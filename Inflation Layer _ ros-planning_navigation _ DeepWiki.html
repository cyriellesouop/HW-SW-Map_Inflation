<!DOCTYPE html>
<!-- saved from url=(0066)https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer -->
<html lang="en" class="light" style="color-scheme: light;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://deepwiki.com/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"><link rel="preload" href="https://deepwiki.com/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"><link rel="stylesheet" href="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/de70bee13400563f.css" data-precedence="next"><link rel="stylesheet" href="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4095ef47de7c7e40.css" data-precedence="next"><link rel="preload" as="script" fetchpriority="low" href="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/webpack-acbbbb548492d4a6.js"><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4bd1b696-cebf68b71ed1e85d.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/1684-e9ef309b586ffd4b.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/main-app-8ab5af3d6b81086e.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/378e5a93-3b0f971d3611a8a5.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/f7f68e2d-40290491c524df5c.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4420-863691215dce8f1b.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4348-824485747071bae4.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/3224-7e9887ea92eab174.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/6967-c4b815e71e97ed18.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/layout-37a15e31a18fac3d.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/7bf36345-06f80506190927ed.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/c16f53c3-1a60b9b77b3e1d4b.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/2249-342d7235b3a68051.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/1769-6bbc7ae2dcadfa9c.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/655-b5574efc1f81bad2.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4154-f7634cd651686b21.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/8613-82346d348221c557.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/4870-3ddb59732948b175.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/page-78fac26cbb8eb9a1.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/3449-a3f74aab9beb2a02.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/7553-2bb9c132a5788553.js" async=""></script><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/1127-b475c4cc62d0a830.js" async=""></script><meta name="next-size-adjust" content=""><title>Inflation Layer | ros-planning/navigation | DeepWiki</title><meta name="description" content="The Inflation Layer is a critical component of the ROS Navigation Stack&#39;s costmap system that expands obstacles to account for the robot&#39;s physical dimensions and create a safety buffer for navigation"><meta property="og:title" content="Inflation Layer | ros-planning/navigation | DeepWiki"><meta property="og:description" content="The Inflation Layer is a critical component of the ROS Navigation Stack&#39;s costmap system that expands obstacles to account for the robot&#39;s physical dimensions and create a safety buffer for navigation"><meta property="og:url" content="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer"><meta property="og:site_name" content="DeepWiki"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Inflation Layer | ros-planning/navigation | DeepWiki"><meta name="twitter:description" content="The Inflation Layer is a critical component of the ROS Navigation Stack&#39;s costmap system that expands obstacles to account for the robot&#39;s physical dimensions and create a safety buffer for navigation"><link rel="icon" href="https://deepwiki.com/favicon.ico" type="image/x-icon" sizes="48x48"><link rel="icon" href="https://deepwiki.com/icon.png?66aaf51e0e68c818" type="image/png" sizes="16x16"><link rel="apple-touch-icon" href="https://deepwiki.com/apple-icon.png?a4f658907db0ab87" type="image/png" sizes="180x180"><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/polyfills-42372ed130431b0a.js" nomodule=""></script><style type="text/css">[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}</style><script id="hotjar-init-script" crossorigin="anonymous">(function(h,o,t,j,a,r){h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};h._hjSettings={hjid:6382967,hjsv:6,hjdebug:false};a=o.getElementsByTagName('head')[0];r=o.createElement('script');r.async=1;r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;a.appendChild(r);})(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');</script><script async="" src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/hotjar-6382967.js"></script><script async="" src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/modules.ce37dfc81afa6fcb9f03.js" charset="utf-8"></script><style type="text/css">
  .with-scroll-bars-hidden {
   overflow: hidden !important;
   padding-right: 15px !important;
  }
  body[data-scroll-locked] {
    overflow: hidden !important;
    overscroll-behavior: contain;
    position: relative !important;
    padding-left: 0px;
    padding-top: 0px;
    padding-right: 0px;
    margin-left:0;
    margin-top:0;
    margin-right: 15px !important;
    
  }
  
  .right-scroll-bar-position {
    right: 15px !important;
  }
  
  .width-before-scroll-bar {
    margin-right: 15px !important;
  }
  
  .right-scroll-bar-position .right-scroll-bar-position {
    right: 0 !important;
  }
  
  .width-before-scroll-bar .width-before-scroll-bar {
    margin-right: 0 !important;
  }
  
  body[data-scroll-locked] {
    --removed-body-scroll-bar-size: 15px;
  }
</style></head><body class="__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased" style="overflow: auto; pointer-events: none;" data-scroll-locked="1"><span data-radix-focus-guard="" tabindex="0" style="outline: none; opacity: 0; position: fixed; pointer-events: none;" data-aria-hidden="true" aria-hidden="true"></span><section aria-label="Notifications alt+T" tabindex="-1" aria-live="polite" aria-relevant="additions text" aria-atomic="false"></section><script data-aria-hidden="true" aria-hidden="true">((e,t,r,n,o,a,i,s)=>{let l=document.documentElement,u=["light","dark"];function c(t){var r;(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(l.classList.remove(...n),l.classList.add(a&&a[t]?a[t]:t)):l.setAttribute(e,t)}),r=t,s&&u.includes(r)&&(l.style.colorScheme=r)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=i&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","light",null,["light","dark"],null,true,true)</script><!--$--><div class="flex min-h-screen w-full flex-col text-white" id="codebase-wiki-repo-page" data-aria-hidden="true" aria-hidden="true"><div class="bg-background border-b-border sticky top-0 z-30 border-b border-dashed"><div class="font-geist-mono relative flex h-8 items-center justify-center text-xs font-medium sm:hidden"><div class="powered-by-devin-gradient absolute inset-0 z-[-1] h-8 w-full"></div><a class="flex items-center gap-2" href="https://deepwiki.com/private-repo"><svg class="size-3 [&amp;_path]:stroke-0 [&amp;_path]:animate-[custom-pulse_1.8s_infinite_var(--delay,0s)]" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="[--delay:0.6s]" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="[--delay:1.2s]" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg>Index your code with Devin</a></div><div class="container-wrapper"><div class="container mx-auto flex w-full flex-row items-center gap-2 py-4 md:py-6"><a class="flex items-center gap-3" href="https://deepwiki.com/"><span class="text-base font-medium leading-none md:text-lg hidden sm:block">DeepWiki</span></a><div class="flex-1"><div class="flex flex-row items-center gap-2"><a class="block text-xs font-medium leading-none text-white sm:hidden md:text-lg" href="https://deepwiki.com/">DeepWiki</a><p class="text-sm font-normal leading-none md:text-lg"><a href="https://github.com/ros-planning/navigation" target="_blank" rel="noopener noreferrer" title="Open repository" class="text-muted-foreground hover:text-muted-foreground/80 group inline-flex items-center gap-1 transition-colors">ros-planning/navigation<!-- --> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="opacity-0 transition-opacity group-hover:opacity-100"><path d="M224,104a8,8,0,0,1-16,0V59.32l-66.33,66.34a8,8,0,0,1-11.32-11.32L196.68,48H152a8,8,0,0,1,0-16h64a8,8,0,0,1,8,8Zm-40,24a8,8,0,0,0-8,8v72H48V80h72a8,8,0,0,0,0-16H48A16,16,0,0,0,32,80V208a16,16,0,0,0,16,16H176a16,16,0,0,0,16-16V136A8,8,0,0,0,184,128Z"></path></svg></a></p></div></div><div class="flex items-center gap-4"><a class="group hidden items-center gap-1.5 md:flex" href="https://deepwiki.com/private-repo"><div class="relative"><span class="text-foreground/70 group-hover:text-foreground text-xs font-light transition-colors">Index your code with</span><div class="bg-foreground/30 absolute bottom-0 left-0 h-[1px] w-0 transition-all duration-300 group-hover:w-full"></div></div><div class="flex items-center gap-1 transition-transform duration-300 group-hover:translate-x-0.5"><svg class="size-4 transform transition-transform duration-700 group-hover:rotate-180 [&amp;_path]:stroke-0" xmlns="http://www.w3.org/2000/svg" viewBox="110 110 460 500"><path style="fill:#21c19a" class="" d="M418.73,332.37c9.84-5.68,22.07-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.58,1.06.19.06.37.11.55.16.87.21,1.76.34,2.65.35.04,0,.08.02.13.02.1,0,.19-.03.29-.04.83-.02,1.64-.13,2.45-.32.14-.03.28-.05.42-.09.87-.24,1.7-.59,2.5-1.03.08-.04.17-.06.25-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.06,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.57-1.06-.19-.06-.37-.11-.56-.16-.88-.21-1.76-.34-2.65-.34-.13,0-.26.02-.4.02-.84.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.24.1.8.44,1.64.79,2.5,1.03.14.04.28.06.42.09.81.19,1.62.3,2.45.32.1,0,.19.04.29.04.04,0,.08-.02.13-.02.89,0,1.77-.13,2.65-.35.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.58-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-.08-.04-.16-.06-.24-.1-.8-.44-1.64-.8-2.51-1.04-.13-.04-.26-.05-.39-.09-.82-.2-1.65-.31-2.49-.33-.13,0-.25-.02-.38-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.75.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.07,5.68-31.9,0-9.84-5.68-15.95-16.27-15.95-27.63s6.11-21.95,15.95-27.63Z"></path><path style="fill:#3969ca" d="M141.09,317.65l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c.08-.04.13-.11.2-.16.78-.48,1.51-1.02,2.15-1.66.1-.1.18-.21.28-.31.57-.6,1.08-1.26,1.51-1.97.07-.12.15-.22.22-.34.44-.77.77-1.6,1.03-2.47.05-.19.1-.37.14-.56.22-.89.37-1.81.37-2.76v-29.43c0-11.36,6.11-21.95,15.96-27.63s22.06-5.68,31.91,0l25.49,14.71c.82.48,1.69.8,2.57,1.06.19.06.37.11.56.16.87.21,1.76.34,2.64.35.04,0,.09.02.13.02.1,0,.19-.04.29-.04.83-.02,1.65-.13,2.45-.32.14-.03.28-.05.41-.09.87-.24,1.71-.6,2.51-1.04.08-.04.16-.06.24-.1l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-.08.04-.13.11-.2.16-.78.48-1.51,1.02-2.15,1.66-.1.1-.18.21-.28.31-.57.6-1.08,1.26-1.51,1.97-.07.12-.15.22-.22.34-.44.77-.77,1.6-1.03,2.47-.05.19-.1.37-.14.56-.22.89-.37,1.81-.37,2.76v29.43c0,11.36-6.11,21.95-15.95,27.63-9.84,5.68-22.07,5.68-31.91,0l-25.49-14.71c-.82-.48-1.69-.8-2.58-1.06-.19-.06-.37-.11-.55-.16-.88-.21-1.76-.34-2.65-.35-.13,0-.26.02-.4.02-.83.02-1.66.13-2.47.32-.13.03-.27.05-.4.09-.87.24-1.71.6-2.51,1.04-.08.04-.16.06-.24.1l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22Z"></path><path style="fill:#0294de" class="" d="M396.88,484.35l-50.97-29.43c-.08-.04-.17-.06-.24-.1-.8-.44-1.64-.79-2.51-1.03-.14-.04-.27-.06-.41-.09-.81-.19-1.64-.3-2.47-.32-.13,0-.26-.02-.39-.02-.89,0-1.78.13-2.66.35-.18.04-.36.1-.54.15-.88.26-1.76.59-2.58,1.07l-25.49,14.72c-9.84,5.68-22.06,5.68-31.9,0-9.84-5.68-15.96-16.27-15.96-27.63v-29.43c0-.95-.15-1.87-.37-2.76-.05-.19-.09-.37-.14-.56-.25-.86-.59-1.69-1.03-2.47-.07-.12-.15-.22-.22-.34-.43-.71-.94-1.37-1.51-1.97-.1-.1-.18-.21-.28-.31-.65-.63-1.37-1.18-2.15-1.66-.07-.04-.13-.11-.2-.16l-50.97-29.43c-3.65-2.11-8.15-2.11-11.81,0l-50.97,29.43c-3.65,2.11-5.9,6.01-5.9,10.22v58.86c0,4.22,2.25,8.11,5.9,10.22l50.97,29.43c.08.04.17.06.25.1.8.44,1.63.79,2.5,1.03.14.04.29.06.43.09.8.19,1.61.3,2.43.32.1,0,.2.04.3.04.04,0,.09-.02.13-.02.88,0,1.77-.13,2.64-.34.19-.04.37-.1.56-.16.88-.26,1.75-.59,2.57-1.06l25.49-14.71c9.84-5.68,22.06-5.68,31.91,0,9.84,5.68,15.95,16.27,15.95,27.63v29.43c0,.95.15,1.87.37,2.76.05.19.09.37.14.56.25.86.59,1.69,1.03,2.47.07.12.15.22.22.34.43.71.94,1.37,1.51,1.97.1.1.18.21.28.31.65.63,1.37,1.18,2.15,1.66.07.04.13.11.2.16l50.97,29.43c1.83,1.05,3.86,1.58,5.9,1.58s4.08-.53,5.9-1.58l50.97-29.43c3.65-2.11,5.9-6.01,5.9-10.22v-58.86c0-4.22-2.25-8.11-5.9-10.22Z"></path></svg><span class="text-sm font-medium">Devin</span></div></a><button aria-label="Edit Wiki" class="flex items-center rounded-md cursor-pointer transition-all border border-border bg-surface hover:border-border-hover hover:bg-component disabled:cursor-default disabled:opacity-50 disabled:hover:border-border disabled:hover:bg-surface gap-2 px-3 py-1.5 text-sm"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 256 256"><path d="M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H216a8,8,0,0,0,0-16H115.32l112-112A16,16,0,0,0,227.32,73.37ZM92.69,208H48V163.31l88-88L180.69,120ZM192,108.69,147.32,64l24-24L216,84.69Z"></path></svg>Edit Wiki</button><button class="flex items-center rounded-md !text-white cursor-pointer transition-all border bg-blue-500 hover:bg-blue-600 border-blue-500 hover:border-blue-600 dark:bg-blue-900 dark:hover:bg-blue-800 dark:border-blue-900 dark:hover:border-blue-800 disabled:cursor-default disabled:opacity-50 disabled:hover:bg-blue-500 disabled:hover:border-blue-500 dark:disabled:hover:bg-blue-900 dark:disabled:hover:border-blue-900 gap-1.5 px-3 py-1.5 text-sm" aria-label="Share" data-state="closed" data-slot="tooltip-trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg><span>Share</span></button><button class="hover:bg-surface-hover flex h-8 w-8 cursor-pointer items-center justify-center rounded-md transition-colors" aria-label="Switch to dark mode"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-5 w-5 text-gray-700"><path d="M235.54,150.21a104.84,104.84,0,0,1-37,52.91A104,104,0,0,1,32,120,103.09,103.09,0,0,1,52.88,57.48a104.84,104.84,0,0,1,52.91-37,8,8,0,0,1,10,10,88.08,88.08,0,0,0,109.8,109.8,8,8,0,0,1,10,10Z"></path></svg></button></div></div></div></div><!--$--><div class="w-full flex-1"><div class="container-wrapper relative mx-auto h-full px-0"><div class="container relative mx-auto flex h-full w-full flex-col gap-0 max-md:!px-0 md:flex-row md:gap-6 lg:gap-10"><div class="border-r-border hidden max-h-screen border-r border-dashed py-6 pr-4 transition-[border-radius] md:sticky md:left-0 md:top-20 md:block md:h-[calc(100vh-82px)] md:w-64 md:flex-shrink-0 md:overflow-y-auto lg:py-9 xl:w-72"><div class="flex h-full w-full max-w-full flex-shrink-0 flex-col overflow-hidden" style="scrollbar-color:var(--color-border) transparent"><div class="flex-shrink-0 px-2"><div class="text-secondary pb-1 text-xs">Last indexed: <!-- -->27 April 2025<!-- --> (<a href="https://github.com/ros-planning/navigation/commits/9ad64419" target="_blank" rel="noopener noreferrer">9ad644</a>)</div></div><ul class="flex-1 flex-shrink-0 space-y-1 overflow-y-auto py-1" style="scrollbar-width:none"><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/1-overview">Overview</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/1.1-architecture">Architecture</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/1.2-packages">Packages</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/1.3-plugin-system">Plugin System</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2-costmap2d">Costmap2D</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.1-costmap2dros">Costmap2DROS</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.2-layeredcostmap">LayeredCostmap</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.3-costmap-layers">Costmap Layers</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.3.1-static-layer">Static Layer</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.3.2-obstacle-layer">Obstacle Layer</a></li><li style="padding-left:24px"><a data-selected="true" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer">Inflation Layer</a></li><li style="padding-left:24px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/2.3.4-voxel-layer">Voxel Layer</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/3-move-base">Move Base</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/3.1-state-machine">State Machine</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/3.2-action-interface">Action Interface</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/3.3-configuration">Configuration</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/4-global-planners">Global Planners</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/4.1-navfn">Navfn</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/4.2-global-planner">Global Planner</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/4.3-carrot-planner">Carrot Planner</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/5-local-planners">Local Planners</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/5.1-base-local-planner">Base Local Planner</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/5.2-dwa-local-planner">DWA Local Planner</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/6-localization">Localization</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/6.1-amcl">AMCL</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/6.2-fake-localization">Fake Localization</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/7-recovery-behaviors">Recovery Behaviors</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/7.1-clear-costmap-recovery">Clear Costmap Recovery</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/7.2-rotate-recovery">Rotate Recovery</a></li><li style="padding-left:12px"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/7.3-move-slow-and-clear">Move Slow and Clear</a></li><li style="padding-left:0"><a data-selected="false" class="hover:bg-hover block w-full rounded px-2 py-1.5 text-left text-sm transition-none text-secondary data-[selected=true]:bg-hover data-[selected=true]:text-primary font-normal data-[selected=true]:font-normal" href="https://deepwiki.com/ros-planning/navigation/8-map-server">Map Server</a></li></ul></div></div><div class="flex h-full flex-1 flex-col overflow-hidden"><div class="bg-background border-b-border sticky top-0 z-10 border-b border-dashed md:hidden"><div class="flex cursor-pointer items-center gap-2 p-3"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256" class="transition-transform"><path d="M184.49,136.49l-80,80a12,12,0,0,1-17-17L159,128,87.51,56.49a12,12,0,1,1,17-17l80,80A12,12,0,0,1,184.49,136.49Z"></path></svg><span class="truncate text-base font-normal">Menu</span></div></div><div class="relative flex-1 overflow-y-auto px-3 pt-3 md:rounded-md md:px-0 md:pt-0 [&amp;_::selection]:bg-purple-500/40" style="scrollbar-color:var(--color-night) transparent"><div class="pb-30 mx-auto max-w-2xl md:pb-40 md:pt-6 lg:pt-8"><div class="prose prose-invert dark:prose-invert prose-headings:text-inherit prose-p:text-inherit max-w-none"><div><div class="prose-custom prose-custom-md prose-custom-gray !max-w-none text-neutral-300 [overflow-wrap:anywhere]"><h1 id="inflation-layer" class="group" data-header="true">Inflation Layer<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h1>
<details>
<summary>Relevant source files</summary>
<ul>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/obstacle_layer.h" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/obstacle_layer.h</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/static_layer.h" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/static_layer.h</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/voxel_layer.h" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/voxel_layer.h</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/obstacle_layer.cpp" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/obstacle_layer.cpp</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/static_layer.cpp" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/static_layer.cpp</span></a></li>
<li><a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/voxel_layer.cpp" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4] rounded-r"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/voxel_layer.cpp</span></a></li>
</ul>
</details>
<p>The Inflation Layer is a critical component of the ROS Navigation Stack's costmap system that expands obstacles to account for the robot's physical dimensions and create a safety buffer for navigation. This page explains how the Inflation Layer works, its configuration parameters, and its role in the layered costmap architecture.</p>
<p>For information about the overall layered costmap system, see <a href="https://deepwiki.com/ros-planning/navigation/2.3-costmap-layers" class="text-neutral-300 hover:text-neutral-200 hover:underline">Costmap Layers</a>. For specific details about other layers, see <a href="https://deepwiki.com/ros-planning/navigation/2.3.1-static-layer" class="text-neutral-300 hover:text-neutral-200 hover:underline">Static Layer</a>, <a href="https://deepwiki.com/ros-planning/navigation/2.3.2-obstacle-layer" class="text-neutral-300 hover:text-neutral-200 hover:underline">Obstacle Layer</a>, or <a href="https://deepwiki.com/ros-planning/navigation/2.3.4-voxel-layer" class="text-neutral-300 hover:text-neutral-200 hover:underline">Voxel Layer</a>.</p>
<h2 id="purpose-and-function" class="group" data-header="true">Purpose and Function<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The Inflation Layer's primary responsibility is to take obstacles identified by other layers (such as the Static Layer or Obstacle Layer) and expand them by a configurable inflation radius. This expansion is crucial for two reasons:</p>
<ol>
<li>It ensures that the robot's planning systems account for the robot's physical footprint, not just its center point</li>
<li>It creates a graduated cost gradient around obstacles, enabling smoother path planning that keeps the robot at a safe distance from obstacles</li>
</ol>
<p>Without inflation, a planner might attempt to place the robot's center exactly at the edge of an obstacle, which would result in a collision since the robot has physical dimensions.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h#L73-L119" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">73-119</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L104-L118" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">104-118</span></a></p>
<h2 id="how-the-inflation-layer-works" class="group" data-header="true">How the Inflation Layer Works<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="group relative cursor-pointer overflow-x-auto rounded-md bg-[#f2f1f0] p-4 transition-colors hover:bg-[#ededed] dark:bg-[#1f1f1f] dark:hover:bg-[#242424]" type="button" aria-haspopup="dialog" aria-expanded="true" aria-controls="radix-r3" data-state="open" data-slot="dialog-trigger"><div class="flex justify-center"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="-4.755791664123535 0.6281562447547913 1265.203125 781" style="max-width: 100%; touch-action: none; user-select: none; cursor: grab; min-height: fit-content; max-height: 100%;" class="flowchart" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" id="mermaid-yi0e9ihi7p" preserveAspectRatio="xMidYMid meet"><style>#mermaid-yi0e9ihi7p{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-yi0e9ihi7p .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-yi0e9ihi7p .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-yi0e9ihi7p .error-icon{fill:#dddddd;}#mermaid-yi0e9ihi7p .error-text{fill:#222222;stroke:#222222;}#mermaid-yi0e9ihi7p .edge-thickness-normal{stroke-width:1px;}#mermaid-yi0e9ihi7p .edge-thickness-thick{stroke-width:3.5px;}#mermaid-yi0e9ihi7p .edge-pattern-solid{stroke-dasharray:0;}#mermaid-yi0e9ihi7p .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-yi0e9ihi7p .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-yi0e9ihi7p .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-yi0e9ihi7p .marker{fill:#999;stroke:#999;}#mermaid-yi0e9ihi7p .marker.cross{stroke:#999;}#mermaid-yi0e9ihi7p svg{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;}#mermaid-yi0e9ihi7p p{margin:0;}#mermaid-yi0e9ihi7p .label{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;color:#333;}#mermaid-yi0e9ihi7p .cluster-label text{fill:#444;}#mermaid-yi0e9ihi7p .cluster-label span{color:#444;}#mermaid-yi0e9ihi7p .cluster-label span p{background-color:transparent;}#mermaid-yi0e9ihi7p .label text,#mermaid-yi0e9ihi7p span{fill:#333;color:#333;}#mermaid-yi0e9ihi7p .node rect,#mermaid-yi0e9ihi7p .node circle,#mermaid-yi0e9ihi7p .node ellipse,#mermaid-yi0e9ihi7p .node polygon,#mermaid-yi0e9ihi7p .node path{fill:#ffffff;stroke:#dddddd;stroke-width:1px;}#mermaid-yi0e9ihi7p .rough-node .label text,#mermaid-yi0e9ihi7p .node .label text,#mermaid-yi0e9ihi7p .image-shape .label,#mermaid-yi0e9ihi7p .icon-shape .label{text-anchor:middle;}#mermaid-yi0e9ihi7p .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-yi0e9ihi7p .rough-node .label,#mermaid-yi0e9ihi7p .node .label,#mermaid-yi0e9ihi7p .image-shape .label,#mermaid-yi0e9ihi7p .icon-shape .label{text-align:center;}#mermaid-yi0e9ihi7p .node.clickable{cursor:pointer;}#mermaid-yi0e9ihi7p .root .anchor path{fill:#999!important;stroke-width:0;stroke:#999;}#mermaid-yi0e9ihi7p .arrowheadPath{fill:#0b0b0b;}#mermaid-yi0e9ihi7p .edgePath .path{stroke:#999;stroke-width:2.0px;}#mermaid-yi0e9ihi7p .flowchart-link{stroke:#999;fill:none;}#mermaid-yi0e9ihi7p .edgeLabel{background-color:#ffffff;text-align:center;}#mermaid-yi0e9ihi7p .edgeLabel p{background-color:#ffffff;}#mermaid-yi0e9ihi7p .edgeLabel rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-yi0e9ihi7p .labelBkg{background-color:rgba(255, 255, 255, 0.5);}#mermaid-yi0e9ihi7p .cluster rect{fill:#f8f8f8;stroke:#dddddd;stroke-width:1px;}#mermaid-yi0e9ihi7p .cluster text{fill:#444;}#mermaid-yi0e9ihi7p .cluster span{color:#444;}#mermaid-yi0e9ihi7p div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:12px;background:#dddddd;border:1px solid hsl(0, 0%, 76.6666666667%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-yi0e9ihi7p .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-yi0e9ihi7p rect.text{fill:none;stroke-width:0;}#mermaid-yi0e9ihi7p .icon-shape,#mermaid-yi0e9ihi7p .image-shape{background-color:#ffffff;text-align:center;}#mermaid-yi0e9ihi7p .icon-shape p,#mermaid-yi0e9ihi7p .image-shape p{background-color:#ffffff;padding:2px;}#mermaid-yi0e9ihi7p .icon-shape rect,#mermaid-yi0e9ihi7p .image-shape rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-yi0e9ihi7p :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(0, 88.5)" class="root"><g class="clusters"><g data-look="classic" id="subGraph1" class="cluster"><rect height="588" width="753.79296875" y="8" x="8" style=""></rect><g transform="translate(323.748046875, 8)" class="cluster-label"><foreignobject height="24" width="122.296875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost Assignment</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X_Y_0" d="M257.036,99.5L242.245,105.75C227.454,112,197.871,124.5,183.08,138.333C168.289,152.167,168.289,167.333,168.289,174.917L168.289,182.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X_Z_0" d="M384.831,99.5L399.622,105.75C414.414,112,443.996,124.5,458.787,136.333C473.578,148.167,473.578,159.333,473.578,164.917L473.578,170.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Z_W_0" d="M402.66,252.5L391.294,258.75C379.929,265,357.199,277.5,345.834,289.333C334.469,301.167,334.469,312.333,334.469,317.917L334.469,323.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Z_V_0" d="M536.579,252.5L546.675,258.75C556.771,265,576.964,277.5,587.06,291.333C597.156,305.167,597.156,320.333,597.156,327.917L597.156,335.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_V_U_0" d="M597.156,393.5L597.156,401.75C597.156,410,597.156,426.5,597.156,440.333C597.156,454.167,597.156,465.333,597.156,470.917L597.156,476.5"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(320.93359375, 72.5)" id="flowchart-X-10" class="node default"><rect height="54" width="160.578125" y="-27" x="-80.2890625" style="" class="basic label-container"></rect><g transform="translate(-50.2890625, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="100.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>If distance = 0</p></span></div></foreignobject></g></g><g transform="translate(168.2890625, 213.5)" id="flowchart-Y-11" class="node default"><rect height="54" width="250.578125" y="-27" x="-125.2890625" style="" class="basic label-container"></rect><g transform="translate(-95.2890625, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="190.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = LETHAL_OBSTACLE</p></span></div></foreignobject></g></g><g transform="translate(473.578125, 213.5)" id="flowchart-Z-13" class="node default"><rect height="78" width="260" y="-39" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>If distance &lt;= inscribed_radius</p></span></div></foreignobject></g></g><g transform="translate(334.46875, 366.5)" id="flowchart-W-15" class="node default"><rect height="78" width="304.71875" y="-39" x="-152.359375" style="" class="basic label-container"></rect><g transform="translate(-122.359375, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="244.71875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = INSCRIBED_INFLATED_OBSTACLE</p></span></div></foreignobject></g></g><g transform="translate(597.15625, 366.5)" id="flowchart-V-17" class="node default"><rect height="54" width="89.59375" y="-27" x="-44.796875" style="" class="basic label-container"></rect><g transform="translate(-14.796875, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="29.59375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Else</p></span></div></foreignobject></g></g><g transform="translate(597.15625, 519.5)" id="flowchart-U-19" class="node default"><rect height="78" width="258.546875" y="-39" x="-129.2734375" style="" class="basic label-container"></rect><g transform="translate(-99.2734375, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="198.546875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = exponential decay<br>based on distance &amp; weight</p></span></div></foreignobject></g></g></g></g><g transform="translate(803.79296875, 0)" class="root"><g class="clusters"><g data-look="classic" id="subGraph0" class="cluster"><rect height="765" width="445.41015625" y="8" x="8" style=""></rect><g transform="translate(170.080078125, 8)" class="cluster-label"><foreignobject height="24" width="121.25"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Inflation Process</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M248.715,123.5L248.715,129.75C248.715,136,248.715,148.5,248.715,160.333C248.715,172.167,248.715,183.333,248.715,188.917L248.715,194.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M248.715,276.5L248.715,282.75C248.715,289,248.715,301.5,248.715,313.333C248.715,325.167,248.715,336.333,248.715,341.917L248.715,347.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M202.217,429.5L194.766,435.75C187.314,442,172.411,454.5,164.959,466.333C157.508,478.167,157.508,489.333,157.508,494.917L157.508,500.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_0" d="M157.508,582.5L157.508,588.75C157.508,595,157.508,607.5,164.449,619.572C171.389,631.643,185.271,643.286,192.212,649.108L199.152,654.929"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_C_0" d="M295.213,657.5L302.664,651.25C310.116,645,325.019,632.5,332.47,613.5C339.922,594.5,339.922,569,339.922,543.5C339.922,518,339.922,492.5,332.981,473.928C326.04,455.357,312.159,443.714,305.218,437.892L298.277,432.071"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g transform="translate(339.921875, 543.5)" class="edgeLabel"><g transform="translate(-45.1875, -12)" class="label"><foreignobject height="24" width="90.375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>For each cell</p></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(248.71484375, 84.5)" id="flowchart-A-0" class="node default"><rect height="78" width="237.4375" y="-39" x="-118.71875" style="" class="basic label-container"></rect><g transform="translate(-88.71875, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="177.4375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Initialize with<br>LETHAL_OBSTACLE cells</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 237.5)" id="flowchart-B-1" class="node default"><rect height="78" width="222.515625" y="-39" x="-111.2578125" style="" class="basic label-container"></rect><g transform="translate(-81.2578125, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="162.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Place cells in<br>distance-sorted queue</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 390.5)" id="flowchart-C-3" class="node default"><rect height="78" width="242.28125" y="-39" x="-121.140625" style="" class="basic label-container"></rect><g transform="translate(-91.140625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="182.28125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Process cells in<br>increasing distance order</p></span></div></foreignobject></g></g><g transform="translate(157.5078125, 543.5)" id="flowchart-D-5" class="node default"><rect height="78" width="204.453125" y="-39" x="-102.2265625" style="" class="basic label-container"></rect><g transform="translate(-72.2265625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="144.453125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Assign cost based<br>on distance formula</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 696.5)" id="flowchart-E-7" class="node default"><rect height="78" width="253.578125" y="-39" x="-126.7890625" style="" class="basic label-container"></rect><g transform="translate(-96.7890625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="193.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Add neighbors to queue<br>with appropriate distances</p></span></div></foreignobject></g></g></g></g></g></g></g></svg></div><div class="bg-input-dark absolute right-2 top-2 rounded-sm p-1 opacity-0 transition-opacity group-hover:opacity-100"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256"><path d="M216,48V96a8,8,0,0,1-16,0V67.31l-42.34,42.35a8,8,0,0,1-11.32-11.32L188.69,56H160a8,8,0,0,1,0-16h48A8,8,0,0,1,216,48ZM98.34,146.34,56,188.69V160a8,8,0,0,0-16,0v48a8,8,0,0,0,8,8H96a8,8,0,0,0,0-16H67.31l42.35-42.34a8,8,0,0,0-11.32-11.32ZM208,152a8,8,0,0,0-8,8v28.69l-42.34-42.35a8,8,0,0,0-11.32,11.32L188.69,200H160a8,8,0,0,0,0,16h48a8,8,0,0,0,8-8V160A8,8,0,0,0,208,152ZM67.31,56H96a8,8,0,0,0,0-16H48a8,8,0,0,0-8,8V96a8,8,0,0,0,16,0V67.31l42.34,42.35a8,8,0,0,0,11.32-11.32Z"></path></svg></div></div></pre>
<p>The inflation algorithm operates by:</p>
<ol>
<li>Identifying all lethal obstacle cells in the relevant area of the costmap</li>
<li>Organizing these cells into a queue sorted by distance from obstacles</li>
<li>Processing cells in order of increasing distance</li>
<li>Assigning costs to cells based on their distance from the nearest obstacle</li>
<li>Adding neighboring cells to the processing queue</li>
</ol>
<p>The cost assigned to each cell follows these rules:</p>
<ul>
<li>Cells containing obstacles (distance = 0) receive <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">LETHAL_OBSTACLE</code> cost (254)</li>
<li>Cells within the inscribed radius receive <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">INSCRIBED_INFLATED_OBSTACLE</code> cost (253)</li>
<li>Cells beyond the inscribed radius but within the inflation radius receive a cost that decays exponentially with distance</li>
</ul>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L176-L280" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">176-280</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h#L104-L119" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">104-119</span></a></p>
<h2 id="core-data-structures" class="group" data-header="true">Core Data Structures<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="group relative cursor-pointer overflow-x-auto rounded-md bg-[#f2f1f0] p-4 transition-colors hover:bg-[#ededed] dark:bg-[#1f1f1f] dark:hover:bg-[#242424]" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-r6" data-state="closed" data-slot="dialog-trigger"><div class="flex justify-center"><svg aria-roledescription="class" role="graphics-document document" viewBox="0 0 282.640625 890" style="max-width: 100%; touch-action: none; user-select: none; cursor: grab; min-height: fit-content; max-height: 100%;" class="classDiagram" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" id="mermaid-k0kzf6kv71" preserveAspectRatio="xMidYMid meet"><style>#mermaid-k0kzf6kv71{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-k0kzf6kv71 .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-k0kzf6kv71 .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-k0kzf6kv71 .error-icon{fill:#dddddd;}#mermaid-k0kzf6kv71 .error-text{fill:#222222;stroke:#222222;}#mermaid-k0kzf6kv71 .edge-thickness-normal{stroke-width:1px;}#mermaid-k0kzf6kv71 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-k0kzf6kv71 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-k0kzf6kv71 .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-k0kzf6kv71 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-k0kzf6kv71 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-k0kzf6kv71 .marker{fill:#999;stroke:#999;}#mermaid-k0kzf6kv71 .marker.cross{stroke:#999;}#mermaid-k0kzf6kv71 svg{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;}#mermaid-k0kzf6kv71 p{margin:0;}#mermaid-k0kzf6kv71 g.classGroup text{fill:#dddddd;stroke:none;font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:10px;}#mermaid-k0kzf6kv71 g.classGroup text .title{font-weight:bolder;}#mermaid-k0kzf6kv71 .nodeLabel,#mermaid-k0kzf6kv71 .edgeLabel{color:#333333;}#mermaid-k0kzf6kv71 .edgeLabel .label rect{fill:#ffffff;}#mermaid-k0kzf6kv71 .label text{fill:#333333;}#mermaid-k0kzf6kv71 .labelBkg{background:#ffffff;}#mermaid-k0kzf6kv71 .edgeLabel .label span{background:#ffffff;}#mermaid-k0kzf6kv71 .classTitle{font-weight:bolder;}#mermaid-k0kzf6kv71 .node rect,#mermaid-k0kzf6kv71 .node circle,#mermaid-k0kzf6kv71 .node ellipse,#mermaid-k0kzf6kv71 .node polygon,#mermaid-k0kzf6kv71 .node path{fill:#ffffff;stroke:#dddddd;stroke-width:1px;}#mermaid-k0kzf6kv71 .divider{stroke:#dddddd;stroke-width:1;}#mermaid-k0kzf6kv71 g.clickable{cursor:pointer;}#mermaid-k0kzf6kv71 g.classGroup rect{fill:#ffffff;stroke:#dddddd;}#mermaid-k0kzf6kv71 g.classGroup line{stroke:#dddddd;stroke-width:1;}#mermaid-k0kzf6kv71 .classLabel .box{stroke:none;stroke-width:0;fill:#ffffff;opacity:0.5;}#mermaid-k0kzf6kv71 .classLabel .label{fill:#dddddd;font-size:10px;}#mermaid-k0kzf6kv71 .relation{stroke:#999;stroke-width:1;fill:none;}#mermaid-k0kzf6kv71 .dashed-line{stroke-dasharray:3;}#mermaid-k0kzf6kv71 .dotted-line{stroke-dasharray:1 2;}#mermaid-k0kzf6kv71 #compositionStart,#mermaid-k0kzf6kv71 .composition{fill:#999!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #compositionEnd,#mermaid-k0kzf6kv71 .composition{fill:#999!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #dependencyStart,#mermaid-k0kzf6kv71 .dependency{fill:#999!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #dependencyStart,#mermaid-k0kzf6kv71 .dependency{fill:#999!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #extensionStart,#mermaid-k0kzf6kv71 .extension{fill:transparent!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #extensionEnd,#mermaid-k0kzf6kv71 .extension{fill:transparent!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #aggregationStart,#mermaid-k0kzf6kv71 .aggregation{fill:transparent!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #aggregationEnd,#mermaid-k0kzf6kv71 .aggregation{fill:transparent!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #lollipopStart,#mermaid-k0kzf6kv71 .lollipop{fill:#ffffff!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 #lollipopEnd,#mermaid-k0kzf6kv71 .lollipop{fill:#ffffff!important;stroke:#999!important;stroke-width:1;}#mermaid-k0kzf6kv71 .edgeTerminals{font-size:11px;line-height:initial;}#mermaid-k0kzf6kv71 .classTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-k0kzf6kv71 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="18" class="marker aggregation class" id="mermaid-k0kzf6kv71_class-aggregationStart"><path d="M 18,7 L9,13 L1,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="28" markerWidth="20" refY="7" refX="1" class="marker aggregation class" id="mermaid-k0kzf6kv71_class-aggregationEnd"><path d="M 18,7 L9,13 L1,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="18" class="marker extension class" id="mermaid-k0kzf6kv71_class-extensionStart"><path d="M 1,7 L18,13 V 1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="28" markerWidth="20" refY="7" refX="1" class="marker extension class" id="mermaid-k0kzf6kv71_class-extensionEnd"><path d="M 1,1 V 13 L18,7 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="18" class="marker composition class" id="mermaid-k0kzf6kv71_class-compositionStart"><path d="M 18,7 L9,13 L1,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="28" markerWidth="20" refY="7" refX="1" class="marker composition class" id="mermaid-k0kzf6kv71_class-compositionEnd"><path d="M 18,7 L9,13 L1,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="6" class="marker dependency class" id="mermaid-k0kzf6kv71_class-dependencyStart"><path d="M 5,7 L9,13 L1,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="28" markerWidth="20" refY="7" refX="13" class="marker dependency class" id="mermaid-k0kzf6kv71_class-dependencyEnd"><path d="M 18,7 L9,13 L14,7 L9,1 Z"></path></marker></defs><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="13" class="marker lollipop class" id="mermaid-k0kzf6kv71_class-lollipopStart"><circle r="6" cy="7" cx="7" fill="transparent" stroke="black"></circle></marker></defs><defs><marker orient="auto" markerHeight="240" markerWidth="190" refY="7" refX="1" class="marker lollipop class" id="mermaid-k0kzf6kv71_class-lollipopEnd"><circle r="6" cy="7" cx="7" fill="transparent" stroke="black"></circle></marker></defs><g class="root"><g class="clusters"></g><g class="edgePaths"><path style=";" class="edge-thickness-normal edge-pattern-solid relation" id="id_InflationLayer_CellData_1" d="M141.32,592L141.32,598.167C141.32,604.333,141.32,616.667,141.32,629C141.32,641.333,141.32,653.667,141.32,659.833L141.32,666"></path><path marker-start="url(#mermaid-k0kzf6kv71_class-extensionStart)" style=";" class="edge-thickness-normal edge-pattern-solid relation" id="id_Layer_InflationLayer_2" d="M141.32,224L141.32,227.167C141.32,230.333,141.32,236.667,141.32,246C141.32,255.333,141.32,267.667,141.32,273.833L141.32,280"></path></g><g class="edgeLabels"><g transform="translate(141.3203125, 629)" class="edgeLabel"><g transform="translate(-16.203125, -12)" class="label"><foreignobject height="24" width="32.40625"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style=";display: inline-block"><p>uses</p></span></div></foreignobject></g></g><g transform="translate(141.3203125, 243)" class="edgeLabel"><g transform="translate(-43.0234375, -12)" class="label"><foreignobject height="24" width="86.046875"><div class="labelBkg" xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="edgeLabel" style=";display: inline-block"><p>implements</p></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(141.3203125, 436)" id="classId-InflationLayer-0" class="node default"><g class="basic label-container"><path style="" fill="#ffffff" stroke-width="0" stroke="none" d="M-133.3203125 -156 L133.3203125 -156 L133.3203125 156 L-133.3203125 156"></path><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-133.3203125 -156 C-78.88090188628479 -156, -24.441491272569593 -156, 133.3203125 -156 M-133.3203125 -156 C-67.15349113257791 -156, -0.986669765155824 -156, 133.3203125 -156 M133.3203125 -156 C133.3203125 -80.20823848903491, 133.3203125 -4.416476978069824, 133.3203125 156 M133.3203125 -156 C133.3203125 -54.62412641253887, 133.3203125 46.75174717492226, 133.3203125 156 M133.3203125 156 C44.48886380470492 156, -44.34258489059016 156, -133.3203125 156 M133.3203125 156 C30.77712690580769 156, -71.76605868838462 156, -133.3203125 156 M-133.3203125 156 C-133.3203125 40.3231984866695, -133.3203125 -75.353603026661, -133.3203125 -156 M-133.3203125 156 C-133.3203125 71.27272885988069, -133.3203125 -13.454542280238627, -133.3203125 -156"></path></g><g transform="translate(0, -132)" class="annotation-group text"></g><g transform="translate(-54.34375, -132)" class="label-group text"><g transform="translate(0,-12)" style="font-weight: bolder" class="label"><foreignobject height="24" width="108.6875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 151px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>InflationLayer</p></span></div></foreignobject></g></g><g transform="translate(-121.3203125, -84)" class="members-group text"><g transform="translate(0,-12)" style="" class="label"><foreignobject height="24" width="184.5625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 245px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>-inflation_radius_: double</p></span></div></foreignobject></g><g transform="translate(0,12)" style="" class="label"><foreignobject height="24" width="121.3125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 181px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>-weight_: double</p></span></div></foreignobject></g><g transform="translate(0,36)" style="" class="label"><foreignobject height="24" width="175"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 236px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>-inflate_unknown_: bool</p></span></div></foreignobject></g></g><g transform="translate(-121.3203125, 12)" class="methods-group text"><g transform="translate(0,-12)" style="" class="label"><foreignobject height="24" width="100.265625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 154px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+onInitialize()</p></span></div></foreignobject></g><g transform="translate(0,12)" style="" class="label"><foreignobject height="24" width="126.9375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 182px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+updateBounds()</p></span></div></foreignobject></g><g transform="translate(0,36)" style="" class="label"><foreignobject height="24" width="112.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 169px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+updateCosts()</p></span></div></foreignobject></g><g transform="translate(0,60)" style="" class="label"><foreignobject height="24" width="188.296875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 242px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+setInflationParameters()</p></span></div></foreignobject></g><g transform="translate(0,84)" style="" class="label"><foreignobject height="24" width="131.640625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 192px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>-computeCaches()</p></span></div></foreignobject></g><g transform="translate(0,108)" style="" class="label"><foreignobject height="24" width="80.25"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 136px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>-enqueue()</p></span></div></foreignobject></g></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-133.3203125 -108 C-66.82863145963624 -108, -0.33695041927248326 -108, 133.3203125 -108 M-133.3203125 -108 C-65.22332822256881 -108, 2.87365605486238 -108, 133.3203125 -108"></path></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-133.3203125 -12 C-56.53210919001485 -12, 20.2560941199703 -12, 133.3203125 -12 M-133.3203125 -12 C-65.43459716647845 -12, 2.4511181670430915 -12, 133.3203125 -12"></path></g></g><g transform="translate(141.3203125, 774)" id="classId-CellData-1" class="node default"><g class="basic label-container"><path style="" fill="#ffffff" stroke-width="0" stroke="none" d="M-105.4921875 -108 L105.4921875 -108 L105.4921875 108 L-105.4921875 108"></path><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-105.4921875 -108 C-57.55127228866232 -108, -9.610357077324636 -108, 105.4921875 -108 M-105.4921875 -108 C-62.57370410222092 -108, -19.655220704441845 -108, 105.4921875 -108 M105.4921875 -108 C105.4921875 -45.38983346291255, 105.4921875 17.220333074174903, 105.4921875 108 M105.4921875 -108 C105.4921875 -38.248095209920876, 105.4921875 31.503809580158247, 105.4921875 108 M105.4921875 108 C41.36804453912099 108, -22.756098421758026 108, -105.4921875 108 M105.4921875 108 C51.88585237503528 108, -1.7204827499294453 108, -105.4921875 108 M-105.4921875 108 C-105.4921875 28.4226279739935, -105.4921875 -51.154744052013, -105.4921875 -108 M-105.4921875 108 C-105.4921875 46.51144001294924, -105.4921875 -14.977119974101527, -105.4921875 -108"></path></g><g transform="translate(0, -84)" class="annotation-group text"></g><g transform="translate(-32.953125, -84)" class="label-group text"><g transform="translate(0,-12)" style="font-weight: bolder" class="label"><foreignobject height="24" width="65.90625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 113px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>CellData</p></span></div></foreignobject></g></g><g transform="translate(-93.4921875, -36)" class="members-group text"><g transform="translate(0,-12)" style="" class="label"><foreignobject height="24" width="154.03125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 214px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+index_: unsigned int</p></span></div></foreignobject></g><g transform="translate(0,12)" style="" class="label"><foreignobject height="24" width="122.421875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 183px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+x_: unsigned int</p></span></div></foreignobject></g><g transform="translate(0,36)" style="" class="label"><foreignobject height="24" width="122.203125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 183px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+y_: unsigned int</p></span></div></foreignobject></g><g transform="translate(0,60)" style="" class="label"><foreignobject height="24" width="151.046875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 215px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+src_x_: unsigned int</p></span></div></foreignobject></g><g transform="translate(0,84)" style="" class="label"><foreignobject height="24" width="150.828125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 214px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+src_y_: unsigned int</p></span></div></foreignobject></g></g><g transform="translate(-93.4921875, 108)" class="methods-group text"></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-105.4921875 -60 C-50.899257216684575 -60, 3.6936730666308506 -60, 105.4921875 -60 M-105.4921875 -60 C-58.93680394271011 -60, -12.381420385420213 -60, 105.4921875 -60"></path></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-105.4921875 84 C-29.563334206417082 84, 46.365519087165836 84, 105.4921875 84 M-105.4921875 84 C-26.875921043395877 84, 51.740345413208246 84, 105.4921875 84"></path></g></g><g transform="translate(141.3203125, 107)" id="classId-Layer-2" class="node default"><g class="basic label-container"><path style="" fill="#ffffff" stroke-width="0" stroke="none" d="M-95.84765625 -99 L95.84765625 -99 L95.84765625 99 L-95.84765625 99"></path><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-95.84765625 -99 C-42.37666160162165 -99, 11.094333046756702 -99, 95.84765625 -99 M-95.84765625 -99 C-54.56778987486169 -99, -13.287923499723377 -99, 95.84765625 -99 M95.84765625 -99 C95.84765625 -48.1575013567083, 95.84765625 2.684997286583396, 95.84765625 99 M95.84765625 -99 C95.84765625 -30.06808807837011, 95.84765625 38.86382384325978, 95.84765625 99 M95.84765625 99 C48.67641078521935 99, 1.5051653204387065 99, -95.84765625 99 M95.84765625 99 C19.4036358928725 99, -57.040384464255 99, -95.84765625 99 M-95.84765625 99 C-95.84765625 43.547400397896425, -95.84765625 -11.90519920420715, -95.84765625 -99 M-95.84765625 99 C-95.84765625 28.58558991696735, -95.84765625 -41.8288201660653, -95.84765625 -99"></path></g><g transform="translate(-40.7578125, -75)" class="annotation-group text"><g transform="translate(0,-12)" style="" class="label"><foreignobject height="24" width="81.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 132px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>interface</p></span></div></foreignobject></g></g><g transform="translate(-21.234375, -51)" class="label-group text"><g transform="translate(0,-12)" style="font-weight: bolder" class="label"><foreignobject height="24" width="42.46875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 91px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>Layer</p></span></div></foreignobject></g></g><g transform="translate(-83.84765625, -3)" class="members-group text"></g><g transform="translate(-83.84765625, 27)" class="methods-group text"><g transform="translate(0,-12)" style="" class="label"><foreignobject height="24" width="126.9375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 182px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+updateBounds()</p></span></div></foreignobject></g><g transform="translate(0,12)" style="" class="label"><foreignobject height="24" width="112.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 169px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+updateCosts()</p></span></div></foreignobject></g><g transform="translate(0,36)" style="" class="label"><foreignobject height="24" width="100.265625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 154px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span style="" class="nodeLabel markdown-node-label"><p>+onInitialize()</p></span></div></foreignobject></g></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-95.84765625 -27 C-32.58793835437402 -27, 30.671779541251965 -27, 95.84765625 -27 M-95.84765625 -27 C-30.935944852279974 -27, 33.97576654544005 -27, 95.84765625 -27"></path></g><g style="" class="divider"><path style="" fill="none" stroke-width="1.3" stroke="#dddddd" d="M-95.84765625 -3 C-31.887879660582932 -3, 32.071896928834136 -3, 95.84765625 -3 M-95.84765625 -3 C-24.917412601980942 -3, 46.012831046038116 -3, 95.84765625 -3"></path></g></g></g></g></g></svg></div><div class="bg-input-dark absolute right-2 top-2 rounded-sm p-1 opacity-0 transition-opacity group-hover:opacity-100"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256"><path d="M216,48V96a8,8,0,0,1-16,0V67.31l-42.34,42.35a8,8,0,0,1-11.32-11.32L188.69,56H160a8,8,0,0,1,0-16h48A8,8,0,0,1,216,48ZM98.34,146.34,56,188.69V160a8,8,0,0,0-16,0v48a8,8,0,0,0,8,8H96a8,8,0,0,0,0-16H67.31l42.35-42.34a8,8,0,0,0-11.32-11.32ZM208,152a8,8,0,0,0-8,8v28.69l-42.34-42.35a8,8,0,0,0-11.32,11.32L188.69,200H160a8,8,0,0,0,0,16h48a8,8,0,0,0,8-8V160A8,8,0,0,0,208,152ZM67.31,56H96a8,8,0,0,0,0-16H48a8,8,0,0,0-8,8V96a8,8,0,0,0,16,0V67.31l42.34,42.35a8,8,0,0,0,11.32-11.32Z"></path></svg></div></div></pre>
<p>The <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">InflationLayer</code> class inherits from the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">Layer</code> interface and implements its required methods. It also uses a supporting <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">CellData</code> class to track cells during the inflation process.</p>
<p>Key internal data structures:</p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">inflation_cells_</code>: A map of distance to vector of cells at that distance</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">cached_costs_</code>: Precomputed costs based on distance</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">cached_distances_</code>: Precomputed distances for efficiency</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">seen_</code>: A boolean array to track which cells have been processed</li>
</ul>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h#L54-L73" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">54-73</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h#L75-L196" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">75-196</span></a></p>
<h2 id="inflation-cost-calculation" class="group" data-header="true">Inflation Cost Calculation<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The cost of inflated cells is calculated using an exponential decay function:</p>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">If distance == 0:
    cost = LETHAL_OBSTACLE (254)
Else if distance &lt;= inscribed_radius:
    cost = INSCRIBED_INFLATED_OBSTACLE (253)
Else:
    factor = exp(-1.0 * weight * (distance - inscribed_radius))
    cost = (INSCRIBED_INFLATED_OBSTACLE - 1) * factor
</code></pre>
<p>Where:</p>
<ul>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">distance</code> is the Euclidean distance from the nearest obstacle</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">inscribed_radius</code> is the radius of the robot's inscribed circle</li>
<li><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">weight</code> is the cost scaling factor (higher values cause faster cost decay)</li>
</ul>
<p>This creates a smooth gradient of costs that decreases as distance from obstacles increases.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/include/costmap_2d/inflation_layer.h#L104-L119" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/include/costmap_2d/inflation_layer.h</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">104-119</span></a></p>
<h2 id="configuration-parameters" class="group" data-header="true">Configuration Parameters<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The Inflation Layer can be configured through the following parameters:</p>



































<table><thead><tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">inflation_radius</code></td><td>double</td><td>-</td><td>Maximum distance from an obstacle at which costs are incurred</td></tr><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">cost_scaling_factor</code></td><td>double</td><td>-</td><td>Scaling factor for the cost decay equation</td></tr><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">inflate_unknown</code></td><td>bool</td><td>false</td><td>Whether to inflate unknown space (represented by NO_INFORMATION)</td></tr><tr><td><code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">enabled</code></td><td>bool</td><td>true</td><td>Whether the layer is currently enabled</td></tr></tbody></table>
<p>These parameters can be dynamically reconfigured at runtime using ROS's dynamic_reconfigure system.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L103-L111" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">103-111</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L369-L383" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">369-383</span></a></p>
<h2 id="inflation-layer-in-the-layered-costmap-architecture" class="group" data-header="true">Inflation Layer in the Layered Costmap Architecture<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<pre class="px-2 py-1.5 has-[code]:rounded-md has-[code]:!bg-[#e5e5e5] has-[div]:bg-transparent has-[div]:!p-0 has-[code]:text-stone-900 dark:has-[code]:!bg-[#242424] has-[code]:dark:text-white [&amp;_code]:block [&amp;_code]:border-none [&amp;_code]:bg-transparent [&amp;_code]:p-0"><div class="group relative cursor-pointer overflow-x-auto rounded-md bg-[#f2f1f0] p-4 transition-colors hover:bg-[#ededed] dark:bg-[#1f1f1f] dark:hover:bg-[#242424]" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-r9" data-state="closed" data-slot="dialog-trigger"><div class="flex justify-center"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 1165.12890625 838" style="max-width: 100%; touch-action: none; user-select: none; cursor: grab; min-height: fit-content; max-height: 100%;" class="flowchart" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" id="mermaid-zk5cxp6oe89" preserveAspectRatio="xMidYMid meet"><style>#mermaid-zk5cxp6oe89{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-zk5cxp6oe89 .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-zk5cxp6oe89 .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-zk5cxp6oe89 .error-icon{fill:#dddddd;}#mermaid-zk5cxp6oe89 .error-text{fill:#222222;stroke:#222222;}#mermaid-zk5cxp6oe89 .edge-thickness-normal{stroke-width:1px;}#mermaid-zk5cxp6oe89 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-zk5cxp6oe89 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-zk5cxp6oe89 .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-zk5cxp6oe89 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-zk5cxp6oe89 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-zk5cxp6oe89 .marker{fill:#999;stroke:#999;}#mermaid-zk5cxp6oe89 .marker.cross{stroke:#999;}#mermaid-zk5cxp6oe89 svg{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;}#mermaid-zk5cxp6oe89 p{margin:0;}#mermaid-zk5cxp6oe89 .label{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;color:#333;}#mermaid-zk5cxp6oe89 .cluster-label text{fill:#444;}#mermaid-zk5cxp6oe89 .cluster-label span{color:#444;}#mermaid-zk5cxp6oe89 .cluster-label span p{background-color:transparent;}#mermaid-zk5cxp6oe89 .label text,#mermaid-zk5cxp6oe89 span{fill:#333;color:#333;}#mermaid-zk5cxp6oe89 .node rect,#mermaid-zk5cxp6oe89 .node circle,#mermaid-zk5cxp6oe89 .node ellipse,#mermaid-zk5cxp6oe89 .node polygon,#mermaid-zk5cxp6oe89 .node path{fill:#ffffff;stroke:#dddddd;stroke-width:1px;}#mermaid-zk5cxp6oe89 .rough-node .label text,#mermaid-zk5cxp6oe89 .node .label text,#mermaid-zk5cxp6oe89 .image-shape .label,#mermaid-zk5cxp6oe89 .icon-shape .label{text-anchor:middle;}#mermaid-zk5cxp6oe89 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-zk5cxp6oe89 .rough-node .label,#mermaid-zk5cxp6oe89 .node .label,#mermaid-zk5cxp6oe89 .image-shape .label,#mermaid-zk5cxp6oe89 .icon-shape .label{text-align:center;}#mermaid-zk5cxp6oe89 .node.clickable{cursor:pointer;}#mermaid-zk5cxp6oe89 .root .anchor path{fill:#999!important;stroke-width:0;stroke:#999;}#mermaid-zk5cxp6oe89 .arrowheadPath{fill:#0b0b0b;}#mermaid-zk5cxp6oe89 .edgePath .path{stroke:#999;stroke-width:2.0px;}#mermaid-zk5cxp6oe89 .flowchart-link{stroke:#999;fill:none;}#mermaid-zk5cxp6oe89 .edgeLabel{background-color:#ffffff;text-align:center;}#mermaid-zk5cxp6oe89 .edgeLabel p{background-color:#ffffff;}#mermaid-zk5cxp6oe89 .edgeLabel rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-zk5cxp6oe89 .labelBkg{background-color:rgba(255, 255, 255, 0.5);}#mermaid-zk5cxp6oe89 .cluster rect{fill:#f8f8f8;stroke:#dddddd;stroke-width:1px;}#mermaid-zk5cxp6oe89 .cluster text{fill:#444;}#mermaid-zk5cxp6oe89 .cluster span{color:#444;}#mermaid-zk5cxp6oe89 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:12px;background:#dddddd;border:1px solid hsl(0, 0%, 76.6666666667%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-zk5cxp6oe89 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-zk5cxp6oe89 rect.text{fill:none;stroke-width:0;}#mermaid-zk5cxp6oe89 .icon-shape,#mermaid-zk5cxp6oe89 .image-shape{background-color:#ffffff;text-align:center;}#mermaid-zk5cxp6oe89 .icon-shape p,#mermaid-zk5cxp6oe89 .image-shape p{background-color:#ffffff;padding:2px;}#mermaid-zk5cxp6oe89 .icon-shape rect,#mermaid-zk5cxp6oe89 .image-shape rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-zk5cxp6oe89 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-zk5cxp6oe89_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(0, 0)" class="root"><g class="clusters"><g data-look="classic" id="subGraph1" class="cluster"><rect height="822" width="450.6015625" y="8" x="8" style=""></rect><g transform="translate(141.69140625, 8)" class="cluster-label"><foreignobject height="24" width="183.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>InflationLayer Processing</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IL2_F_0" d="M265.465,99.5L265.465,105.75C265.465,112,265.465,124.5,265.465,136.333C265.465,148.167,265.465,159.333,265.465,164.917L265.465,170.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_Q_0" d="M265.465,228.5L265.465,234.75C265.465,241,265.465,253.5,265.465,265.333C265.465,277.167,265.465,288.333,265.465,293.917L265.465,299.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Q_P_0" d="M265.465,381.5L265.465,387.75C265.465,394,265.465,406.5,265.465,418.333C265.465,430.167,265.465,441.333,265.465,446.917L265.465,452.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_P_C_0" d="M227.509,510.5L218.723,516.75C209.937,523,192.365,535.5,183.579,547.333C174.793,559.167,174.793,570.333,174.793,575.917L174.793,581.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_N_0" d="M174.793,663.5L174.793,669.75C174.793,676,174.793,688.5,183.036,700.614C191.279,712.727,207.764,724.454,216.007,730.318L224.25,736.181"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_N_P_0" d="M303.421,738.5L312.207,732.25C320.993,726,338.565,713.5,347.351,694.5C356.137,675.5,356.137,650,356.137,624.5C356.137,599,356.137,573.5,347.894,554.886C339.651,536.273,323.166,524.546,314.923,518.682L306.68,512.819"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g transform="translate(356.13671875, 624.5)" class="edgeLabel"><g transform="translate(-16.34375, -12)" class="label"><foreignobject height="24" width="32.6875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>loop</p></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(265.46484375, 72.5)" id="flowchart-IL2-12" class="node default"><rect height="54" width="267.171875" y="-27" x="-133.5859375" style="" class="basic label-container"></rect><g transform="translate(-103.5859375, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="207.171875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>InflationLayer.updateCosts()</p></span></div></foreignobject></g></g><g transform="translate(265.46484375, 201.5)" id="flowchart-F-13" class="node default"><rect height="54" width="208.921875" y="-27" x="-104.4609375" style="" class="basic label-container"></rect><g transform="translate(-74.4609375, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="148.921875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Find lethal obstacles</p></span></div></foreignobject></g></g><g transform="translate(265.46484375, 342.5)" id="flowchart-Q-15" class="node default"><rect height="78" width="260" y="-39" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Create distance-sorted queue</p></span></div></foreignobject></g></g><g transform="translate(265.46484375, 483.5)" id="flowchart-P-17" class="node default"><rect height="54" width="237.484375" y="-27" x="-118.7421875" style="" class="basic label-container"></rect><g transform="translate(-88.7421875, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="177.484375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Process cells by distance</p></span></div></foreignobject></g></g><g transform="translate(174.79296875, 624.5)" id="flowchart-C-19" class="node default"><rect height="78" width="260" y="-39" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Compute cost based on distance</p></span></div></foreignobject></g></g><g transform="translate(265.46484375, 765.5)" id="flowchart-N-21" class="node default"><rect height="54" width="192.4375" y="-27" x="-96.21875" style="" class="basic label-container"></rect><g transform="translate(-66.21875, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="132.4375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Process neighbors</p></span></div></foreignobject></g></g></g></g><g transform="translate(500.6015625, 193.5)" class="root"><g class="clusters"><g data-look="classic" id="subGraph0" class="cluster"><rect height="435" width="648.52734375" y="8" x="8" style=""></rect><g transform="translate(248.833984375, 8)" class="cluster-label"><foreignobject height="24" width="166.859375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Costmap2D Processing</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_LC_SL_0" d="M253.211,99.5L231.386,107.75C209.56,116,165.909,132.5,144.083,148.333C122.258,164.167,122.258,179.333,122.258,186.917L122.258,194.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_LC_OL_0" d="M324.641,99.5L324.641,107.75C324.641,116,324.641,132.5,324.641,148.333C324.641,164.167,324.641,179.333,324.641,186.917L324.641,194.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_LC_IL_0" d="M399.657,99.5L422.579,107.75C445.501,116,491.344,132.5,514.266,148.333C537.188,164.167,537.188,179.333,537.188,186.917L537.188,194.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_SL_CM_0" d="M122.258,252.5L122.258,260.75C122.258,269,122.258,285.5,143.46,301.764C164.662,318.029,207.066,334.057,228.268,342.071L249.47,350.086"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_OL_CM_0" d="M324.641,252.5L324.641,260.75C324.641,269,324.641,285.5,324.641,301.333C324.641,317.167,324.641,332.333,324.641,339.917L324.641,347.5"></path><path marker-end="url(#mermaid-zk5cxp6oe89_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IL_CM_0" d="M537.188,252.5L537.188,260.75C537.188,269,537.188,285.5,514.893,301.774C492.599,318.048,448.01,334.097,425.715,342.121L403.421,350.145"></path></g><g class="edgeLabels"><g transform="translate(122.2578125, 149)" class="edgeLabel"><g transform="translate(-53.9609375, -12)" class="label"><foreignobject height="24" width="107.921875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>1.updateMap()</p></span></div></foreignobject></g></g><g transform="translate(324.640625, 149)" class="edgeLabel"><g transform="translate(-53.9609375, -12)" class="label"><foreignobject height="24" width="107.921875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>2.updateMap()</p></span></div></foreignobject></g></g><g transform="translate(537.1875, 149)" class="edgeLabel"><g transform="translate(-53.9609375, -12)" class="label"><foreignobject height="24" width="107.921875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>3.updateMap()</p></span></div></foreignobject></g></g><g transform="translate(122.2578125, 302)" class="edgeLabel"><g transform="translate(-51.5390625, -12)" class="label"><foreignobject height="24" width="103.078125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>updateCosts()</p></span></div></foreignobject></g></g><g transform="translate(324.640625, 302)" class="edgeLabel"><g transform="translate(-51.5390625, -12)" class="label"><foreignobject height="24" width="103.078125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>updateCosts()</p></span></div></foreignobject></g></g><g transform="translate(537.1875, 302)" class="edgeLabel"><g transform="translate(-51.5390625, -12)" class="label"><foreignobject height="24" width="103.078125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>updateCosts()</p></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(324.640625, 72.5)" id="flowchart-LC-0" class="node default"><rect height="54" width="182.109375" y="-27" x="-91.0546875" style="" class="basic label-container"></rect><g transform="translate(-61.0546875, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="122.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>LayeredCostmap</p></span></div></foreignobject></g></g><g transform="translate(122.2578125, 225.5)" id="flowchart-SL-1" class="node default"><rect height="54" width="140.71875" y="-27" x="-70.359375" style="" class="basic label-container"></rect><g transform="translate(-40.359375, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="80.71875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>StaticLayer</p></span></div></foreignobject></g></g><g transform="translate(324.640625, 225.5)" id="flowchart-OL-3" class="node default"><rect height="54" width="164.046875" y="-27" x="-82.0234375" style="" class="basic label-container"></rect><g transform="translate(-52.0234375, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="104.046875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ObstacleLayer</p></span></div></foreignobject></g></g><g transform="translate(537.1875, 225.5)" id="flowchart-IL-5" class="node default"><rect height="54" width="161.046875" y="-27" x="-80.5234375" style="" class="basic label-container"></rect><g transform="translate(-50.5234375, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="101.046875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>InflationLayer</p></span></div></foreignobject></g></g><g transform="translate(324.640625, 378.5)" id="flowchart-CM-7" class="node default"><rect height="54" width="176.3125" y="-27" x="-88.15625" style="" class="basic label-container"></rect><g transform="translate(-58.15625, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="116.3125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Master costmap</p></span></div></foreignobject></g></g></g></g></g></g></g></svg></div><div class="bg-input-dark absolute right-2 top-2 rounded-sm p-1 opacity-0 transition-opacity group-hover:opacity-100"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256"><path d="M216,48V96a8,8,0,0,1-16,0V67.31l-42.34,42.35a8,8,0,0,1-11.32-11.32L188.69,56H160a8,8,0,0,1,0-16h48A8,8,0,0,1,216,48ZM98.34,146.34,56,188.69V160a8,8,0,0,0-16,0v48a8,8,0,0,0,8,8H96a8,8,0,0,0,0-16H67.31l42.35-42.34a8,8,0,0,0-11.32-11.32ZM208,152a8,8,0,0,0-8,8v28.69l-42.34-42.35a8,8,0,0,0-11.32,11.32L188.69,200H160a8,8,0,0,0,0,16h48a8,8,0,0,0,8-8V160A8,8,0,0,0,208,152ZM67.31,56H96a8,8,0,0,0,0-16H48a8,8,0,0,0-8,8V96a8,8,0,0,0,16,0V67.31l42.34,42.35a8,8,0,0,0,11.32-11.32Z"></path></svg></div></div></pre>
<p>The Inflation Layer typically operates after the Static Layer and Obstacle Layer have updated the master costmap. The sequence of operations is:</p>
<ol>
<li>The Static Layer adds information from the static map</li>
<li>The Obstacle Layer adds information from sensor observations</li>
<li>The Inflation Layer inflates obstacles from both static and sensor data</li>
<li>The resulting costmap is used by planners for navigation</li>
</ol>
<p>This ordering ensures that all obstacles are properly identified before inflation occurs.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L176-L280" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">176-280</span></a></p>
<h2 id="implementation-details" class="group" data-header="true">Implementation Details<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The Inflation Layer uses several optimizations to efficiently inflate obstacles:</p>
<ol>
<li>
<p><strong>Distance and Cost Caching</strong>: The layer precomputes distances and costs for cells within the inflation radius to avoid repetitive calculations.</p>
</li>
<li>
<p><strong>Distance-Sorted Cell Queue</strong>: Cells are processed in order of increasing distance from obstacles, which ensures that closer cells are processed before their neighbors.</p>
</li>
<li>
<p><strong>Seen Cells Tracking</strong>: A boolean array tracks which cells have been processed to avoid redundant calculations.</p>
</li>
<li>
<p><strong>Cell Inflation Radius</strong>: The inflation radius is converted to cell units for more efficient grid operations.</p>
</li>
</ol>
<p>The inflation process is thread-safe, using a recursive mutex to protect access during updates.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L308-L341" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">308-341</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L176-L197" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">176-197</span></a></p>
<h2 id="common-issues-and-troubleshooting" class="group" data-header="true">Common Issues and Troubleshooting<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<h3 id="appropriate-inflation-radius" class="group" data-header="true">Appropriate Inflation Radius<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<p>Setting the inflation radius is critical:</p>
<ul>
<li>Too small: The robot may collide with obstacles or navigate too close to them</li>
<li>Too large: The robot may be unable to navigate through tight spaces</li>
</ul>
<p>The inflation radius should generally be set to at least the robot's circumscribed radius (the radius of the smallest circle that completely contains the robot), plus a safety margin.</p>
<h3 id="cost-scaling-factor-tuning" class="group" data-header="true">Cost Scaling Factor Tuning<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<p>The cost scaling factor controls how quickly costs decay as distance from obstacles increases:</p>
<ul>
<li>Lower values: Costs decrease slowly, creating a wider high-cost area around obstacles</li>
<li>Higher values: Costs decrease quickly, creating a steeper gradient</li>
</ul>
<p>A typical starting value is 2.0, which can then be adjusted based on the robot's behavior.</p>
<h3 id="inflation-and-map-resolution" class="group" data-header="true">Inflation and Map Resolution<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h3>
<p>The effectiveness of inflation is affected by the map resolution. Higher resolution maps (smaller cell sizes) allow for more precise inflation but require more computational resources.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L369-L383" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">369-383</span></a></p>
<h2 id="interaction-with-robot-footprint-changes" class="group" data-header="true">Interaction with Robot Footprint Changes<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>When the robot's footprint changes (e.g., when carrying a load that extends beyond its normal dimensions), the Inflation Layer automatically recomputes the inflation to account for the new dimensions. This is triggered by the <code class="rounded-sm bg-[#e5e5e5] px-[0.25rem] py-[0.20rem] text-xs font-normal leading-[15px] before:hidden after:hidden dark:bg-[#484848]/30">onFootprintChanged()</code> method.</p>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L164-L173" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">164-173</span></a></p>
<h2 id="performance-considerations" class="group" data-header="true">Performance Considerations<button class="relative ml-2 cursor-pointer align-baseline text-gray-400 opacity-0 transition-opacity hover:text-blue-400 focus:opacity-100 group-hover:opacity-100" aria-label="Copy link to header"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M117.18,188.74a12,12,0,0,1,0,17l-5.12,5.12A58.26,58.26,0,0,1,70.6,228h0A58.62,58.62,0,0,1,29.14,127.92L63.89,93.17a58.64,58.64,0,0,1,98.56,28.11,12,12,0,1,1-23.37,5.44,34.65,34.65,0,0,0-58.22-16.58L46.11,144.89A34.62,34.62,0,0,0,70.57,204h0a34.41,34.41,0,0,0,24.49-10.14l5.11-5.12A12,12,0,0,1,117.18,188.74ZM226.83,45.17a58.65,58.65,0,0,0-82.93,0l-5.11,5.11a12,12,0,0,0,17,17l5.12-5.12a34.63,34.63,0,1,1,49,49L175.1,145.86A34.39,34.39,0,0,1,150.61,156h0a34.63,34.63,0,0,1-33.69-26.72,12,12,0,0,0-23.38,5.44A58.64,58.64,0,0,0,150.56,180h.05a58.28,58.28,0,0,0,41.47-17.17l34.75-34.75a58.62,58.62,0,0,0,0-82.91Z"></path></svg></button></h2>
<p>The Inflation Layer can be computationally intensive, especially with large inflation radii or high-resolution maps. To optimize performance:</p>
<ul>
<li>Use an appropriate inflation radius (not larger than necessary)</li>
<li>Consider the tradeoff between map resolution and computational load</li>
<li>Be aware that full reinflation is triggered when parameters change or when the robot's footprint changes</li>
</ul>
<p>Sources: <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L128-L161" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">128-161</span></a> <a href="https://github.com/ros-planning/navigation/blob/9ad64419/costmap_2d/plugins/inflation_layer.cpp#L176-L280" target="_blank" rel="noopener noreferrer" class="mb-1 mr-1 inline-flex items-stretch font-mono text-xs !no-underline transition-opacity hover:opacity-75"><span class="flex items-center break-all rounded-l px-2 py-1.5 bg-[#e5e5e5] text-[#333333] dark:bg-[#252525] dark:text-[#e4e4e4]"><svg class="mr-1.5 hidden h-3.5 w-3.5 flex-shrink-0 opacity-40 md:block" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg>costmap_2d/plugins/inflation_layer.cpp</span><span class="flex flex-shrink-0 items-center rounded-r border-l px-2 py-1.5 border-[#dddddd] bg-[#d8d8d8] text-[#666666] dark:border-[#333333] dark:bg-[#2a2a2a] dark:text-[#888888]">176-280</span></a></p></div></div></div></div></div></div><div class="hidden overflow-hidden transition-[border-radius] xl:sticky xl:right-0 xl:top-20 xl:block xl:h-[calc(100vh-82px)] xl:w-64 xl:flex-shrink-0 2xl:w-72" style="scrollbar-width:none"><div class="flex max-h-full w-full flex-shrink-0 flex-col py-6 pt-0 text-sm lg:pb-4 lg:pt-8 xl:w-64 2xl:w-72" style="scrollbar-color:var(--color-night) transparent"><div><div class="relative mx-4 my-4 rounded-md border border-neutral-200 bg-neutral-100 p-3 text-sm text-neutral-600 dark:border-neutral-800 dark:bg-neutral-900 dark:text-neutral-400"><button class="absolute right-2 top-2 rounded-sm p-1 opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-neutral-400 focus:ring-offset-2"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="h-4 w-4"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"></path></svg><span class="sr-only">Dismiss</span></button><p class="text-sm font-medium">Refresh this wiki</p><button class="mt-2 flex items-center gap-1 rounded-md bg-neutral-200 px-2 py-1 text-sm font-medium text-neutral-700 transition-colors hover:bg-neutral-300 dark:bg-neutral-800 dark:text-neutral-300 dark:hover:bg-neutral-700">Enter email to refresh</button></div></div><h3 class="px-4 pb-5 text-lg font-medium leading-none">On this page</h3><ul style="scrollbar-width:none" class="min-h-0 flex-1 space-y-3 overflow-y-auto p-4 pt-0"><li class=""><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#inflation-layer" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Inflation Layer</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#purpose-and-function" class="hover:text-primary pr-1 transition-all text-primary font-medium">Purpose and Function</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#how-the-inflation-layer-works" class="hover:text-primary pr-1 font-normal transition-all text-secondary">How the Inflation Layer Works</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#core-data-structures" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Core Data Structures</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#inflation-cost-calculation" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Inflation Cost Calculation</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#configuration-parameters" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Configuration Parameters</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#inflation-layer-in-the-layered-costmap-architecture" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Inflation Layer in the Layered Costmap Architecture</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#implementation-details" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Implementation Details</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#common-issues-and-troubleshooting" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Common Issues and Troubleshooting</a></li><li class="ml-6"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#appropriate-inflation-radius" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Appropriate Inflation Radius</a></li><li class="ml-6"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#cost-scaling-factor-tuning" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Cost Scaling Factor Tuning</a></li><li class="ml-6"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#inflation-and-map-resolution" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Inflation and Map Resolution</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#interaction-with-robot-footprint-changes" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Interaction with Robot Footprint Changes</a></li><li class="ml-3"><a href="https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer#performance-considerations" class="hover:text-primary pr-1 font-normal transition-all text-secondary">Performance Considerations</a></li></ul></div></div><div class="pointer-events-none fixed bottom-2 left-2 right-2 mt-2 md:bottom-4 md:left-0 md:right-0"><div class="z-10 mx-auto max-w-3xl"><form class="z-20 w-full rounded-md backdrop-blur-md transition-shadow [pointer-events:all] focus-within:ring-[.5px] focus-within:ring-indigo-300/40 bg-component/70 border border-indigo-300/20 shadow-lg shadow-indigo-500/20 [backdrop-filter:blur(8px)]"><div class=""><div class="relative text-base font-normal"><div class="relative px-3 pt-3"><div class="pointer-events-none absolute left-3 right-3 top-3 ml-px flex w-full overflow-hidden text-base" aria-hidden="true"><div class="flex items-center gap-1 overflow-hidden text-wrap opacity-60">Ask Devin about ros-planning/navigation</div></div><textarea data-deepwiki-input="question" placeholder="" rows="2" class="w-full resize-none rounded-none bg-transparent text-white focus:outline-none text-base"></textarea></div></div></div><div class="dark:border-border flex h-12 items-center justify-between border-t-[0.5px] border-[#c0c0c0] p-3 pl-1.5"><div class="flex items-center text-sm gap-4"><button data-slot="button" class="font-medium disabled:pointer-events-none disabled:opacity-50 shrink-0 focus-visible:border-ring aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:hover:bg-accent/50 has-[&gt;svg]:px-3 data-[placeholder]:text-muted-foreground [&amp;_svg:not([class*=&#39;text-&#39;])]:text-muted-foreground focus-visible:ring-ring/50 hover:bg-accent hover:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex h-9 w-fit cursor-pointer items-center justify-between gap-2 whitespace-nowrap rounded-md bg-transparent px-3 py-2 text-sm text-neutral-700 outline-none transition-all focus-visible:ring-[3px] dark:text-neutral-400 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0" data-selected="true" type="button" id="radix-r0" aria-haspopup="menu" aria-expanded="false" data-state="closed"><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="size-4 text-current"><path d="M213.85,125.46l-112,120a8,8,0,0,1-13.69-7l14.66-73.33L45.19,143.49a8,8,0,0,1-3-13l112-120a8,8,0,0,1,13.69,7L153.18,90.9l57.63,21.61a8,8,0,0,1,3,12.95Z"></path></svg><span>Fast</span></div><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="size-4 text-current opacity-50"><path d="M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,53.66,90.34L128,164.69l74.34-74.35a8,8,0,0,1,11.32,11.32Z"></path></svg></button></div><div class="flex items-center gap-2"><button class="rounded-full bg-[#e0e0e0] p-1 text-neutral-400 transition-colors dark:bg-neutral-700" disabled="" data-state="closed" data-slot="tooltip-trigger"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 256 256"><path d="M221.66,133.66l-72,72a8,8,0,0,1-11.32-11.32L196.69,136H40a8,8,0,0,1,0-16H196.69L138.34,61.66a8,8,0,0,1,11.32-11.32l72,72A8,8,0,0,1,221.66,133.66Z"></path></svg></button></div></div></form></div></div></div></div></div><!--/$--></div><!--/$--><script src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/webpack-acbbbb548492d4a6.js" async="" data-aria-hidden="true" aria-hidden="true"></script><script data-aria-hidden="true" aria-hidden="true">(self.__next_f=self.__next_f||[]).push([0])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[51709,[\"9453\",\"static/chunks/b1298b8d-549c141f97a3b262.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"8970\",\"static/chunks/378e5a93-3b0f971d3611a8a5.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1585\",\"static/chunks/f7f68e2d-40290491c524df5c.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4420\",\"static/chunks/4420-863691215dce8f1b.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6417\",\"static/chunks/6417-34cc3208366c5e5f.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4348\",\"static/chunks/4348-824485747071bae4.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"3224\",\"static/chunks/3224-7e9887ea92eab174.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6967\",\"static/chunks/6967-c4b815e71e97ed18.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"7177\",\"static/chunks/app/layout-37a15e31a18fac3d.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\"],\"RootProvider\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[90894,[],\"ClientPageRoot\"]\n7:I[87667,[\"9453\",\"static/chunks/b1298b8d-549c141f97a3b262.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"8970\",\"static/chunks/378e5a93-3b0f971d3611a8a5.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1585\",\"static/chunks/f7f68e2d-40290491c524df5c.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4129\",\"static/chunks/7bf36345-06f80506190927ed.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2545\",\"static/chunks/c16f53c3-1a60b9b77b3e1d4b.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4420\",\"static/chunks/4420-863691215dce8f1b.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6417\",\"static/chunks/6417-34cc3208366c5e5f.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4348\",\"static/chunks/4348-824485747071bae4.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"3224\",\"static/chunks/3224-7e9887ea92eab174.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2249\",\"static/chunks/2249-342d7235b3a68051.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"9970\",\"static/chunks/9970-31fea4ade6367f07.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6967\",\"static/chunks/6967-c4b815e71e97ed18.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1769\",\"static/chunks/1769-6bbc7ae2dcadfa9c.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"655\",\"static/c"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"hunks/655-b5574efc1f81bad2.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4154\",\"static/chunks/4154-f7634cd651686b21.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"3639\",\"static/chunks/3639-22cfac537e991f4e.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"8613\",\"static/chunks/8613-82346d348221c557.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4870\",\"static/chunks/4870-3ddb59732948b175.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"3285\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/%5B%5B...wikiRoutes%5D%5D/page-78fac26cbb8eb9a1.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\"],\"default\"]\na:I[59665,[],\"OutletBoundary\"]\nd:I[59665,[],\"ViewportBoundary\"]\nf:I[59665,[],\"MetadataBoundary\"]\n11:I[26614,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/de70bee13400563f.css?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"style\"]\n:HL[\"/_next/static/css/4095ef47de7c7e40.css?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"style\"]\n"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"0:{\"P\":null,\"b\":\"B87t301-MfI6j0-2ZPiM5\",\"p\":\"\",\"c\":[\"\",\"ros-planning\",\"navigation\",\"2.3.3-inflation-layer\"],\"i\":false,\"f\":[[[\"\",{\"children\":[[\"org\",\"ros-planning\",\"d\"],{\"children\":[[\"repo\",\"navigation\",\"d\"],{\"children\":[[\"wikiRoutes\",\"2.3.3-inflation-layer\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/de70bee13400563f.css?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4095ef47de7c7e40.css?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{}],[\"$\",\"body\",null,{\"className\":\"__variable_188709 font-geist-sans relative min-h-screen __variable_9a8899 bg-background antialiased\",\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}]]}],{\"children\":[[\"org\",\"ros-planning\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"repo\",\"navigation\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L5\"]}],{\"children\":[[\"wikiRoutes\",\"2.3.3-inflation-layer\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L6\",null,{\"Component\":\"$7\",\"searchParams\":{},\"params\":{\"org\":\"ros-planning\",\"repo\":\"navigation\",\"wikiRoutes\":[\"2.3.3-inflation-layer\"]},\"promises\":[\"$@8\",\"$@9\"]}],\"$undefined\",null,[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",null]}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"XDwXe5Ba736aVkDv-Tp-E\",{\"children\":[[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"8:{}\n9:{\"org\":\"ros-planning\",\"repo\":\"navigation\",\"wikiRoutes\":\"$0:f:0:1:2:children:2:children:2:children:2:children:1:props:children:0:props:params:wikiRoutes\"}\n"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"e:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"12:I[87437,[\"9453\",\"static/chunks/b1298b8d-549c141f97a3b262.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"8970\",\"static/chunks/378e5a93-3b0f971d3611a8a5.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1585\",\"static/chunks/f7f68e2d-40290491c524df5c.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4420\",\"static/chunks/4420-863691215dce8f1b.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6417\",\"static/chunks/6417-34cc3208366c5e5f.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4348\",\"static/chunks/4348-824485747071bae4.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2249\",\"static/chunks/2249-342d7235b3a68051.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"9970\",\"static/chunks/9970-31fea4ade6367f07.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"655\",\"static/chunks/655-b5574efc1f81bad2.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"3449\",\"static/chunks/3449-a3f74aab9beb2a02.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"7553\",\"static/chunks/7553-2bb9c132a5788553.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1127\",\"static/chunks/1127-b475c4cc62d0a830.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"736\",\"static/chunks/736-90a1c8956f4d3102.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-99964eedd99460bc.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\"],\"HeaderWrapperWithSuspense\"]\n13:I[93403,[\"9453\",\"static/chunks/b1298b8d-549c141f97a3b262.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"8970\",\"static/chunks/378e5a93-3b0f971d3611a8a5.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1585\",\"static/chunks/f7f68e2d-40290491c524df5c.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4420\",\"static/chunks/4420-863691215dce8f1b.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"6417\",\"static/chunks/6417-34cc3208366c5e5f.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"4348\",\"static/chunks/4348-824485747071bae4.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2249\",\"static/chunks/2249-342d7235b3a68051.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"9970\",\"static/chunks/9970-31fea4ade6367f07.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"655\",\"static/chunks/655-b5574efc1f81bad2.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxi"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"h3r4\",\"3449\",\"static/chunks/3449-a3f74aab9beb2a02.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"7553\",\"static/chunks/7553-2bb9c132a5788553.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"1127\",\"static/chunks/1127-b475c4cc62d0a830.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"736\",\"static/chunks/736-90a1c8956f4d3102.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\",\"2933\",\"static/chunks/app/%5Borg%5D/%5Brepo%5D/layout-99964eedd99460bc.js?dpl=dpl_H8wiiUhZWnZBdrUbMc4WjJxih3r4\"],\"WikiContextProvider\"]\n14:T2b6a,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Overview\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/CHANGELOG.rst](amcl/CHANGELOG.rst)\n- [base_local_planner/CHANGELOG.rst](base_local_planner/CHANGELOG.rst)\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [base_local_planner/package.xml](base_local_planner/package.xml)\n- [carrot_planner/CHANGELOG.rst](carrot_planner/CHANGELOG.rst)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [carrot_planner/package.xml](carrot_planner/package.xml)\n- [clear_costmap_recovery/CHANGELOG.rst](clear_costmap_recovery/CHANGELOG.rst)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [clear_costmap_recovery/package.xml](clear_costmap_recovery/package.xml)\n- [costmap_2d/CHANGELOG.rst](costmap_2d/CHANGELOG.rst)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/package.xml](costmap_2d/package.xml)\n- [dwa_local_planner/CHANGELOG.rst](dwa_local_planner/CHANGELOG.rst)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [dwa_local_planner/package.xml](dwa_local_planner/package.xml)\n- [fake_localization/CHANGELOG.rst](fake_localization/CHANGELOG.rst)\n- [global_planner/CHANGELOG.rst](global_planner/CHANGELOG.rst)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [map_server/CHANGELOG.rst](map_server/CHANGELOG.rst)\n- [move_base/CHANGELOG.rst](move_base/CHANGELOG.rst)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_base/package.xml](move_base/package.xml)\n- [move_slow_and_clear/CHANGELOG.rst](move_slow_and_clear/CHANGELOG.rst)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [move_slow_and_clear/package.xml](move_slow_and_clear/package.xml)\n- [nav_core/package.xml](nav_core/package.xml)\n- [navfn/CHANGELOG.rst](navfn/CHANGELOG.rst)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [navfn/package.xml](navfn/package.xml)\n- [navigation/README.rst](navigation/README.rst)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [rotate_recovery/package.xml](rotate_recovery/package.xml)\n- [voxel_grid/CHANGELOG.rst](voxel_grid/CHANGELOG.rst)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n- [voxel_grid/package.xml](voxel_grid/package.xml)\n\n\u003c/details\u003e\n\n\n\nThe ROS Navigation Stack is a comprehensive system that provides autonomous navigation capabilities for mobile robots in 2D environments. This stack processes information from odometry, sensor streams, and target goals to generate and execute safe navigation paths.\n\n## Purpose and Scope\n\nThis overview introduces the ROS Navigation Stack's architecture and components, explaining how they work together to enable mobile robot navigation. For detailed information on specific components, please refer to the dedicated pages linked throughout this document.\n\n## Core Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Central Coordination\"\n        MB[\"move_base\"]\n    end\n    \n    subgraph \"Planning\"\n        GP[\"Global Planners\"]\n        LP[\"Local Planners\"]\n        GP --\u003e NAVFN[\"navfn\"]\n        GP --\u003e GLOB[\"global_planner\"]\n        GP --\u003e CARR[\"carrot_planner\"]\n        LP --\u003e BLPR[\"base_local_planner\"]\n        LP --\u003e DWALP[\"dwa_local_planner\"]\n    end\n    \n    subgraph \"Environment Representation\"\n        CM[\"costmap_2d\"]\n        CM --\u003e STAT[\"Static Layer\"]\n        CM --\u003e OBST[\"Obstacle Layer\"]\n        CM --\u003e INFL[\"Inflation Layer\"]\n        CM --\u003e VOXL[\"Voxel Layer\"]\n        VG[\"voxel_grid\"]\n    end\n    \n    subgraph \"Recovery Behaviors\"\n        RB[\"Recovery Behaviors\"]\n        RB --\u003e CCR[\"clear_costmap_recovery\"]\n        RB --\u003e ROT[\"rotate_recovery\"]\n        RB --\u003e MSC[\"move_slow_and_clear\"]\n    end\n    \n    subgraph \"Localization\"\n        LOC[\"Localization\"]\n        LOC --\u003e AMCL[\"amcl\"]\n        LOC --\u003e FAKE[\"fake_localization\"]\n    end\n    \n    MAP[\"map_server\"]\n    \n    MB --\u003e GP\n    MB --\u003e LP\n    MB --\u003e RB\n    MB --\u003e CM\n    \n    CM --\u003e VG\n    MAP --\u003e CM\n    LOC --\u003e MB\n```\n\nSources: [navigation/README.rst:1-12](), [costmap_2d/CMakeLists.txt:1-218](), [base_local_planner/CMakeLists.txt:1-166](), [navfn/CMakeLists.txt:1-142](), [move_base/CMakeLists.txt:1-88]()\n\n## Key Components\n\nThe ROS Navigation Stack consists of several interconnected packages that work together:\n\n### Move Base\n\nThe `move_base` node is the central coordinator of the navigation stack. It manages the global and local planners, handles recovery behaviors, and interfaces with the robot's controllers. Move Base operates as an action server that accepts navigation goals and works to achieve them.\n\n### Costmap2D\n\nThe `costmap_2d` package provides a 2D representation of the environment through a layered approach. Each layer adds different information:\n\n- **Static Layer**: Incorporates static map data\n- **Obstacle Layer**: Integrates sensor data about obstacles\n- **Inflation Layer**: Expands obstacles to account for robot size\n- **Voxel Layer**: Provides 3D representation of obstacles\n\n### Planning Components\n\nThe navigation stack divides planning into two levels:\n\n- **Global Planners**: Generate a complete path from the robot's current position to the goal\n  - `navfn`: Uses a fast interpolated navigation function based on Dijkstra's algorithm\n  - `global_planner`: A more flexible global planning framework\n  - `carrot_planner`: A simple planner that creates direct paths to goals\n\n- **Local Planners**: Generate velocity commands to follow the global path\n  - `base_local_planner`: Implements trajectory-based local planning\n  - `dwa_local_planner`: Implements the Dynamic Window Approach\n\n### Recovery Behaviors\n\nWhen the robot gets stuck, recovery behaviors help it get back on track:\n\n- `clear_costmap_recovery`: Clears areas of the costmap that might be stale\n- `rotate_recovery`: Rotates the robot to find a clear path\n- `move_slow_and_clear`: Reduces speed and clears obstacles\n\n### Localization\n\nThe navigation stack includes localization components:\n\n- `amcl`: Adaptive Monte Carlo Localization using a particle filter\n- `fake_localization`: Simplified localization for testing\n\n### Map Management\n\nThe `map_server` provides map data to the navigation stack components.\n\nSources: [base_local_planner/package.xml:1-53](), [costmap_2d/package.xml:1-60](), [navfn/package.xml:1-50](), [move_base/package.xml:1-48]()\n\n## Plugin Architecture\n\n```mermaid\ngraph LR\n    subgraph \"Core Interfaces (nav_core)\"\n        BGP[\"BaseGlobalPlanner\"]\n        BLP[\"BaseLocalPlanner\"]\n        RB[\"RecoveryBehavior\"]\n    end\n    \n    subgraph \"Plugin Implementations\"\n        BGP --- NAVF[\"NavfnROS\"]\n        BGP --- GPlan[\"GlobalPlanner\"]\n        BGP --- CPlan[\"CarrotPlanner\"]\n        \n        BLP --- TPLR[\"TrajectoryPlannerROS\"]\n        BLP --- DWALPR[\"DWAPlannerROS\"]\n        \n        RB --- CCR[\"ClearCostmapRecovery\"]\n        RB --- RR[\"RotateRecovery\"]\n        RB --- MSLC[\"MoveSlowAndClear\"]\n    end\n    \n    MB[\"move_base\"] --\u003e BGP\n    MB --\u003e BLP\n    MB --\u003e RB\n```\n\nThe navigation stack uses a plugin architecture defined in the `nav_core` package. This design allows different planning algorithms and recovery behaviors to be loaded dynamically, making the system highly configurable. The core interfaces are:\n\n- `BaseGlobalPlanner`: Interface for global path planning\n- `BaseLocalPlanner`: Interface for local trajectory planning\n- `RecoveryBehavior`: Interface for recovery behaviors\n\nSources: [nav_core/package.xml:1-27](), [carrot_planner/package.xml:1-40](), [dwa_local_planner/package.xml:1-51](), [clear_costmap_recovery/package.xml:1-38]()\n\n## Navigation Data Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MB as move_base\n    participant GP as Global Planner\n    participant LP as Local Planner\n    participant CM as costmap_2d\n    participant RB as Recovery Behaviors\n    participant LOC as Localization\n    \n    User-\u003e\u003eMB: Navigation Goal\n    LOC-\u003e\u003eMB: Robot Pose\n    \n    MB-\u003e\u003eGP: Request Path\n    GP-\u003e\u003eCM: Query Global Costmap\n    CM-\u003e\u003eGP: Costmap Data\n    GP-\u003e\u003eMB: Global Path\n    \n    loop Until Goal Reached\n        MB-\u003e\u003eLP: Follow Path\n        LP-\u003e\u003eCM: Query Local Costmap\n        CM-\u003e\u003eLP: Costmap Data\n        LP-\u003e\u003eMB: Velocity Commands\n        MB-\u003e\u003eUser: Robot Base Commands\n        \n        alt If Stuck or Obstacle\n            MB-\u003e\u003eRB: Execute Recovery\n            RB-\u003e\u003eCM: Modify Costmap\n            RB-\u003e\u003eMB: Recovery Result\n        end\n    end\n    \n    MB-\u003e\u003eUser: Goal Status\n```\n\nWhen a navigation goal is received, the following typical flow occurs:\n\n1. The `move_base` node receives a goal and robot pose from localization\n2. It requests a path from the global planner, which uses the global costmap\n3. The global planner returns a path from the current position to the goal\n4. The `move_base` node repeatedly:\n   - Requests velocity commands from the local planner to follow the path\n   - The local planner uses the local costmap to avoid obstacles\n   - If the robot gets stuck, recovery behaviors are triggered\n5. Finally, the goal status is reported back to the user\n\nSources: [move_base/CMakeLists.txt:1-88](), [base_local_planner/CMakeLists.txt:1-166](), [navfn/CMakeLists.txt:1-142]()\n\n## Packages Table\n\n| Package | Purpose | Key Classes |\n|---------|---------|-------------|\n| move_base | Central navigation coordinator | MoveBase |\n| costmap_2d | Environment representation | Costmap2DROS, LayeredCostmap, Layer |\n| nav_core | Core interfaces | BaseGlobalPlanner, BaseLocalPlanner, RecoveryBehavior |\n| navfn | Navigation function global planner | NavfnROS |\n| global_planner | Flexible global planning framework | GlobalPlanner |\n| carrot_planner | Simple direct path planner | CarrotPlanner |\n| base_local_planner | Trajectory-based local planning | TrajectoryPlannerROS |\n| dwa_local_planner | Dynamic Window Approach local planner | DWAPlannerROS |\n| amcl | Adaptive Monte Carlo Localization | AmclNode |\n| fake_localization | Simplified localization for testing | FakeLocalization |\n| clear_costmap_recovery | Clears costmap areas | ClearCostmapRecovery |\n| rotate_recovery | Rotates to find clear path | RotateRecovery |\n| move_slow_and_clear | Reduces speed when obstacles are nearby | MoveSlowAndClear |\n| voxel_grid | Efficient 3D grid implementation | VoxelGrid |\n| map_server | Provides map data | MapServer |\n\nSources: [voxel_grid/package.xml:1-25](), [global_planner/CMakeLists.txt:1-78](), [move_slow_and_clear/package.xml:1-36](), [rotate_recovery/CMakeLists.txt:1-59]()\n\n## Key Advantages\n\n1. **Modularity**: Components can be replaced or configured independently\n2. **Flexibility**: Plugin architecture allows custom planning algorithms\n3. **Robustness**: Recovery behaviors help navigate challenging environments\n4. **Integration**: Works with standard ROS messages and transforms\n\nFor more detailed information about specific components, please refer to the dedicated pages:\n- [Architecture](#1.1)\n- [Packages](#1.2)\n- [Plugin System](#1.3)\n- [Costmap2D](#2)\n- [Move Base](#3)\n- [Global Planners](#4)\n- [Local Planners](#5)\n- [Localization](#6)\n- [Recovery Behaviors](#7)\n- [Map Server](#8)"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"15:T53a3,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Architecture\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/CHANGELOG.rst](amcl/CHANGELOG.rst)\n- [base_local_planner/CHANGELOG.rst](base_local_planner/CHANGELOG.rst)\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [base_local_planner/package.xml](base_local_planner/package.xml)\n- [carrot_planner/CHANGELOG.rst](carrot_planner/CHANGELOG.rst)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [carrot_planner/package.xml](carrot_planner/package.xml)\n- [clear_costmap_recovery/CHANGELOG.rst](clear_costmap_recovery/CHANGELOG.rst)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [clear_costmap_recovery/package.xml](clear_costmap_recovery/package.xml)\n- [costmap_2d/CHANGELOG.rst](costmap_2d/CHANGELOG.rst)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/package.xml](costmap_2d/package.xml)\n- [dwa_local_planner/CHANGELOG.rst](dwa_local_planner/CHANGELOG.rst)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [dwa_local_planner/package.xml](dwa_local_planner/package.xml)\n- [fake_localization/CHANGELOG.rst](fake_localization/CHANGELOG.rst)\n- [global_planner/CHANGELOG.rst](global_planner/CHANGELOG.rst)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [map_server/CHANGELOG.rst](map_server/CHANGELOG.rst)\n- [move_base/CHANGELOG.rst](move_base/CHANGELOG.rst)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_base/cfg/MoveBase.cfg](move_base/cfg/MoveBase.cfg)\n- [move_base/include/move_base/move_base.h](move_base/include/move_base/move_base.h)\n- [move_base/package.xml](move_base/package.xml)\n- [move_base/src/move_base.cpp](move_base/src/move_base.cpp)\n- [move_base/src/move_base_node.cpp](move_base/src/move_base_node.cpp)\n- [move_slow_and_clear/CHANGELOG.rst](move_slow_and_clear/CHANGELOG.rst)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [move_slow_and_clear/package.xml](move_slow_and_clear/package.xml)\n- [nav_core/package.xml](nav_core/package.xml)\n- [navfn/CHANGELOG.rst](navfn/CHANGELOG.rst)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [navfn/package.xml](navfn/package.xml)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [rotate_recovery/package.xml](rotate_recovery/package.xml)\n- [voxel_grid/CHANGELOG.rst](voxel_grid/CHANGELOG.rst)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n- [voxel_grid/package.xml](voxel_grid/package.xml)\n\n\u003c/details\u003e\n\n\n\nThis page describes the overall architecture of the ROS Navigation Stack, explaining how different components interact to enable autonomous robot navigation. The navigation stack provides capabilities for path planning, obstacle avoidance, localization, and recovery behaviors. This document focuses on the system architecture and component relationships rather than specific parameter configurations or API details.\n\nFor information about specific components, see their dedicated pages: [Costmap2D](#2), [Move Base](#3), [Global Planners](#4), [Local Planners](#5), [Localization](#6), and [Recovery Behaviors](#7).\n\n## High-Level Architecture\n\nThe Navigation Stack is built around a modular, plugin-based architecture. This design allows users to swap out specific planners or recovery behaviors without needing to modify the core framework.\n\n### Core Components Diagram\n\n```mermaid\ngraph TD\n    subgraph \"Central Coordinator\"\n        MB[\"move_base\"]\n    end\n    \n    subgraph \"Environment Representation\"\n        CM[\"costmap_2d\"]\n        CM --\u003e SL[\"Static Layer\"]\n        CM --\u003e OL[\"Obstacle Layer\"]\n        CM --\u003e IL[\"Inflation Layer\"]\n        CM --\u003e VL[\"Voxel Layer\"]\n    end\n    \n    subgraph \"Global Planning\"\n        GP[\"BaseGlobalPlanner\u003cInterface\u003e\"]\n        GP --\u003e NavFn[\"navfn::NavfnROS\"]\n        GP --\u003e GLPlanner[\"global_planner::GlobalPlanner\"]\n        GP --\u003e CP[\"carrot_planner::CarrotPlanner\"]\n    end\n    \n    subgraph \"Local Planning\"\n        LP[\"BaseLocalPlanner\u003cInterface\u003e\"]\n        LP --\u003e TrajPlanner[\"base_local_planner::TrajectoryPlannerROS\"]\n        LP --\u003e DWA[\"dwa_local_planner::DWAPlannerROS\"]\n    end\n    \n    subgraph \"Recovery Behaviors\"\n        RB[\"RecoveryBehavior\u003cInterface\u003e\"]\n        RB --\u003e CCR[\"clear_costmap_recovery::ClearCostmapRecovery\"]\n        RB --\u003e RR[\"rotate_recovery::RotateRecovery\"]\n        RB --\u003e MSC[\"move_slow_and_clear::MoveSlowAndClear\"]\n    end\n    \n    subgraph \"Localization\"\n        LOC[\"Localization\"]\n        LOC --\u003e AMCL[\"amcl::AmclNode\"]\n        LOC --\u003e FL[\"fake_localization::FakeLocalization\"]\n    end\n    \n    MB --\u003e GP\n    MB --\u003e LP\n    MB --\u003e RB\n    \n    GP --\u003e CM\n    LP --\u003e CM\n    \n    MB --\u003e CM\n    LOC --\u003e MB\n```\n\nSources: [move_base/include/move_base/move_base.h:83-236](), [move_base/src/move_base.cpp:51-180](), [costmap_2d/CMakeLists.txt:85-101](), [navfn/CMakeLists.txt:65-69](), [global_planner/CMakeLists.txt:43-53](), [base_local_planner/CMakeLists.txt:93-120](), [dwa_local_planner/CMakeLists.txt:49-51]()\n\nThe `move_base` node acts as the central coordinator for the navigation stack. It manages two costmaps (one for global planning and one for local planning), loads the appropriate plugins for global planning, local planning, and recovery behaviors, and implements a state machine to control the navigation process.\n\n## Plugin Architecture\n\nThe navigation stack uses a flexible plugin architecture defined through interfaces in the `nav_core` package. This architecture allows different implementations to be loaded at runtime based on configuration parameters.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n    }\n    \n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class NavfnROS {\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class GlobalPlanner {\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class TrajectoryPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n    }\n    \n    class DWAPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n    }\n    \n    class ClearCostmapRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class RotateRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    BaseGlobalPlanner \u003c|-- NavfnROS\n    BaseGlobalPlanner \u003c|-- GlobalPlanner\n    BaseLocalPlanner \u003c|-- TrajectoryPlannerROS\n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n    RecoveryBehavior \u003c|-- ClearCostmapRecovery\n    RecoveryBehavior \u003c|-- RotateRecovery\n    \n    MoveBase --\u003e BaseGlobalPlanner: uses\n    MoveBase --\u003e BaseLocalPlanner: uses\n    MoveBase --\u003e RecoveryBehavior: uses\n```\n\nSources: [move_base/src/move_base.cpp:124-140](), [move_base/src/move_base.cpp:225-266](), [move_base/include/move_base/move_base.h:209-211]()\n\nPlugins are loaded using the `pluginlib::ClassLoader` to dynamically load classes based on the plugin specification in package XML files. This allows users to select different planner implementations through configuration parameters.\n\n## move_base\n\nThe `move_base` node serves as the central coordinator for the navigation stack. It implements a state machine to control the navigation process and coordinates the interactions between global planners, local planners, costmaps, and recovery behaviors.\n\n### State Machine\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e PLANNING\n    \n    PLANNING --\u003e CONTROLLING: Valid Plan Found\n    PLANNING --\u003e CLEARING: Planning Failed/Timeout\n    \n    CONTROLLING --\u003e PLANNING: Control Failed/Path Needs Replan\n    CONTROLLING --\u003e CLEARING: Oscillation/Control Timeout\n    CONTROLLING --\u003e [*]: Goal Reached\n    \n    CLEARING --\u003e PLANNING: Recovery Complete\n    CLEARING --\u003e [*]: All Recovery Behaviors Failed\n```\n\nSources: [move_base/include/move_base/move_base.h:66-70](), [move_base/src/move_base.cpp:801-943]()\n\nIn the PLANNING state, `move_base` attempts to generate a global plan from the current position to the goal. In the CONTROLLING state, it follows that plan using the local planner to generate velocity commands. If either planning or control fails, it transitions to the CLEARING state to execute recovery behaviors.\n\n### Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant MoveBaseNode as \"move_base_node\"\n    participant MoveBase as \"MoveBase\"\n    participant GlobalPlanner as \"Global Planner\"\n    participant LocalPlanner as \"Local Planner\"\n    participant Recovery as \"Recovery Behaviors\"\n    \n    Client-\u003e\u003eMoveBaseNode: Send Goal (ActionLib)\n    MoveBaseNode-\u003e\u003eMoveBase: Execute Goal\n    \n    activate MoveBase\n    MoveBase-\u003e\u003eMoveBase: Initialize State (PLANNING)\n    \n    loop until goal reached or aborted\n        alt State = PLANNING\n            MoveBase-\u003e\u003eGlobalPlanner: makePlan(start, goal, plan)\n            GlobalPlanner--\u003e\u003eMoveBase: Return Plan\n            \n            alt Plan Valid\n                MoveBase-\u003e\u003eLocalPlanner: setPlan(plan)\n                MoveBase-\u003e\u003eMoveBase: State = CONTROLLING\n            else Plan Invalid/Timeout\n                MoveBase-\u003e\u003eMoveBase: State = CLEARING\n            end\n            \n        else State = CONTROLLING\n            MoveBase-\u003e\u003eLocalPlanner: computeVelocityCommands(cmd_vel)\n            LocalPlanner--\u003e\u003eMoveBase: Return Velocity\n            \n            alt Velocity Valid\n                MoveBase-\u003e\u003eMoveBaseNode: Publish Velocity Command\n            else Control Failed\n                MoveBase-\u003e\u003eMoveBase: State = PLANNING or CLEARING\n            end\n            \n            MoveBase-\u003e\u003eLocalPlanner: isGoalReached()\n            LocalPlanner--\u003e\u003eMoveBase: Goal Status\n            \n            alt Goal Reached\n                MoveBase-\u003e\u003eMoveBaseNode: Send Success Result\n                deactivate MoveBase\n            end\n            \n        else State = CLEARING\n            MoveBase-\u003e\u003eRecovery: runBehavior()\n            Recovery--\u003e\u003eMoveBase: Behavior Result\n            MoveBase-\u003e\u003eMoveBase: State = PLANNING\n        end\n    end\n```\n\nSources: [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:569-648](), [move_base/src/move_base_node.cpp:33-44]()\n\nThe `move_base` node receives goals through an ActionLib interface. It then coordinates the planning and execution process through its internal state machine. The planning thread continuously generates global plans, while the control loop generates velocity commands at a specified frequency. If planning or control fails, recovery behaviors are executed to try to resolve the issue.\n\n## Costmap2D\n\nThe `costmap_2d` package provides a 2D grid representation of the environment that the robot uses for planning and obstacle avoidance. It consists of multiple layers that can be combined to create a complete representation of the environment.\n\n### Layered Architecture\n\n```mermaid\nclassDiagram\n    class Costmap2DROS {\n        +initialize()\n        +update()\n        +getRobotPose()\n        +getLayeredCostmap()\n        +getCostmap()\n    }\n    \n    class LayeredCostmap {\n        +updateMap()\n        +resizeMap()\n        +addPlugin()\n        -Costmap2D* costmap_\n        -std::vector\u003cLayer*\u003e plugins_\n    }\n    \n    class Costmap2D {\n        +getCost(x, y)\n        +setCost(x, y, cost)\n        +mapToWorld(mx, my, wx, wy)\n        +worldToMap(wx, wy, mx, my)\n        -unsigned char* costmap_\n    }\n    \n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +activate()\n        +deactivate()\n    }\n    \n    class StaticLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class ObstacleLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class InflationLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class VoxelLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    Costmap2DROS \"1\" --\u003e \"1\" LayeredCostmap : contains\n    LayeredCostmap \"1\" --\u003e \"1\" Costmap2D : contains\n    LayeredCostmap \"1\" --\u003e \"*\" Layer : manages\n    \n    Layer \u003c|-- StaticLayer\n    Layer \u003c|-- ObstacleLayer\n    Layer \u003c|-- InflationLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nSources: [costmap_2d/CMakeLists.txt:85-108]()\n\nThe `Costmap2DROS` class provides the ROS interface for the costmap system. It contains a `LayeredCostmap` that manages the underlying `Costmap2D` and multiple `Layer` implementations. Each layer contributes different information to the costmap:\n\n- **StaticLayer**: Adds static map data from a map server\n- **ObstacleLayer**: Incorporates sensor observations\n- **InflationLayer**: Expands obstacles to account for robot size\n- **VoxelLayer**: Provides 3D obstacle representation\n\n### Costmap Update Process\n\n```mermaid\nflowchart TD\n    subgraph Costmap2DROS[\"Costmap2DROS::update()\"]\n        A[\"Get Current Robot Position\"]\n        B[\"Check if Robot Moved Enough\"]\n        C[\"Update Layered Costmap\"]\n    end\n    \n    subgraph LayeredCostmap[\"LayeredCostmap::updateMap()\"]\n        D[\"Reset Bounds\"]\n        E[\"Update Bounds for Each Layer\"]\n        F[\"Update Master Grid\"]\n        G[\"Update Costs for Each Layer\"]\n    end\n    \n    subgraph Layer[\"Layer::updateBounds/updateCosts\"]\n        H[\"Static Layer: Load Map Data\"]\n        I[\"Obstacle Layer: Process Sensor Data\"]\n        J[\"Inflation Layer: Inflate Obstacles\"]\n    end\n    \n    A --\u003e B\n    B --\u003e|Yes| C\n    C --\u003e D\n    D --\u003e E\n    E --\u003e F\n    F --\u003e G\n    G --\u003e H\n    G --\u003e I\n    G --\u003e J\n```\n\nSources: [costmap_2d/CMakeLists.txt:85-108]()\n\nThe costmap update process begins with `Costmap2DROS::update()`, which checks if the robot has moved enough to warrant an update. If so, it calls `LayeredCostmap::updateMap()`, which resets the bounds, updates the bounds for each layer, updates the master grid, and then updates the costs for each layer.\n\n## Planning Subsystem\n\nThe planning subsystem consists of two main components: global planners and local planners.\n\n### Global Planners\n\nGlobal planners generate a path from the robot's current position to the goal position using the global costmap.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class NavfnROS {\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class GlobalPlanner {\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n        -Expander* planner_\n    }\n    \n    class CarrotPlanner {\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan)\n    }\n    \n    class Expander {\n        \u003c\u003cinterface\u003e\u003e\n        +calculatePotentials()\n    }\n    \n    class AStarExpansion {\n        +calculatePotentials()\n    }\n    \n    class DijkstraExpansion {\n        +calculatePotentials()\n    }\n    \n    BaseGlobalPlanner \u003c|-- NavfnROS\n    BaseGlobalPlanner \u003c|-- GlobalPlanner\n    BaseGlobalPlanner \u003c|-- CarrotPlanner\n    \n    GlobalPlanner --\u003e Expander\n    Expander \u003c|-- AStarExpansion\n    Expander \u003c|-- DijkstraExpansion\n```\n\nSources: [navfn/CMakeLists.txt:65-69](), [global_planner/CMakeLists.txt:43-53](), [carrot_planner/CMakeLists.txt:37-41]()\n\nThe navigation stack includes several global planner implementations:\n- **NavfnROS**: Uses a fast interpolated navigation function algorithm\n- **GlobalPlanner**: A more configurable planner with options for A* or Dijkstra's algorithm\n- **CarrotPlanner**: A simple planner that places a \"carrot\" (intermediate goal) for the robot to follow\n\n### Local Planners\n\nLocal planners generate velocity commands to move the robot along the global plan while avoiding obstacles.\n\n```mermaid\nclassDiagram\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n    }\n    \n    class TrajectoryPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n        -TrajectoryPlanner* tc_\n    }\n    \n    class DWAPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel)\n        +isGoalReached()\n        +setPlan(global_plan)\n        -DWAPlanner* dp_\n    }\n    \n    class TrajectoryPlanner {\n        +updatePlan(global_plan)\n        +findBestPath(drive_velocities)\n    }\n    \n    class DWAPlanner {\n        +findBestPath(drive_velocities)\n        +scoreTrajectory(traj)\n    }\n    \n    BaseLocalPlanner \u003c|-- TrajectoryPlannerROS\n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n    \n    TrajectoryPlannerROS --\u003e TrajectoryPlanner\n    DWAPlannerROS --\u003e DWAPlanner\n```\n\nSources: [base_local_planner/CMakeLists.txt:93-120](), [dwa_local_planner/CMakeLists.txt:49-51]()\n\nThe navigation stack includes two main local planner implementations:\n- **TrajectoryPlannerROS**: An implementation of the Trajectory Rollout algorithm\n- **DWAPlannerROS**: An implementation of the Dynamic Window Approach\n\nBoth planners generate candidate trajectories and score them based on various metrics such as proximity to obstacles, progress toward the goal, and adherence to the global plan.\n\n## Recovery Behaviors\n\nRecovery behaviors are actions taken when planning or control fails. They attempt to resolve issues that might be preventing the robot from navigating successfully.\n\n```mermaid\nclassDiagram\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class ClearCostmapRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n        -void clear(costmap_2d::Costmap2DROS* costmap)\n    }\n    \n    class RotateRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class MoveSlowAndClear {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    RecoveryBehavior \u003c|-- ClearCostmapRecovery\n    RecoveryBehavior \u003c|-- RotateRecovery\n    RecoveryBehavior \u003c|-- MoveSlowAndClear\n```\n\nSources: [clear_costmap_recovery/CMakeLists.txt:34-36](), [rotate_recovery/CMakeLists.txt:40-42](), [move_slow_and_clear/CMakeLists.txt:35-40]()\n\nThe navigation stack includes three main recovery behaviors:\n- **ClearCostmapRecovery**: Clears obstacles from the costmap that might be preventing planning\n- **RotateRecovery**: Rotates the robot in place to find a clear path\n- **MoveSlowAndClear**: Reduces speed and clears obstacles from the costmap\n\nThese behaviors are executed in sequence when the robot gets stuck or cannot find a valid plan or control.\n\n## Integration and Data Flow\n\nThis diagram illustrates the data flow between components during navigation:\n\n```mermaid\nflowchart TD\n    subgraph Input[\"Input Sources\"]\n        MapServer[\"map_server\"]\n        Sensors[\"Sensor Data\u003cbr\u003e(laser, pointcloud)\"]\n        TF[\"tf\u003cbr\u003e(robot position)\"]\n    end\n    \n    subgraph MoveBase[\"move_base\"]\n        GlobalCostmap[\"Global Costmap\"]\n        GlobalPlanner[\"Global Planner\"]\n        LocalCostmap[\"Local Costmap\"]\n        LocalPlanner[\"Local Planner\"]\n        Recovery[\"Recovery Behaviors\"]\n    end\n    \n    subgraph Output[\"Output\"]\n        CmdVel[\"cmd_vel\"]\n    end\n    \n    MapServer --\u003e GlobalCostmap\n    Sensors --\u003e GlobalCostmap\n    Sensors --\u003e LocalCostmap\n    TF --\u003e GlobalCostmap\n    TF --\u003e LocalCostmap\n    TF --\u003e GlobalPlanner\n    TF --\u003e LocalPlanner\n    \n    GlobalCostmap --\u003e GlobalPlanner\n    GlobalPlanner --\u003e LocalPlanner\n    LocalCostmap --\u003e LocalPlanner\n    LocalPlanner --\u003e CmdVel\n    \n    GlobalCostmap --\u003e Recovery\n    LocalCostmap --\u003e Recovery\n    Recovery --\u003e GlobalCostmap\n    Recovery --\u003e LocalCostmap\n```\n\nSources: [move_base/src/move_base.cpp:96-97](), [move_base/src/move_base.cpp:509-510](), [move_base/src/move_base.cpp:801-943]()\n\nThis diagram shows how data flows through the navigation stack. The system takes input from the map server, sensors, and tf transforms. The global planner uses the global costmap to generate a path, which the local planner follows using the local costmap to generate velocity commands. If planning or control fails, recovery behaviors are executed to attempt to resolve the issue.\n\n## Conclusion\n\nThe ROS Navigation Stack is a modular, plugin-based system centered around the `move_base` node. It uses a combination of global planning, local planning, costmap management, and recovery behaviors to navigate a robot from its current position to a goal position while avoiding obstacles.\n\nThe plugin architecture allows users to swap out different implementations of global planners, local planners, and recovery behaviors without modifying the core framework. This makes the system highly flexible and adaptable to different robot platforms and environments."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"16:T381e,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Packages\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/package.xml](amcl/package.xml)\n- [base_local_planner/package.xml](base_local_planner/package.xml)\n- [carrot_planner/package.xml](carrot_planner/package.xml)\n- [clear_costmap_recovery/package.xml](clear_costmap_recovery/package.xml)\n- [costmap_2d/package.xml](costmap_2d/package.xml)\n- [dwa_local_planner/package.xml](dwa_local_planner/package.xml)\n- [fake_localization/package.xml](fake_localization/package.xml)\n- [map_server/package.xml](map_server/package.xml)\n- [move_base/package.xml](move_base/package.xml)\n- [move_slow_and_clear/package.xml](move_slow_and_clear/package.xml)\n- [nav_core/package.xml](nav_core/package.xml)\n- [navfn/package.xml](navfn/package.xml)\n- [navigation/README.rst](navigation/README.rst)\n- [navigation/package.xml](navigation/package.xml)\n- [rotate_recovery/package.xml](rotate_recovery/package.xml)\n- [voxel_grid/package.xml](voxel_grid/package.xml)\n\n\u003c/details\u003e\n\n\n\nThis document provides a comprehensive overview of the packages that make up the ROS Navigation Stack. It describes each package's purpose, functionality, and relationship to other components in the system. For information about the overall architecture of the navigation stack, see [Architecture](#1.1). For details on the plugin system used throughout these packages, see [Plugin System](#1.3).\n\n## Package Organization\n\nThe ROS Navigation Stack is composed of several specialized packages that work together to provide robot navigation capabilities. These packages can be organized into functional categories:\n\n```mermaid\ngraph TD\n    subgraph \"Core Infrastructure\"\n        Nav[\"navigation\"]\n        NavCore[\"nav_core\"]\n        MB[\"move_base\"]\n    end\n    \n    subgraph \"Environment Representation\"\n        CM[\"costmap_2d\"]\n        VG[\"voxel_grid\"]\n    end\n    \n    subgraph \"Global Planners\"\n        NF[\"navfn\"]\n        GP[\"global_planner\"]\n        CP[\"carrot_planner\"]\n    end\n    \n    subgraph \"Local Planners\"\n        BLP[\"base_local_planner\"]\n        DWA[\"dwa_local_planner\"]\n    end\n    \n    subgraph \"Recovery Behaviors\"\n        CCR[\"clear_costmap_recovery\"]\n        RR[\"rotate_recovery\"]\n        MSC[\"move_slow_and_clear\"]\n    end\n    \n    subgraph \"Localization\"\n        AMCL[\"amcl\"]\n        FL[\"fake_localization\"]\n    end\n    \n    subgraph \"Utilities\"\n        MS[\"map_server\"]\n    end\n    \n    Nav --\u003e MB\n    Nav --\u003e NavCore\n    Nav --\u003e CM\n    Nav --\u003e VG\n    Nav --\u003e NF\n    Nav --\u003e GP\n    Nav --\u003e CP\n    Nav --\u003e BLP\n    Nav --\u003e DWA\n    Nav --\u003e CCR\n    Nav --\u003e RR\n    Nav --\u003e MSC\n    Nav --\u003e AMCL\n    Nav --\u003e FL\n    Nav --\u003e MS\n```\n\nSources: [navigation/package.xml:21-36]()\n\n## Package Dependencies\n\nThe packages in the Navigation Stack have specific dependencies on each other. Understanding these relationships is essential for developing with or modifying the stack:\n\n```mermaid\nflowchart TD\n    subgraph \"Core\"\n        MB[\"move_base\"]\n        NavCore[\"nav_core\"]\n    end\n    \n    subgraph \"Environment\"\n        CM[\"costmap_2d\"]\n        VG[\"voxel_grid\"]\n    end\n    \n    subgraph \"Planning\"\n        NF[\"navfn\"]\n        CP[\"carrot_planner\"]\n        BLP[\"base_local_planner\"]\n        DWA[\"dwa_local_planner\"]\n    end\n    \n    subgraph \"Recovery\"\n        CCR[\"clear_costmap_recovery\"]\n        RR[\"rotate_recovery\"]\n        MSC[\"move_slow_and_clear\"]\n    end\n    \n    MB --\u003e CM\n    MB --\u003e NavCore\n    MB --\u003e NF\n    MB --\u003e BLP\n    MB --\u003e CCR\n    MB --\u003e RR\n    \n    NF --\u003e CM\n    NF --\u003e NavCore\n    \n    CP --\u003e CM\n    CP --\u003e NavCore\n    CP --\u003e BLP\n    \n    BLP --\u003e CM\n    \n    DWA --\u003e BLP\n    DWA --\u003e CM\n    DWA --\u003e NavCore\n    \n    CCR --\u003e CM\n    CCR --\u003e NavCore\n    \n    RR --\u003e CM\n    RR --\u003e NavCore\n    RR --\u003e BLP\n    \n    MSC --\u003e CM\n    MSC --\u003e NavCore\n    \n    CM --\u003e VG\n```\n\nSources: [move_base/package.xml:25-44](), [navfn/package.xml:31-40](), [carrot_planner/package.xml:24-32](), [base_local_planner/package.xml:28-44](), [dwa_local_planner/package.xml:31-42](), [clear_costmap_recovery/package.xml:23-28](), [rotate_recovery/package.xml:25-33](), [move_slow_and_clear/package.xml:23-27](), [costmap_2d/package.xml:32-47]()\n\n## Package Descriptions\n\n### Core Infrastructure Packages\n\n#### navigation\n\nThe `navigation` metapackage is the top-level package that groups all components of the navigation stack. It doesn't contain code itself but serves as a convenient way to install all navigation components together.\n\n**Description**: A 2D navigation stack that takes in information from odometry, sensor streams, and a goal pose and outputs safe velocity commands that are sent to a mobile base.\n\nSources: [navigation/package.xml:4-10](), [navigation/README.rst:1-6]()\n\n#### nav_core\n\nThe `nav_core` package defines the core interfaces that standardize the navigation stack components.\n\n**Description**: Provides common interfaces for navigation-specific robot actions, including `BaseGlobalPlanner`, `BaseLocalPlanner`, and `RecoveryBehavior` interfaces. These interfaces allow for easy swapping of planners, controllers, and recovery behaviors.\n\nSources: [nav_core/package.xml:6-9]()\n\n#### move_base\n\nThe `move_base` package is the central coordinator of the navigation stack.\n\n**Description**: Implements an action that attempts to reach a goal with a mobile base. It links together global and local planners, maintains two costmaps (one for global planning and one for local planning), and manages recovery behaviors when navigation fails.\n\nSources: [move_base/package.xml:6-9]()\n\n### Environment Representation Packages\n\n#### costmap_2d\n\nThe `costmap_2d` package provides a 2D representation of the robot's environment.\n\n**Description**: Implements a 2D costmap that takes sensor data from the world, builds an occupancy grid, and inflates costs based on the occupancy grid and a user-specified inflation radius. It supports map_server-based initialization, rolling windows, and parameter-based configuration of sensor topics.\n\nSources: [costmap_2d/package.xml:6-14]()\n\n#### voxel_grid\n\nThe `voxel_grid` package provides a 3D representation of the robot's environment.\n\n**Description**: Implements an efficient 3D voxel grid with three cell states: marked, free, or unknown. Limited to 16 different levels per voxel column, which enables raytracing and cell marking performance comparable to 2D structures.\n\nSources: [voxel_grid/package.xml:6-9]()\n\n### Global Planner Packages\n\n#### navfn\n\nThe `navfn` package implements a global path planner.\n\n**Description**: Provides a fast interpolated navigation function for creating plans for a mobile base. It uses Dijkstra's algorithm to find a minimum cost path in a grid and assumes a circular robot. Adheres to the `nav_core::BaseGlobalPlanner` interface.\n\nSources: [navfn/package.xml:6-14]()\n\n#### carrot_planner\n\nThe `carrot_planner` package implements a simple global path planner.\n\n**Description**: Attempts to find a legal place to put a \"carrot\" for the robot to follow. It does this by moving back along the vector between the robot and the goal point. Adheres to the `nav_core::BaseGlobalPlanner` interface.\n\nSources: [carrot_planner/package.xml:6-9]()\n\n### Local Planner Packages\n\n#### base_local_planner\n\nThe `base_local_planner` package provides local trajectory planning.\n\n**Description**: Implements the Trajectory Rollout and Dynamic Window approaches to local robot navigation. It produces velocity commands for a mobile base given a plan to follow and a costmap. Supports both holonomic and non-holonomic robots, any robot footprint representable as a convex polygon or circle, and is configurable via ROS parameters. Adheres to the `nav_core::BaseLocalPlanner` interface.\n\nSources: [base_local_planner/package.xml:6-9]()\n\n#### dwa_local_planner\n\nThe `dwa_local_planner` package provides an alternative local trajectory planning approach.\n\n**Description**: Implements the Dynamic Window Approach to local robot navigation. Like `base_local_planner`, it produces velocity commands for a mobile base given a plan and a costmap. Supports any robot whose footprint can be represented as a convex polygon or circle, and is dynamically reconfigurable. Adheres to the `nav_core::BaseLocalPlanner` interface.\n\nSources: [dwa_local_planner/package.xml:6-15]()\n\n### Localization Packages\n\n#### amcl\n\nThe `amcl` package provides probabilistic localization.\n\n**Description**: A probabilistic localization system for a robot moving in 2D. It implements the adaptive (or KLD-sampling) Monte Carlo localization approach using a particle filter to track the pose of a robot against a known map.\n\nSources: [amcl/package.xml:6-17]()\n\n#### fake_localization\n\nThe `fake_localization` package provides a simple alternative to AMCL.\n\n**Description**: A ROS node that simply forwards odometry information. Useful for testing or for situations where full probabilistic localization is not needed.\n\nSources: [fake_localization/package.xml:6]()\n\n### Recovery Behavior Packages\n\n#### clear_costmap_recovery\n\nThe `clear_costmap_recovery` package implements a recovery behavior for clearing costmaps.\n\n**Description**: Provides a recovery behavior that attempts to clear space by reverting the costmaps used by the navigation stack to the static map outside of a given area. Adheres to the `nav_core::RecoveryBehavior` interface.\n\nSources: [clear_costmap_recovery/package.xml:6-9]()\n\n#### rotate_recovery\n\nThe `rotate_recovery` package implements a recovery behavior for rotation.\n\n**Description**: Provides a recovery behavior that attempts to clear space by performing a 360-degree rotation of the robot. Adheres to the `nav_core::RecoveryBehavior` interface.\n\nSources: [rotate_recovery/package.xml:6-9]()\n\n#### move_slow_and_clear\n\nThe `move_slow_and_clear` package implements a recovery behavior for slow movement.\n\n**Description**: Provides a recovery behavior that slows down the robot's movement and clears obstacles from the costmap. Adheres to the `nav_core::RecoveryBehavior` interface.\n\nSources: [move_slow_and_clear/package.xml:6-9]()\n\n### Utility Packages\n\n#### map_server\n\nThe `map_server` package provides map management.\n\n**Description**: Provides the `map_server` ROS Node, which offers map data as a ROS Service. It also provides the `map_saver` command-line utility, which allows dynamically generated maps to be saved to file.\n\nSources: [map_server/package.xml:6-9]()\n\n## Package Functionality Table\n\nThe following table summarizes the main functionality of each package and its role in the navigation stack:\n\n| Package | Category | Primary Functionality | Key Components |\n|---------|----------|----------------------|----------------|\n| navigation | Core | Metapackage for all navigation components | N/A |\n| nav_core | Core | Core interfaces for navigation | BaseGlobalPlanner, BaseLocalPlanner, RecoveryBehavior |\n| move_base | Core | Central navigation coordinator | Action server, state machine |\n| costmap_2d | Environment | 2D environment representation | Costmap2DROS, LayeredCostmap |\n| voxel_grid | Environment | 3D environment representation | VoxelGrid |\n| navfn | Global Planning | Navigation function path planning | NavfnROS |\n| carrot_planner | Global Planning | Simple vector-based planning | CarrotPlanner |\n| base_local_planner | Local Planning | Trajectory generation | TrajectoryPlannerROS |\n| dwa_local_planner | Local Planning | Dynamic window approach | DWAPlannerROS |\n| amcl | Localization | Probabilistic localization | Particle filter |\n| fake_localization | Localization | Simple odometry forwarding | N/A |\n| clear_costmap_recovery | Recovery | Clearing obstacles from costmap | ClearCostmapRecovery |\n| rotate_recovery | Recovery | Robot rotation to find clear path | RotateRecovery |\n| move_slow_and_clear | Recovery | Slowing down and clearing obstacles | MoveSlowAndClear |\n| map_server | Utility | Map management | map_server, map_saver |\n\nSources: All package.xml files\n\n## Plugin Architecture\n\nMany packages in the navigation stack implement the plugin interfaces defined in the `nav_core` package. This plugin architecture allows for easy extension and customization of the navigation system.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, costmap, frame_id)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, costmap)\n        +computeVelocityCommands(cmd_vel) bool\n        +isGoalReached() bool\n        +setPlan(plan) bool\n    }\n    \n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class NavfnROS {\n        +initialize(name, costmap, frame_id)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class CarrotPlanner {\n        +initialize(name, costmap, frame_id)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class TrajectoryPlannerROS {\n        +initialize(name, tf, costmap)\n        +computeVelocityCommands(cmd_vel) bool\n        +isGoalReached() bool\n        +setPlan(plan) bool\n    }\n    \n    class DWAPlannerROS {\n        +initialize(name, tf, costmap)\n        +computeVelocityCommands(cmd_vel) bool\n        +isGoalReached() bool\n        +setPlan(plan) bool\n    }\n    \n    class ClearCostmapRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class RotateRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class MoveSlowAndClear {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    BaseGlobalPlanner \u003c|-- NavfnROS\n    BaseGlobalPlanner \u003c|-- CarrotPlanner\n    \n    BaseLocalPlanner \u003c|-- TrajectoryPlannerROS\n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n    \n    RecoveryBehavior \u003c|-- ClearCostmapRecovery\n    RecoveryBehavior \u003c|-- RotateRecovery\n    RecoveryBehavior \u003c|-- MoveSlowAndClear\n```\n\nSources: [nav_core/package.xml:6-9](), [navfn/package.xml:46-48](), [carrot_planner/package.xml:34-36](), [base_local_planner/package.xml:49-51](), [dwa_local_planner/package.xml:44-46](), [clear_costmap_recovery/package.xml:32-34](), [rotate_recovery/package.xml:35-37](), [move_slow_and_clear/package.xml:29-31]()\n\nFor more details on how the plugin system works, see [Plugin System](#1.3)."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"17:T4b91,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Plugin System\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/include/base_local_planner/odometry_helper_ros.h](base_local_planner/include/base_local_planner/odometry_helper_ros.h)\n- [base_local_planner/src/odometry_helper_ros.cpp](base_local_planner/src/odometry_helper_ros.cpp)\n- [carrot_planner/include/carrot_planner/carrot_planner.h](carrot_planner/include/carrot_planner/carrot_planner.h)\n- [carrot_planner/src/carrot_planner.cpp](carrot_planner/src/carrot_planner.cpp)\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h](clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h)\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp](clear_costmap_recovery/src/clear_costmap_recovery.cpp)\n- [costmap_2d/include/costmap_2d/costmap_layer.h](costmap_2d/include/costmap_2d/costmap_layer.h)\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n- [costmap_2d/src/costmap_layer.cpp](costmap_2d/src/costmap_layer.cpp)\n- [dwa_local_planner/cfg/DWAPlanner.cfg](dwa_local_planner/cfg/DWAPlanner.cfg)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner.h](dwa_local_planner/include/dwa_local_planner/dwa_planner.h)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h](dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h)\n- [dwa_local_planner/src/dwa_planner.cpp](dwa_local_planner/src/dwa_planner.cpp)\n- [dwa_local_planner/src/dwa_planner_ros.cpp](dwa_local_planner/src/dwa_planner_ros.cpp)\n- [nav_core/include/nav_core/base_global_planner.h](nav_core/include/nav_core/base_global_planner.h)\n- [nav_core/include/nav_core/base_local_planner.h](nav_core/include/nav_core/base_local_planner.h)\n- [nav_core/include/nav_core/recovery_behavior.h](nav_core/include/nav_core/recovery_behavior.h)\n- [navfn/include/navfn/navfn_ros.h](navfn/include/navfn/navfn_ros.h)\n- [navfn/src/navfn_ros.cpp](navfn/src/navfn_ros.cpp)\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h](rotate_recovery/include/rotate_recovery/rotate_recovery.h)\n- [rotate_recovery/src/rotate_recovery.cpp](rotate_recovery/src/rotate_recovery.cpp)\n\n\u003c/details\u003e\n\n\n\nThe ROS Navigation Stack uses a plugin architecture to provide modularity and extensibility. This plugin system allows users to swap out different implementations of key navigation components without modifying the core codebase. This document explains how the plugin system works, the available plugin interfaces, and how to create custom plugins.\n\nFor information about specific plugin implementations like global planners or local planners, see their respective wiki pages ([Global Planners](#4), [Local Planners](#5), and [Recovery Behaviors](#7)).\n\n## Overview of the Plugin System\n\nThe Navigation Stack defines several plugin interfaces for critical navigation components, allowing different implementations to be easily interchanged:\n\n```mermaid\ngraph TD\n    subgraph \"move_base Node\"\n        mb[Central Coordinator]\n    end\n    \n    subgraph \"Plugin Interfaces\"\n        bgp[\"nav_core::BaseGlobalPlanner\"]\n        blp[\"nav_core::BaseLocalPlanner\"]\n        rb[\"nav_core::RecoveryBehavior\"]\n    end\n    \n    subgraph \"Plugin Implementations\"\n        navfn[\"navfn::NavfnROS\"]\n        carrot[\"carrot_planner::CarrotPlanner\"]\n        dwa[\"dwa_local_planner::DWAPlannerROS\"]\n        rotate[\"rotate_recovery::RotateRecovery\"]\n        clear[\"clear_costmap_recovery::ClearCostmapRecovery\"]\n    end\n    \n    mb --\u003e bgp\n    mb --\u003e blp\n    mb --\u003e rb\n    \n    bgp --\u003e navfn\n    bgp --\u003e carrot\n    blp --\u003e dwa\n    rb --\u003e rotate\n    rb --\u003e clear\n```\n\nThe plugin architecture provides several benefits:\n\n1. **Modularity**: Components can be developed and tested independently\n2. **Extensibility**: New implementations can be added without modifying existing code\n3. **Runtime flexibility**: Different plugins can be selected via configuration files\n4. **Maintainability**: Clear interfaces make the code more understandable and maintainable\n\nSources: [nav_core/include/nav_core/base_global_planner.h](), [nav_core/include/nav_core/base_local_planner.h](), [nav_core/include/nav_core/recovery_behavior.h]()\n\n## Key Plugin Interfaces\n\n### Global Planner Plugins\n\nGlobal planners generate a path from the robot's current position to a goal position. They implement the `nav_core::BaseGlobalPlanner` interface:\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class NavfnROS {\n        +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class CarrotPlanner {\n        +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    BaseGlobalPlanner \u003c|-- NavfnROS\n    BaseGlobalPlanner \u003c|-- CarrotPlanner\n```\n\nThe key methods that global planner plugins must implement are:\n\n- `initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros)`: Sets up the planner with a costmap\n- `makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan)`: Generates a path from start to goal\n\nExample implementations include:\n- `NavfnROS`: A navigation function implementation using wavefront propagation\n- `CarrotPlanner`: A simple planner that generates a straight path toward the goal\n\nSources: [nav_core/include/nav_core/base_global_planner.h](), [navfn/include/navfn/navfn_ros.h](), [carrot_planner/include/carrot_planner/carrot_planner.h]()\n\n### Local Planner Plugins\n\nLocal planners generate velocity commands to follow the global path while avoiding obstacles. They implement the `nav_core::BaseLocalPlanner` interface:\n\n```mermaid\nclassDiagram\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n    }\n    \n    class DWAPlannerROS {\n        +initialize(string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n    }\n    \n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n```\n\nThe key methods that local planner plugins must implement are:\n\n- `initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros)`: Sets up the planner with transform and costmap information\n- `bool computeVelocityCommands(geometry_msgs::Twist\u0026 cmd_vel)`: Calculates the next velocity command\n- `bool setPlan(const std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan)`: Sets the global plan to follow\n- `bool isGoalReached()`: Determines if the goal has been reached\n\nExample implementations include:\n- `DWAPlannerROS`: Implements the Dynamic Window Approach (DWA) for local planning\n\nSources: [nav_core/include/nav_core/base_local_planner.h](), [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h]()\n\n### Recovery Behavior Plugins\n\nRecovery behaviors are triggered when the robot gets stuck or cannot find a valid plan. They implement the `nav_core::RecoveryBehavior` interface:\n\n```mermaid\nclassDiagram\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* global_costmap, costmap_2d::Costmap2DROS* local_costmap)\n        +runBehavior()\n    }\n    \n    class RotateRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class ClearCostmapRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    RecoveryBehavior \u003c|-- RotateRecovery\n    RecoveryBehavior \u003c|-- ClearCostmapRecovery\n```\n\nThe key methods that recovery behavior plugins must implement are:\n\n- `initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* global_costmap, costmap_2d::Costmap2DROS* local_costmap)`: Sets up the behavior with transform and costmap information\n- `runBehavior()`: Executes the recovery action\n\nExample implementations include:\n- `RotateRecovery`: Rotates the robot in place to find a clear path\n- `ClearCostmapRecovery`: Clears obstacles from the costmap that may be stale\n\nSources: [nav_core/include/nav_core/recovery_behavior.h](), [rotate_recovery/include/rotate_recovery/rotate_recovery.h](), [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h]()\n\n### Costmap Layer Plugins\n\nThe navigation stack also uses plugins for costmap representation. Costmap layers allow different sources of information to be combined into a single costmap. They implement the `costmap_2d::Layer` interface:\n\n```mermaid\nclassDiagram\n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(LayeredCostmap* parent, string name)\n        +updateBounds(robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y)\n        +updateCosts(master_grid, min_i, min_j, max_i, max_j)\n    }\n    \n    class CostmapLayer {\n        +updateWithMax(master_grid, min_i, min_j, max_i, max_j)\n        +updateWithOverwrite(master_grid, min_i, min_j, max_i, max_j)\n    }\n    \n    class StaticLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class ObstacleLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class InflationLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class VoxelLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    Layer \u003c|-- CostmapLayer\n    Layer \u003c|-- InflationLayer\n    CostmapLayer \u003c|-- StaticLayer\n    CostmapLayer \u003c|-- ObstacleLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nThe key methods that costmap layer plugins must implement are:\n\n- `initialize(LayeredCostmap* parent, std::string name)`: Sets up the layer with its parent costmap\n- `updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x, double* min_y, double* max_x, double* max_y)`: Updates bounds of the area that needs to be updated\n- `updateCosts(costmap_2d::Costmap2D\u0026 master_grid, int min_i, int min_j, int max_i, int max_j)`: Updates the master costmap with this layer's data\n\nExample implementations include:\n- `StaticLayer`: Incorporates static map data\n- `ObstacleLayer`: Adds obstacles from sensor data\n- `InflationLayer`: Inflates obstacles to account for robot size\n- `VoxelLayer`: Provides 3D representation of obstacles\n\nSources: [costmap_2d/include/costmap_2d/layer.h](), [costmap_2d/include/costmap_2d/static_layer.h](), [costmap_2d/include/costmap_2d/obstacle_layer.h](), [costmap_2d/include/costmap_2d/inflation_layer.h](), [costmap_2d/include/costmap_2d/voxel_layer.h]()\n\n## Plugin Registration and Loading\n\n### Plugin Registration\n\nPlugins are registered using the `pluginlib` ROS package. This registration makes the plugins discoverable at runtime without requiring hard-coded linking. The registration process involves two key components:\n\n1. **Code Registration**: Each plugin implementation must include a `PLUGINLIB_EXPORT_CLASS` macro that tells ROS about the plugin:\n\n```cpp\nPLUGINLIB_EXPORT_CLASS(namespace::ClassName, base_namespace::BaseClassName)\n```\n\nExamples from the codebase:\n\n```cpp\n// Global planner plugins\nPLUGINLIB_EXPORT_CLASS(navfn::NavfnROS, nav_core::BaseGlobalPlanner)\nPLUGINLIB_EXPORT_CLASS(carrot_planner::CarrotPlanner, nav_core::BaseGlobalPlanner)\n\n// Local planner plugin\nPLUGINLIB_EXPORT_CLASS(dwa_local_planner::DWAPlannerROS, nav_core::BaseLocalPlanner)\n\n// Recovery behavior plugins\nPLUGINLIB_EXPORT_CLASS(clear_costmap_recovery::ClearCostmapRecovery, nav_core::RecoveryBehavior)\nPLUGINLIB_EXPORT_CLASS(rotate_recovery::RotateRecovery, nav_core::RecoveryBehavior)\n\n// Costmap layer plugins\nPLUGINLIB_EXPORT_CLASS(costmap_2d::StaticLayer, costmap_2d::Layer)\nPLUGINLIB_EXPORT_CLASS(costmap_2d::ObstacleLayer, costmap_2d::Layer)\nPLUGINLIB_EXPORT_CLASS(costmap_2d::InflationLayer, costmap_2d::Layer)\nPLUGINLIB_EXPORT_CLASS(costmap_2d::VoxelLayer, costmap_2d::Layer)\n```\n\n2. **XML Description**: Each plugin package must also include an XML file that describes the plugins it provides. This is typically named `plugin.xml` or `pluginname_plugin.xml`.\n\nSources: [navfn/src/navfn_ros.cpp:44](), [dwa_local_planner/src/dwa_planner_ros.cpp:53](), [clear_costmap_recovery/src/clear_costmap_recovery.cpp:43](), [rotate_recovery/src/rotate_recovery.cpp:50](), [costmap_2d/plugins/inflation_layer.cpp:45](), [costmap_2d/plugins/obstacle_layer.cpp:45](), [costmap_2d/plugins/static_layer.cpp:45](), [costmap_2d/plugins/voxel_layer.cpp:43]()\n\n### Plugin Loading and Usage\n\n```mermaid\nsequenceDiagram\n    participant User as move_base\n    participant PL as pluginlib::ClassLoader\n    participant Plugin\n    \n    User-\u003e\u003ePL: Create loader for plugin interface\n    User-\u003e\u003ePL: Load plugin by name\n    PL-\u003e\u003ePlugin: Instantiate\n    PL-\u003e\u003eUser: Return plugin instance\n    User-\u003e\u003ePlugin: Initialize with parameters\n    User-\u003e\u003ePlugin: Call interface methods\n```\n\nThe actual plugin loading process works as follows:\n\n1. The `move_base` node (or another component) creates a `pluginlib::ClassLoader` for the plugin interface it needs\n2. It loads a specific plugin by name from configuration parameters\n3. It initializes the loaded plugin with appropriate parameters\n4. It calls the plugin's methods as needed during execution\n\nFor example, when loading a global planner:\n\n```cpp\n// Create a class loader for the BaseGlobalPlanner interface\npluginlib::ClassLoader\u003cnav_core::BaseGlobalPlanner\u003e planner_loader(\"nav_core\", \"nav_core::BaseGlobalPlanner\");\n\n// Load a specific planner by name (from parameters)\nboost::shared_ptr\u003cnav_core::BaseGlobalPlanner\u003e planner = planner_loader.createInstance(\"navfn/NavfnROS\");\n\n// Initialize the planner\nplanner-\u003einitialize(\"planner\", costmap_ros);\n\n// Use the planner to create paths\nplanner-\u003emakePlan(start, goal, plan);\n```\n\n## Creating Custom Plugins\n\nTo create a custom plugin for the navigation stack, follow these steps:\n\n1. **Create a class that inherits from the desired interface**\n   - For a global planner, inherit from `nav_core::BaseGlobalPlanner`\n   - For a local planner, inherit from `nav_core::BaseLocalPlanner`\n   - For a recovery behavior, inherit from `nav_core::RecoveryBehavior`\n   - For a costmap layer, inherit from `costmap_2d::Layer`\n\n2. **Implement all required methods**\n   - Each interface requires specific methods to be implemented\n\n3. **Register the plugin with pluginlib**\n   - Add the `PLUGINLIB_EXPORT_CLASS` macro in your implementation file\n\n4. **Create a plugin description XML file**\n   - This file tells ROS about your plugin\n\n5. **Update your package.xml to export the plugin**\n   - Adds an `\u003cexport\u003e` tag pointing to your plugin XML file\n\nHere's an example of creating a custom global planner:\n\n1. **Header file (my_planner.h)**:\n\n```cpp\n#include \u003cnav_core/base_global_planner.h\u003e\n\nnamespace my_planner_namespace {\n  class MyCustomPlanner : public nav_core::BaseGlobalPlanner {\n  public:\n    MyCustomPlanner();\n    ~MyCustomPlanner();\n    \n    void initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros);\n    bool makePlan(const geometry_msgs::PoseStamped\u0026 start,\n                 const geometry_msgs::PoseStamped\u0026 goal,\n                 std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan);\n  };\n}\n```\n\n2. **Implementation file (my_planner.cpp)**:\n\n```cpp\n#include \u003cmy_planner/my_planner.h\u003e\n#include \u003cpluginlib/class_list_macros.hpp\u003e\n\nPLUGINLIB_EXPORT_CLASS(my_planner_namespace::MyCustomPlanner, nav_core::BaseGlobalPlanner)\n\nnamespace my_planner_namespace {\n  // Implementation of methods...\n}\n```\n\n3. **Plugin description file (my_planner_plugin.xml)**:\n\n```xml\n\u003clibrary path=\"lib/libmy_planner\"\u003e\n  \u003cclass name=\"my_planner_namespace/MyCustomPlanner\" type=\"my_planner_namespace::MyCustomPlanner\" base_class_type=\"nav_core::BaseGlobalPlanner\"\u003e\n    \u003cdescription\u003eMy custom global planner implementation\u003c/description\u003e\n  \u003c/class\u003e\n\u003c/library\u003e\n```\n\n4. **Package.xml export tag**:\n\n```xml\n\u003cexport\u003e\n  \u003cnav_core plugin=\"${prefix}/my_planner_plugin.xml\" /\u003e\n\u003c/export\u003e\n```\n\n## Plugin Configuration\n\nThe Navigation Stack uses the ROS parameter server to determine which plugins to load and how to configure them. Here's how plugins are typically configured:\n\n### Global and Local Planner Configuration\n\nIn the `move_base` node parameters:\n\n```yaml\nmove_base:\n  # Global planner selection\n  base_global_planner: navfn/NavfnROS\n  # Global planner parameters\n  NavfnROS:\n    visualize_potential: false\n    allow_unknown: true\n    \n  # Local planner selection\n  base_local_planner: dwa_local_planner/DWAPlannerROS\n  # Local planner parameters\n  DWAPlannerROS:\n    max_vel_x: 0.5\n    min_vel_x: 0.0\n    max_vel_theta: 1.0\n```\n\n### Recovery Behavior Configuration\n\n```yaml\nmove_base:\n  recovery_behaviors:\n    - name: conservative_reset\n      type: clear_costmap_recovery/ClearCostmapRecovery\n    - name: rotate_recovery\n      type: rotate_recovery/RotateRecovery\n  \n  # Recovery behavior parameters\n  conservative_reset:\n    reset_distance: 3.0\n  \n  rotate_recovery:\n    sim_granularity: 0.017\n    frequency: 20.0\n```\n\n### Costmap Layer Configuration\n\n```yaml\nglobal_costmap:\n  plugins:\n    - {name: static_layer, type: \"costmap_2d::StaticLayer\"}\n    - {name: obstacle_layer, type: \"costmap_2d::ObstacleLayer\"}\n    - {name: inflation_layer, type: \"costmap_2d::InflationLayer\"}\n  \n  # Layer-specific parameters\n  static_layer:\n    map_topic: map\n    track_unknown_space: true\n  \n  obstacle_layer:\n    observation_sources: laser_scan_sensor\n    laser_scan_sensor: {sensor_frame: base_laser, data_type: LaserScan, topic: scan, marking: true, clearing: true}\n  \n  inflation_layer:\n    inflation_radius: 0.55\n    cost_scaling_factor: 10.0\n```\n\n## Summary\n\nThe plugin system in the ROS Navigation Stack provides a flexible architecture for extending and customizing robot navigation capabilities. By leveraging the plugin interfaces, users can:\n\n1. Swap different algorithm implementations without changing the core navigation code\n2. Create custom implementations tailored to specific robot platforms or environments\n3. Configure plugin parameters to tune navigation behavior\n\nThis modular design has contributed significantly to the widespread adoption of the ROS Navigation Stack across diverse robot platforms and applications.\n\nSources: [navfn/src/navfn_ros.cpp](), [dwa_local_planner/src/dwa_planner_ros.cpp](), [nav_core/include/nav_core/base_global_planner.h](), [nav_core/include/nav_core/base_local_planner.h](), [nav_core/include/nav_core/recovery_behavior.h]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"18:T3600,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Costmap2D\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [base_local_planner/package.xml](base_local_planner/package.xml)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [carrot_planner/package.xml](carrot_planner/package.xml)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [clear_costmap_recovery/package.xml](clear_costmap_recovery/package.xml)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/cfg/Costmap2D.cfg](costmap_2d/cfg/Costmap2D.cfg)\n- [costmap_2d/include/costmap_2d/costmap_2d.h](costmap_2d/include/costmap_2d/costmap_2d.h)\n- [costmap_2d/include/costmap_2d/costmap_2d_ros.h](costmap_2d/include/costmap_2d/costmap_2d_ros.h)\n- [costmap_2d/include/costmap_2d/layer.h](costmap_2d/include/costmap_2d/layer.h)\n- [costmap_2d/include/costmap_2d/layered_costmap.h](costmap_2d/include/costmap_2d/layered_costmap.h)\n- [costmap_2d/package.xml](costmap_2d/package.xml)\n- [costmap_2d/src/costmap_2d.cpp](costmap_2d/src/costmap_2d.cpp)\n- [costmap_2d/src/costmap_2d_ros.cpp](costmap_2d/src/costmap_2d_ros.cpp)\n- [costmap_2d/src/layered_costmap.cpp](costmap_2d/src/layered_costmap.cpp)\n- [costmap_2d/test/module_tests.cpp](costmap_2d/test/module_tests.cpp)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [dwa_local_planner/package.xml](dwa_local_planner/package.xml)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_base/package.xml](move_base/package.xml)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [move_slow_and_clear/package.xml](move_slow_and_clear/package.xml)\n- [nav_core/package.xml](nav_core/package.xml)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [navfn/package.xml](navfn/package.xml)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [rotate_recovery/package.xml](rotate_recovery/package.xml)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n- [voxel_grid/include/voxel_grid/voxel_grid.h](voxel_grid/include/voxel_grid/voxel_grid.h)\n- [voxel_grid/package.xml](voxel_grid/package.xml)\n- [voxel_grid/src/voxel_grid.cpp](voxel_grid/src/voxel_grid.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Costmap2D component provides a 2D grid-based representation of the robot's environment, which is essential for collision avoidance and path planning in the ROS navigation stack. It maintains a map where each cell has an associated \"cost\" representing the safety or navigability of that location. For details about ROS wrapper functionality, see [Costmap2DROS](#2.1).\n\n## Purpose and Functionality\n\nCostmap2D manages a two-dimensional grid where each cell contains an unsigned char value representing the cost of traversing that part of the environment. It supports:\n\n- Conversion between world coordinates and map coordinates\n- Assignment of cost values to cells based on obstacles and inflation\n- Efficient handling of bounded map regions\n- Integration with the layered costmap system\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d.h:57-466](). [costmap_2d/src/costmap_2d.cpp:38-488]()\n\n## Architecture Overview\n\n```mermaid\nclassDiagram\n    class Costmap2D {\n        -unsigned char* costmap_\n        -unsigned int size_x_\n        -unsigned int size_y_\n        -double resolution_\n        -double origin_x_\n        -double origin_y_\n        +getCost(x, y)\n        +setCost(x, y, cost)\n        +mapToWorld(mx, my, wx, wy)\n        +worldToMap(wx, wy, mx, my)\n        +resetMap()\n        +resizeMap()\n        +updateOrigin()\n    }\n    \n    class LayeredCostmap {\n        -Costmap2D costmap_\n        -vector~shared_ptr~Layer~~ plugins_\n        +updateMap(robot_x, robot_y, robot_yaw)\n        +setFootprint()\n        +addPlugin()\n    }\n    \n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +initialize()\n        +activate()\n        +deactivate()\n    }\n    \n    class StaticLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class ObstacleLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class InflationLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    class VoxelLayer {\n        +updateBounds()\n        +updateCosts()\n    }\n    \n    LayeredCostmap --* Costmap2D\n    LayeredCostmap --o \"0..*\" Layer\n    \n    Layer \u003c|-- StaticLayer\n    Layer \u003c|-- ObstacleLayer\n    Layer \u003c|-- InflationLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d.h:57-466](). [costmap_2d/include/costmap_2d/layered_costmap.h:38-177](). [costmap_2d/include/costmap_2d/layer.h:37-151]()\n\n## Core Data Structure\n\nThe central data structure in Costmap2D is a 2D grid where each cell contains a cost value. The costs are defined as following:\n\n| Cost Value | Constant | Meaning |\n|------------|----------|---------|\n| 0 | FREE_SPACE | Safe for robot to traverse |\n| 1-252 | Various | Increasing cost, partially safe to traverse |\n| 253 | INSCRIBED_INFLATED_OBSTACLE | Robot inscribed radius touches an obstacle |\n| 254 | LETHAL_OBSTACLE | Obstacle present, cannot traverse |\n| 255 | NO_INFORMATION | Unknown state, no data available |\n\nThe cost values are used by planners to determine safe paths for the robot. Higher costs indicate less preferable areas, with lethal obstacles being completely avoided.\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d.h:115-200](). [costmap_2d/src/costmap_2d.cpp:192-200]()\n\n## Coordinate Systems and Transformations\n\nCostmap2D provides methods to convert between two coordinate systems:\n\n```mermaid\ngraph LR\n    WorldCoords[\"World Coordinates (meters)\"]\n    MapCoords[\"Map Coordinates (cells)\"]\n    \n    WorldCoords -- \"worldToMap(wx, wy, mx, my)\" --\u003e MapCoords\n    MapCoords -- \"mapToWorld(mx, my, wx, wy)\" --\u003e WorldCoords\n```\n\nKey transformation methods include:\n- `worldToMap`: Converts world coordinates (meters) to map cell indices\n- `mapToWorld`: Converts map cell indices to world coordinates\n- `worldToMapNoBounds`: Converts world coordinates without bounds checking\n- `worldToMapEnforceBounds`: Ensures coordinates stay within map bounds\n\nSources: [costmap_2d/src/costmap_2d.cpp:202-258]()\n\n## Memory Management\n\nCostmap2D uses a one-dimensional array to represent the two-dimensional grid for efficiency:\n\n```mermaid\ngraph TD\n    subgraph \"Costmap2D Memory Layout\"\n        A[\"costmap_[0]\"] --- B[\"costmap_[1]\"] --- C[\"...\"] --- D[\"costmap_[size_x_ * size_y_ - 1]\"]\n    end\n    \n    subgraph \"Logical 2D Grid View\"\n        E[\"(0,0)\"] --- F[\"(1,0)\"] --- G[\"...\"] --- H[\"(size_x_-1,0)\"]\n        I[\"(0,1)\"] --- J[\"(1,1)\"] --- K[\"...\"] --- L[\"(size_x_-1,1)\"]\n        M[\"...\"] --- N[\"...\"] --- O[\"...\"] --- P[\"...\"]\n        Q[\"(0,size_y_-1)\"] --- R[\"(1,size_y_-1)\"] --- S[\"...\"] --- T[\"(size_x_-1,size_y_-1)\"]\n    end\n```\n\nThe conversion between 2D coordinates and array indices is handled by:\n- `getIndex(x, y)`: Converts (x, y) coordinates to array index\n- `indexToCells(index, x, y)`: Converts array index to (x, y) coordinates\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d.h:171-186](). [costmap_2d/src/costmap_2d.cpp:65-99]()\n\n## Map Modification and Operations\n\nCostmap2D provides several methods to modify the map:\n\n- `setCost(x, y, cost)`: Sets the cost of a specific cell\n- `resetMap()`: Resets all cells to default value\n- `resetMap(x0, y0, xn, yn)`: Resets a specific region\n- `updateOrigin(new_origin_x, new_origin_y)`: Shifts the map's origin\n- `resizeMap(size_x, size_y, resolution, origin_x, origin_y)`: Changes map dimensions\n- `setConvexPolygonCost(polygon, cost)`: Sets costs for cells within a polygon\n\nThese operations are used to update the costmap based on new sensor data or changes in the environment.\n\nSources: [costmap_2d/src/costmap_2d.cpp:197-200](). [costmap_2d/src/costmap_2d.cpp:87-99](). [costmap_2d/src/costmap_2d.cpp:260-342]()\n\n## Layered Costmap System\n\nThe Costmap2D integrates with the LayeredCostmap system, which manages multiple layers that contribute to the final costmap:\n\n```mermaid\nflowchart TD\n    subgraph \"LayeredCostmap Update Process\"\n        Start[\"Start Update\"] --\u003e ForEach[\"For each layer\"]\n        ForEach --\u003e IfEnabled{\"Is layer enabled?\"}\n        IfEnabled -- \"No\" --\u003e NextLayer[\"Next layer\"]\n        NextLayer --\u003e ForEach\n        \n        IfEnabled -- \"Yes\" --\u003e UpdateBounds[\"Layer.updateBounds()\"]\n        UpdateBounds --\u003e NextLayer\n        \n        ForEach -- \"All layers processed\" --\u003e ResetCostmap[\"Reset costmap in update region\"]\n        ResetCostmap --\u003e LayerUpdate[\"For each layer\"]\n        LayerUpdate --\u003e IfEnabled2{\"Is layer enabled?\"}\n        IfEnabled2 -- \"No\" --\u003e NextLayer2[\"Next layer\"]\n        NextLayer2 --\u003e LayerUpdate\n        \n        IfEnabled2 -- \"Yes\" --\u003e UpdateCosts[\"Layer.updateCosts()\"]\n        UpdateCosts --\u003e NextLayer2\n        \n        LayerUpdate -- \"All layers processed\" --\u003e End[\"Update complete\"]\n    end\n```\n\nDuring update, each layer:\n1. First defines the bounds that need updating (`updateBounds()`)\n2. Then contributes costs to those regions (`updateCosts()`)\n\nSources: [costmap_2d/src/layered_costmap.cpp:95-163](). [costmap_2d/include/costmap_2d/layer.h:64-71]()\n\n## Layer Types\n\nThe layered costmap system supports several types of layers, each providing different functionality:\n\n| Layer Type | Purpose |\n|------------|---------|\n| Static Layer | Incorporates static map data (e.g., from map_server) |\n| Obstacle Layer | Adds dynamic obstacles from sensor data |\n| Inflation Layer | Inflates obstacles to account for robot size |\n| Voxel Layer | Provides 3D obstacle representation using voxel grid |\n\nEach layer implements the Layer interface and contributes costs to the master costmap during the update process.\n\nSources: [costmap_2d/include/costmap_2d/layer.h:37-151](). [costmap_2d/src/layered_costmap.cpp:49-187]()\n\n## Integration with Navigation Stack\n\nCostmap2D serves as the environmental representation for both global and local planners in the ROS navigation stack:\n\n```mermaid\ngraph TD\n    subgraph \"Navigation Stack Integration\"\n        MoveBase[\"move_base\"]\n        GlobalPlanner[\"Global Planner\"]\n        LocalPlanner[\"Local Planner\"]\n        GlobalCostmap[\"Global Costmap\"]\n        LocalCostmap[\"Local Costmap\"]\n        \n        MoveBase --\u003e GlobalPlanner\n        MoveBase --\u003e LocalPlanner\n        \n        GlobalPlanner --\u003e GlobalCostmap\n        LocalPlanner --\u003e LocalCostmap\n        \n        GlobalCostmap --\u003e Costmap2D\n        LocalCostmap --\u003e Costmap2D\n    end\n```\n\nThe global costmap is typically used for long-range path planning, while the local costmap is used for obstacle avoidance and trajectory generation.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:63-170](). [costmap_2d/include/costmap_2d/costmap_2d_ros.h:71-278]()\n\n## Thread Safety and Update Cycle\n\nCostmap2D implements thread safety through mutex locks to protect shared data during concurrent access. The update cycle is managed by the Costmap2DROS class, which:\n\n1. Creates a separate thread for map updates (`mapUpdateLoop`)\n2. Controls update frequency through ROS parameters\n3. Manages the publish cycle for visualization\n4. Provides methods to start, stop, pause, and resume updates\n\nThis ensures that the costmap stays current with the latest sensor data and robot position.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:412-453](). [costmap_2d/src/costmap_2d_ros.cpp:480-531]()\n\n## Robot Footprint Handling\n\nCostmap2D accounts for the robot's shape through footprint management:\n\n```mermaid\ngraph TD\n    subgraph \"Footprint Processing\"\n        FootprintSpec[\"Robot Footprint\\n(set of points)\"]\n        PaddedFootprint[\"Padded Footprint\\n(with safety margin)\"]\n        InflationRadius[\"Calculate Circumscribed\\nand Inscribed Radii\"]\n        LayerNotification[\"Notify Layers of\\nFootprint Change\"]\n        \n        FootprintSpec --\u003e PaddedFootprint\n        PaddedFootprint --\u003e InflationRadius\n        InflationRadius --\u003e LayerNotification\n    end\n```\n\nThe footprint is used to:\n- Determine which areas are traversable\n- Calculate inflation radii for obstacle expansion\n- Generate oriented footprints for collision checking\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:390-397](). [costmap_2d/src/layered_costmap.cpp:177-187]()\n\n## Configuration and Parameters\n\nCostmap2D is configured through ROS parameters, which can be set in launch files or dynamically reconfigured. Key parameters include:\n\n| Parameter | Description |\n|-----------|-------------|\n| width, height | Map dimensions in meters |\n| resolution | Size of each cell in meters |\n| origin_x, origin_y | Origin coordinates |\n| update_frequency | How often the map is updated |\n| publish_frequency | How often the map is published |\n| footprint | Robot footprint as list of points |\n| robot_radius | Radius for circular robots |\n| transform_tolerance | Allowed delay in transform data |\n\nDynamic reconfiguration allows changing these parameters at runtime without restarting nodes.\n\nSources: [costmap_2d/cfg/Costmap2D.cfg:1-23](). [costmap_2d/src/costmap_2d_ros.cpp:311-356]()\n\n## Example Usage\n\nThe Costmap2D class is typically used through the Costmap2DROS wrapper, which handles ROS integration. Global and local planners request costmap information to plan paths and avoid obstacles.\n\nTypical usage pattern:\n1. Create an instance of Costmap2DROS\n2. Configure with appropriate parameters\n3. Start the update cycle\n4. Query cost information for planning and navigation\n5. Stop or pause when done\n\nCommon tasks include checking if cells are obstacles, finding free space, and ensuring paths are collision-free.\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d_ros.h:71-278](). [costmap_2d/src/costmap_2d_ros.cpp:63-170]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"19:T311e,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Costmap2DROS\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/cfg/Costmap2D.cfg](costmap_2d/cfg/Costmap2D.cfg)\n- [costmap_2d/include/costmap_2d/costmap_2d.h](costmap_2d/include/costmap_2d/costmap_2d.h)\n- [costmap_2d/include/costmap_2d/costmap_2d_publisher.h](costmap_2d/include/costmap_2d/costmap_2d_publisher.h)\n- [costmap_2d/include/costmap_2d/costmap_2d_ros.h](costmap_2d/include/costmap_2d/costmap_2d_ros.h)\n- [costmap_2d/src/costmap_2d.cpp](costmap_2d/src/costmap_2d.cpp)\n- [costmap_2d/src/costmap_2d_publisher.cpp](costmap_2d/src/costmap_2d_publisher.cpp)\n- [costmap_2d/src/costmap_2d_ros.cpp](costmap_2d/src/costmap_2d_ros.cpp)\n- [costmap_2d/test/module_tests.cpp](costmap_2d/test/module_tests.cpp)\n- [fake_localization/fake_localization.cpp](fake_localization/fake_localization.cpp)\n- [navfn/src/navfn_node.cpp](navfn/src/navfn_node.cpp)\n- [voxel_grid/include/voxel_grid/voxel_grid.h](voxel_grid/include/voxel_grid/voxel_grid.h)\n- [voxel_grid/src/voxel_grid.cpp](voxel_grid/src/voxel_grid.cpp)\n\n\u003c/details\u003e\n\n\n\nCostmap2DROS serves as the ROS wrapper for the 2D costmap system in the ROS navigation stack. It provides the interface between ROS and the core costmap functionality, handling topics, parameters, and transformations required for costmaps to function within a ROS environment.\n\nFor information about the underlying costmap representation, see [Costmap2D](#2). For details about the layered architecture used in the costmap, see [LayeredCostmap](#2.2).\n\n## Overview\n\nThe Costmap2DROS class acts as a bridge between ROS and the core costmap data structure. Its primary responsibilities include:\n\n- Managing the lifecycle of the underlying layered costmap\n- Loading and configuring plugins (layers) through ROS parameters\n- Handling the robot's footprint representation and transformations\n- Publishing costmap data for visualization and debugging\n- Providing methods to control costmap updates (start/stop/pause/resume)\n- Managing coordinate transformations between map and robot frames\n\n## Architecture\n\nCostmap2DROS integrates multiple components to create a complete environment representation system:\n\n```mermaid\nclassDiagram\n    class Costmap2DROS {\n        +initialize()\n        +updateMap()\n        +start()/stop()\n        +pause()/resume()\n        +getRobotPose()\n        +getLayeredCostmap()\n        +getCostmap()\n        +getOrientedFootprint()\n    }\n    \n    class LayeredCostmap {\n        +updateMap()\n        +resizeMap()\n        +addPlugin()\n        +getPlugins()\n    }\n    \n    class Costmap2D {\n        +getCost()/setCost()\n        +worldToMap()/mapToWorld()\n        +resizeMap()\n        +resetMap()\n    }\n    \n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize()\n        +updateBounds()\n        +updateCosts()\n        +activate()/deactivate()\n    }\n    \n    class Costmap2DPublisher {\n        +publishCostmap()\n        +updateBounds()\n    }\n    \n    class TF2_Buffer {\n        +lookupTransform()\n        +canTransform()\n    }\n    \n    Costmap2DROS \"1\" --\u003e \"1\" LayeredCostmap : contains\n    Costmap2DROS \"1\" --\u003e \"1\" Costmap2DPublisher : publishes via\n    Costmap2DROS \"1\" --\u003e \"1\" TF2_Buffer : uses\n    LayeredCostmap \"1\" --\u003e \"1\" Costmap2D : contains\n    LayeredCostmap \"1\" --\u003e \"many\" Layer : manages\n```\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d_ros.h:73-278](), [costmap_2d/src/costmap_2d_ros.cpp:64-110]()\n\n## Initialization Process\n\nWhen a Costmap2DROS instance is created, it follows this initialization sequence:\n\n```mermaid\nsequenceDiagram\n    participant Node as ROS Node\n    participant CROS as Costmap2DROS\n    participant LC as LayeredCostmap\n    participant TF as TF System\n    participant Plugins as Plugins (Layers)\n    \n    Node-\u003e\u003eCROS: Constructor(name, tf_buffer)\n    CROS-\u003e\u003eCROS: Load global/robot frame parameters\n    CROS-\u003e\u003eTF: Wait for transform availability\n    CROS-\u003e\u003eLC: Create LayeredCostmap\n    alt has \"plugins\" parameter\n        CROS-\u003e\u003ePlugins: Load via pluginlib\n        loop for each plugin\n            CROS-\u003e\u003eCROS: copyParentParameters()\n            CROS-\u003e\u003ePlugins: initialize()\n            LC-\u003e\u003ePlugins: addPlugin()\n        end\n    else\n        CROS-\u003e\u003eCROS: loadOldParameters() (pre-Hydro compatibility)\n    end\n    CROS-\u003e\u003eCROS: Initialize footprint\n    CROS-\u003e\u003eCROS: Create publisher\n    CROS-\u003e\u003eCROS: Set up dynamic_reconfigure server\n```\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:64-169]()\n\n## Configuration\n\nCostmap2DROS is configured via ROS parameters and dynamic reconfiguration. Key parameters include:\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| global_frame | string | Frame ID for the global coordinate system |\n| robot_base_frame | string | Frame ID for the robot's base |\n| transform_tolerance | double | Acceptable delay in transform data (seconds) |\n| update_frequency | double | How often the costmap is updated (Hz) |\n| publish_frequency | double | How often the costmap is published (Hz) |\n| width, height | int | Map dimensions in cells |\n| resolution | double | Map resolution in meters/cell |\n| origin_x, origin_y | double | Map origin in global coordinates |\n| footprint | string | Robot footprint as a list of points `[[x1,y1],[x2,y2],...]` |\n| robot_radius | double | Alternative to footprint for circular robots |\n| footprint_padding | double | Additional padding around the robot footprint |\n| plugins | list | List of costmap layers to load and use |\n\nSources: [costmap_2d/cfg/Costmap2D.cfg:1-23](), [costmap_2d/src/costmap_2d_ros.cpp:311-351]()\n\n### Plugin Configuration\n\nPlugins (layers) are configured via the `plugins` parameter, which is a list of dictionaries, each containing:\n\n```yaml\nplugins:\n  - name: \"static_layer\"\n    type: \"costmap_2d::StaticLayer\"\n  - name: \"obstacle_layer\"\n    type: \"costmap_2d::ObstacleLayer\"\n  - name: \"inflation_layer\"\n    type: \"costmap_2d::InflationLayer\"\n```\n\nEach plugin has its own namespace (`~/\u003ccostmap_name\u003e/\u003cplugin_name\u003e`) for parameters.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:121-137]()\n\n## Map Update Lifecycle\n\nCostmap2DROS manages the update lifecycle through a dedicated update thread and several control methods:\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Initialized: Constructor\n    Initialized --\u003e Running: start()\n    Running --\u003e Stopped: stop()\n    Running --\u003e Paused: pause()\n    Paused --\u003e Running: resume()\n    Stopped --\u003e Running: start()\n    Running --\u003e [*]: Destructor\n    Stopped --\u003e [*]: Destructor\n    Paused --\u003e [*]: Destructor\n    \n    state Running {\n        [*] --\u003e UpdateLoop\n        UpdateLoop --\u003e GetRobotPose: mapUpdateLoop()\n        GetRobotPose --\u003e UpdateMap: if pose obtained\n        UpdateMap --\u003e PublishMap: if time to publish\n        PublishMap --\u003e UpdateLoop\n        GetRobotPose --\u003e UpdateLoop: if pose failed\n    }\n```\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:412-452](), [costmap_2d/src/costmap_2d_ros.cpp:455-478](), [costmap_2d/src/costmap_2d_ros.cpp:480-531]()\n\n### Control Methods\n\nCostmap2DROS provides several methods to control its operation:\n\n- **start()**: Activates all layers and begins costmap updates\n- **stop()**: Deactivates all layers and stops costmap updates\n- **pause()**: Temporarily pauses costmap updates without deactivating layers\n- **resume()**: Resumes costmap updates after pausing\n- **updateMap()**: Manually triggers a map update (used internally by the update thread)\n- **resetLayers()**: Resets all layers to their initial state\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:480-544]()\n\n## Robot Footprint Handling\n\nCostmap2DROS manages the robot's footprint, which is used for collision checking and inflation:\n\n```mermaid\nflowchart TD\n    subgraph \"Footprint Sources\"\n        FP1[\"ROS Parameter: footprint\"]\n        FP2[\"ROS Parameter: robot_radius\"]\n        FP3[\"footprint Topic Subscription\"]\n        FP4[\"Dynamic Reconfigure\"]\n    end\n    \n    subgraph \"Internal Representation\"\n        UFP[\"unpadded_footprint_\"]\n        PFP[\"padded_footprint_\"]\n    end\n    \n    subgraph \"Usage\"\n        LC[\"LayeredCostmap::setFootprint()\"]\n        TP[\"transformFootprint()\"]\n        OF[\"getOrientedFootprint()\"]\n        FPub[\"footprint_pub_\"]\n    end\n    \n    FP1 --\u003e |\"makeFootprintFromParams()\"| UFP\n    FP2 --\u003e |\"makeFootprintFromRadius()\"| UFP\n    FP3 --\u003e |\"setUnpaddedRobotFootprintPolygon()\"| UFP\n    FP4 --\u003e |\"readFootprintFromConfig()\"| UFP\n    \n    UFP --\u003e |\"padFootprint()\"| PFP\n    PFP --\u003e LC\n    PFP --\u003e |\"with robot pose\"| TP\n    TP --\u003e FPub\n    PFP --\u003e |\"with robot pose\"| OF\n```\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:172-175](), [costmap_2d/src/costmap_2d_ros.cpp:358-390](), [costmap_2d/src/costmap_2d_ros.cpp:597-606]()\n\n## Coordinate Transforms\n\nCostmap2DROS handles coordinate transformations between the global frame and robot frame:\n\n### Robot Pose Lookup\n\nThe `getRobotPose()` method retrieves the robot's current pose in the global frame:\n\n```mermaid\nflowchart TD\n    getRobotPose --\u003e canTransform{\"Can transform\\ncurrent time?\"}\n    canTransform --\u003e|Yes| lookupTransform[\"lookupTransform(global_frame,\\nrobot_base_frame, current_time)\"]\n    canTransform --\u003e|No| transform[\"transform(robot_pose,\\nglobal_pose, global_frame)\"]\n    lookupTransform --\u003e doTransform[\"tf2::doTransform(robot_pose,\\nglobal_pose, transform)\"]\n    transform --\u003e checkTimeout{\"Timeout\\nexceeded?\"}\n    doTransform --\u003e checkTimeout\n    checkTimeout --\u003e|Yes| returnFalse[Return false]\n    checkTimeout --\u003e|No| returnTrue[Return true]\n```\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:546-595]()\n\n## Publisher\n\nCostmap2DROS uses the Costmap2DPublisher class to publish costmap data as ROS messages:\n\n- **Costmap**: Published as a `nav_msgs/OccupancyGrid` message\n- **Costmap Updates**: Published as `map_msgs/OccupancyGridUpdate` messages for efficiency\n\nThe publisher can be configured to:\n- Send the full costmap on every update\n- Send incremental updates for changed areas only\n\nSources: [costmap_2d/include/costmap_2d/costmap_2d_publisher.h:51-106](), [costmap_2d/src/costmap_2d_publisher.cpp:47-169]()\n\n## Usage Example\n\nExample of creating and using a Costmap2DROS instance:\n\n```cpp\n#include \u003ccostmap_2d/costmap_2d_ros.h\u003e\n#include \u003ctf2_ros/transform_listener.h\u003e\n\nint main(int argc, char** argv) {\n    ros::init(argc, argv, \"costmap_node\");\n    \n    // Create TF buffer and listener\n    tf2_ros::Buffer buffer;\n    tf2_ros::TransformListener tf(buffer);\n    \n    // Create the costmap\n    costmap_2d::Costmap2DROS costmap(\"my_costmap\", buffer);\n    \n    // Start costmap updates\n    costmap.start();\n    \n    // Get access to the underlying costmap\n    costmap_2d::Costmap2D* costmap_2d = costmap.getCostmap();\n    \n    ros::spin();\n    return 0;\n}\n```\n\nSources: [navfn/src/navfn_node.cpp:102-114](), [fake_localization/fake_localization.cpp:96-102]()\n\n## Integration with Navigation Stack\n\nCostmap2DROS plays a central role in the ROS navigation stack:\n\n```mermaid\nflowchart TD\n    subgraph \"move_base\"\n        MB[\"move_base node\"]\n    end\n    \n    subgraph \"Global Planning\"\n        GP[\"Global Planners\"]\n        NF[\"navfn\"]\n        GPL[\"global_planner\"]\n    end\n    \n    subgraph \"Local Planning\"\n        LP[\"Local Planners\"]\n        BLP[\"base_local_planner\"]\n        DWA[\"dwa_local_planner\"]\n    end\n    \n    subgraph \"Environment Representation\"\n        GC[\"Global Costmap (Costmap2DROS)\"]\n        LC[\"Local Costmap (Costmap2DROS)\"]\n        \n        subgraph \"Layers\"\n            SL[\"Static Layer\"]\n            OL[\"Obstacle Layer\"]\n            IL[\"Inflation Layer\"]\n            VL[\"Voxel Layer\"]\n        end\n    end\n    \n    MB --\u003e GP\n    MB --\u003e LP\n    GP --\u003e GC\n    LP --\u003e LC\n    GC --\u003e SL\n    GC --\u003e OL\n    GC --\u003e IL\n    LC --\u003e OL\n    LC --\u003e IL\n    LC --\u003e VL\n```\n\nSources: [navfn/src/navfn_node.cpp:109-111]()\n\n## Common Issues and Troubleshooting\n\n1. **Transform Errors**: \n   - Ensure the global_frame and robot_base_frame are published correctly\n   - Check if the transform_tolerance is large enough for your system\n\n2. **Performance Issues**:\n   - Adjust update_frequency and publish_frequency to balance CPU load and responsiveness\n   - Consider making the costmap smaller or using a lower resolution\n\n3. **Obstacle Detection Problems**:\n   - Verify that sensor data is properly configured in the obstacle layers\n   - Check obstacle_range and raytrace_range parameters\n\n4. **Visualization**:\n   - Use RViz to visualize the costmap as a Map display\n   - Enable always_send_full_costmap if visualization is choppy\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:91-104](), [costmap_2d/src/costmap_2d_ros.cpp:572-591]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1a:T3657,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# LayeredCostmap\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/cfg/Costmap2D.cfg](costmap_2d/cfg/Costmap2D.cfg)\n- [costmap_2d/include/costmap_2d/costmap_2d.h](costmap_2d/include/costmap_2d/costmap_2d.h)\n- [costmap_2d/include/costmap_2d/costmap_2d_ros.h](costmap_2d/include/costmap_2d/costmap_2d_ros.h)\n- [costmap_2d/include/costmap_2d/layer.h](costmap_2d/include/costmap_2d/layer.h)\n- [costmap_2d/include/costmap_2d/layered_costmap.h](costmap_2d/include/costmap_2d/layered_costmap.h)\n- [costmap_2d/src/costmap_2d.cpp](costmap_2d/src/costmap_2d.cpp)\n- [costmap_2d/src/costmap_2d_ros.cpp](costmap_2d/src/costmap_2d_ros.cpp)\n- [costmap_2d/src/layered_costmap.cpp](costmap_2d/src/layered_costmap.cpp)\n- [costmap_2d/test/module_tests.cpp](costmap_2d/test/module_tests.cpp)\n- [voxel_grid/include/voxel_grid/voxel_grid.h](voxel_grid/include/voxel_grid/voxel_grid.h)\n- [voxel_grid/src/voxel_grid.cpp](voxel_grid/src/voxel_grid.cpp)\n\n\u003c/details\u003e\n\n\n\nThe LayeredCostmap is a core component of the ROS Navigation Stack's costmap system. It provides a framework for maintaining and combining multiple sources of environmental information into a single unified costmap for robot navigation.\n\nThis page explains the architecture and functionality of the LayeredCostmap system, how it manages different types of environmental data, and how it integrates with the rest of the navigation stack. For information about the ROS wrapper that manages the LayeredCostmap, see [Costmap2DROS](#2.1).\n\n## Purpose and Role\n\nLayeredCostmap serves as a hierarchical environmental representation system that:\n\n- Manages a collection of environment information \"layers\" as plugins\n- Combines data from these layers into a unified Costmap2D\n- Coordinates the update process across all layers\n- Handles the robot's footprint representation\n- Provides a clean interface for costmap consumers like path planners\n\nBy using a layered architecture, the system can efficiently handle different types of information (static maps, sensor data, inflation zones) while maintaining a single consistent representation for navigation decision-making.\n\nSources: [costmap_2d/include/costmap_2d/layered_costmap.h:55-173]()\n\n## Architecture Overview\n\n### Class Relationships\n\n```mermaid\nclassDiagram\n    class LayeredCostmap {\n        -Costmap2D costmap_\n        -vector plugins_\n        -bool rolling_window_\n        -bool initialized_\n        -vector footprint_\n        +updateMap(robot_x, robot_y, robot_yaw)\n        +addPlugin(plugin)\n        +setFootprint(footprint)\n        +getCostmap()\n        +getPlugins()\n    }\n    \n    class Costmap2D {\n        -unsigned int size_x_\n        -unsigned int size_y_\n        -double resolution_\n        -unsigned char* costmap_\n        +getCost(mx, my)\n        +setCost(mx, my, cost)\n        +resetMap(x0, y0, xn, yn)\n    }\n    \n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        #LayeredCostmap* layered_costmap_\n        #bool current_\n        #bool enabled_\n        +updateBounds(robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y)\n        +updateCosts(master_grid, min_i, min_j, max_i, max_j)\n        +onFootprintChanged()\n    }\n    \n    class Costmap2DROS {\n        -LayeredCostmap* layered_costmap_\n        -boost::thread* map_update_thread_\n        +getLayeredCostmap()\n        +updateMap()\n    }\n    \n    class StaticLayer\n    class ObstacleLayer\n    class InflationLayer\n    class VoxelLayer\n    \n    Costmap2DROS *-- LayeredCostmap : creates and manages\n    LayeredCostmap *-- Costmap2D : contains\n    LayeredCostmap o-- \"1..*\" Layer : manages plugins\n    \n    Layer \u003c|-- StaticLayer\n    Layer \u003c|-- ObstacleLayer\n    Layer \u003c|-- InflationLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nThe diagram shows how LayeredCostmap serves as the central component that coordinates various layers and maintains the master costmap used by navigation algorithms.\n\nSources: [costmap_2d/include/costmap_2d/layered_costmap.h:55-173](), [costmap_2d/include/costmap_2d/layer.h:49-147]()\n\n### Data Flow\n\n```mermaid\nflowchart TD\n    subgraph \"Input Sources\"\n        SM[\"Static Map Data\"]\n        LS[\"Laser Scans\"]\n        PC[\"Point Clouds\"]\n        ODOM[\"Odometry\"]\n    end\n\n    subgraph \"Layer Plugins\"\n        SL[\"StaticLayer\"]\n        OL[\"ObstacleLayer\"]\n        VL[\"VoxelLayer\"]\n        IL[\"InflationLayer\"]\n    end\n\n    subgraph \"LayeredCostmap\"\n        MCM[\"Master Costmap (Costmap2D)\"]\n        UPD[\"Update Process\"]\n    end\n\n    subgraph \"Consumers\"\n        GP[\"Global Planner\"]\n        LP[\"Local Planner\"]\n        RB[\"Recovery Behaviors\"]\n    end\n\n    SM --\u003e SL\n    LS --\u003e OL\n    PC --\u003e OL\n    PC --\u003e VL\n    ODOM --\u003e UPD\n\n    SL --\u003e UPD\n    OL --\u003e UPD\n    VL --\u003e UPD\n    \n    UPD --\u003e MCM\n    MCM --\u003e IL\n    IL --\u003e MCM\n\n    MCM --\u003e GP\n    MCM --\u003e LP\n    MCM --\u003e RB\n```\n\nThis diagram shows how data flows from various inputs through the layers and ultimately to the master costmap which is used by planning components.\n\nSources: [costmap_2d/src/layered_costmap.cpp:95-163]()\n\n## Core Components\n\n### LayeredCostmap Class\n\nThe `LayeredCostmap` class is the central component that:\n\n1. Manages a collection of Layer plugins via a vector of shared pointers\n2. Contains a master `Costmap2D` instance that stores the combined environmental data\n3. Coordinates the update process across all layers\n4. Maintains the robot's footprint and related calculations\n\nKey attributes:\n- `costmap_`: The underlying Costmap2D that holds the combined data\n- `plugins_`: Vector of Layer plugin instances\n- `global_frame_`: Coordinate frame for the costmap\n- `rolling_window_`: Whether the map follows the robot or stays fixed\n- `footprint_`: Robot's footprint as a vector of points\n- `circumscribed_radius_` and `inscribed_radius_`: Derived from the footprint\n\nKey methods:\n- `updateMap(double robot_x, double robot_y, double robot_yaw)`: The main update method\n- `addPlugin(boost::shared_ptr\u003cLayer\u003e plugin)`: Adds a new layer to the system\n- `setFootprint(const std::vector\u003cgeometry_msgs::Point\u003e\u0026 footprint)`: Updates the robot's footprint\n\nSources: [costmap_2d/include/costmap_2d/layered_costmap.h:55-173](), [costmap_2d/src/layered_costmap.cpp:50-187]()\n\n### Layer Interface\n\nThe `Layer` abstract base class defines the interface that all layer implementations must follow:\n\n```\nLayer\n updateBounds() - Determines area needing update\n updateCosts() - Updates master costmap\n activate() - Enables the layer\n deactivate() - Disables the layer\n reset() - Resets layer to initial state\n onFootprintChanged() - Responds to footprint changes\n isCurrent() - Checks if layer has current data\n```\n\nEvery layer plugin must implement this interface to participate in the layered costmap system.\n\nSources: [costmap_2d/include/costmap_2d/layer.h:49-147]()\n\n### Common Layer Types\n\nThe navigation stack includes several standard layer implementations:\n\n| Layer Type | Purpose | Key Features |\n|------------|---------|--------------|\n| StaticLayer | Incorporates static map data | Rarely changes, typically from map_server |\n| ObstacleLayer | Tracks dynamic obstacles | Uses sensor data (laser, point clouds), ray-tracing for clearing |\n| InflationLayer | Expands obstacles | Creates cost gradients around obstacles based on robot size |\n| VoxelLayer | 3D obstacle representation | Extends ObstacleLayer with 3D voxel grid |\n\nEach layer performs its specific function during the update process and contributes its information to the master costmap.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:204-259]()\n\n## Initialization\n\nThe LayeredCostmap initialization process typically happens through `Costmap2DROS`:\n\n```mermaid\nsequenceDiagram\n    participant CROS as Costmap2DROS\n    participant LCM as LayeredCostmap\n    participant PL as PluginLoader\n    participant LP as Layer Plugins\n    \n    CROS-\u003e\u003eLCM: new LayeredCostmap(global_frame, rolling_window, track_unknown)\n    \n    Note over CROS: Read plugin configurations from ROS parameters\n    \n    loop For each plugin in configuration\n        CROS-\u003e\u003ePL: createInstance(plugin_type)\n        PL--\u003e\u003eCROS: plugin instance\n        CROS-\u003e\u003eLCM: addPlugin(plugin)\n        CROS-\u003e\u003eLP: initialize(layered_costmap, name, tf)\n        Note over LP: Layer-specific initialization\n    end\n    \n    CROS-\u003e\u003eCROS: setUnpaddedRobotFootprint(footprint)\n    CROS-\u003e\u003eLCM: setFootprint(padded_footprint_)\n```\n\nThis sequence shows how `Costmap2DROS` creates and configures a `LayeredCostmap` with the appropriate plugins based on ROS parameters.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:64-187]()\n\n## Update Process\n\nThe update process is the core functionality of the LayeredCostmap system:\n\n```mermaid\nsequenceDiagram\n    participant LCM as LayeredCostmap\n    participant Layers as Layer Plugins\n    participant MCM as Master Costmap\n    \n    Note over LCM: updateMap(robot_x, robot_y, robot_yaw)\n    \n    alt If rolling window\n        LCM-\u003e\u003eMCM: updateOrigin(new_origin_x, new_origin_y)\n    end\n    \n    LCM-\u003e\u003eLCM: Initialize bounds (minx_, miny_, maxx_, maxy_)\n    \n    loop For each enabled plugin\n        LCM-\u003e\u003eLayers: updateBounds(robot_x, robot_y, robot_yaw, \u0026minx_, \u0026miny_, \u0026maxx_, \u0026maxy_)\n        Note over Layers: Plugin updates bounds based on its data\n    end\n    \n    LCM-\u003e\u003eLCM: Convert world bounds to map coordinates\n    LCM-\u003e\u003eMCM: resetMap(x0, y0, xn, yn)\n    \n    loop For each enabled plugin\n        LCM-\u003e\u003eLayers: updateCosts(costmap_, x0, y0, xn, yn)\n        Note over Layers: Plugin writes its costs to master costmap\n    end\n    \n    LCM-\u003e\u003eLCM: Set initialized_ = true\n```\n\nThe update process follows a two-phase approach:\n1. First, determine the bounds that need updating across all layers\n2. Then, update only that area of the master costmap with data from each layer\n\nThis approach minimizes computation by focusing only on areas that have changed.\n\nSources: [costmap_2d/src/layered_costmap.cpp:95-163]()\n\n## Footprint Handling\n\nThe robot's footprint is an important concept in costmap operations:\n\n```mermaid\nflowchart TD\n    FP[\"Robot Footprint\\n(vector of points)\"]\n    CR[\"circumscribed_radius_\\n(smallest circle containing footprint)\"]\n    IR[\"inscribed_radius_\\n(largest circle inside footprint)\"]\n    NL[\"Layer Notifications\\nonFootprintChanged()\"]\n    \n    FP --\u003e LCM[\"LayeredCostmap::setFootprint()\"]\n    LCM --\u003e CR\n    LCM --\u003e IR\n    LCM --\u003e NL\n    \n    CR --\u003e IL[\"InflationLayer\\n(inflation radius)\"]\n    IR --\u003e COL[\"Collision Checking\"]\n```\n\nWhen `setFootprint()` is called:\n1. The footprint is stored as a vector of points\n2. Inscribed and circumscribed radii are calculated\n3. All layers are notified via `onFootprintChanged()`\n\nThis allows layers (especially the inflation layer) to adjust their operations based on the robot's shape.\n\nSources: [costmap_2d/src/layered_costmap.cpp:177-187]()\n\n## Plugin Management\n\nLayeredCostmap implements a plugin architecture using the ROS pluginlib system:\n\n1. Plugins are loaded based on their type string (e.g., \"costmap_2d::StaticLayer\")\n2. Each plugin is initialized with a reference to its parent LayeredCostmap\n3. Plugins can be enabled/disabled dynamically\n4. The enabled status of plugins is checked during the update process\n\nThis architecture allows users to easily configure which layers are active and what parameters they use.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:123-136]()\n\n## Configuration Example\n\nThe LayeredCostmap is typically configured through ROS parameters. A typical configuration might look like:\n\n```yaml\ncostmap:\n  global_frame: map\n  robot_base_frame: base_link\n  update_frequency: 5.0\n  plugins:\n    - {name: static_layer, type: \"costmap_2d::StaticLayer\"}\n    - {name: obstacle_layer, type: \"costmap_2d::ObstacleLayer\"}\n    - {name: inflation_layer, type: \"costmap_2d::InflationLayer\"}\n  \n  static_layer:\n    map_topic: /map\n    track_unknown_space: false\n  \n  obstacle_layer:\n    observation_sources: laser_scan_sensor\n    laser_scan_sensor: {sensor_frame: base_laser, data_type: LaserScan, topic: scan, marking: true, clearing: true}\n  \n  inflation_layer:\n    inflation_radius: 0.55\n    cost_scaling_factor: 10.0\n```\n\nThis configuration would create a LayeredCostmap with three layers, each with its own parameters.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:114-137]()\n\n## Integration with Navigation Stack\n\nLayeredCostmap is a central component in the ROS Navigation Stack:\n\n```mermaid\nflowchart TD\n    subgraph \"Navigation Stack\"\n        MB[\"move_base\\nMain Node\"]\n        GCOS[\"global_costmap\\nCostmap2DROS\"]\n        LCOS[\"local_costmap\\nCostmap2DROS\"]\n        GP[\"Global Planner\"]\n        LP[\"Local Planner\"]\n    end\n    \n    MB --\u003e GCOS\n    MB --\u003e LCOS\n    \n    GCOS --\u003e GLCM[\"global LayeredCostmap\"]\n    LCOS --\u003e LLCM[\"local LayeredCostmap\"]\n    \n    GLCM --\u003e GSL[\"Static Layer\"]\n    GLCM --\u003e GOL[\"Obstacle Layer\"]\n    GLCM --\u003e GIL[\"Inflation Layer\"]\n    \n    LLCM --\u003e LOL[\"Obstacle Layer\"]\n    LLCM --\u003e LIL[\"Inflation Layer\"]\n    \n    GLCM --\u003e GP\n    LLCM --\u003e LP\n    \n    GP --\u003e MB\n    LP --\u003e MB\n```\n\nTypically, the navigation stack uses two separate LayeredCostmap instances:\n1. A global costmap (often with static map) for long-range planning\n2. A local costmap (often with rolling window) for local obstacle avoidance\n\nBoth share the same architecture but may have different configurations and active layers.\n\nSources: [costmap_2d/src/costmap_2d_ros.cpp:64-170]()\n\n## Summary\n\nThe LayeredCostmap provides a flexible and efficient architecture for representing the robot's environment for navigation. By separating different types of environmental information into layers while maintaining a unified interface, it allows the navigation stack to consider various sources of data while keeping the system modular and extensible.\n\nSources: [costmap_2d/include/costmap_2d/layered_costmap.h:55-173](), [costmap_2d/src/layered_costmap.cpp:50-187]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1b:T3c2b,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Costmap Layers\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/layer.h](costmap_2d/include/costmap_2d/layer.h)\n- [costmap_2d/include/costmap_2d/layered_costmap.h](costmap_2d/include/costmap_2d/layered_costmap.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n- [costmap_2d/src/layered_costmap.cpp](costmap_2d/src/layered_costmap.cpp)\n\n\u003c/details\u003e\n\n\n\nThis document provides detailed information about the costmap layer system in the ROS Navigation Stack. Costmap layers provide a modular approach to building environment representations for robot navigation. For information about the overall costmap architecture, see [Costmap2D](#2) and [LayeredCostmap](#2.2).\n\n## Layer Interface and Architecture\n\nThe costmap layer system is built on a plugin-based architecture that allows for extensibility and modularity. Each layer contributes specific information to the master costmap, with layers processed in a specific order.\n\n### Layer Base Class\n\nAll costmap layers inherit from the base `Layer` class, which defines the core interface and functionality.\n\n```mermaid\nclassDiagram\n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds(robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y)\n        +updateCosts(master_grid, min_i, min_j, max_i, max_j)\n        +activate()\n        +deactivate()\n        +reset()\n        +matchSize()\n        +isEnabled()\n        +onFootprintChanged()\n    }\n    \n    Layer \u003c|-- CostmapLayer\n    Layer \u003c|-- InflationLayer\n    \n    CostmapLayer \u003c|-- StaticLayer\n    CostmapLayer \u003c|-- ObstacleLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n    \n    class CostmapLayer {\n        +updateWithTrueOverwrite()\n        +updateWithMax()\n    }\n    \n    class StaticLayer {\n        +incomingMap()\n        +interpretValue()\n    }\n    \n    class ObstacleLayer {\n        +observation_buffers_\n        +raytraceFreespace()\n        +getMarkingObservations()\n        +getClearingObservations()\n    }\n    \n    class VoxelLayer {\n        +voxel_grid_\n        +worldToMap3D()\n        +clearNonLethal()\n    }\n    \n    class InflationLayer {\n        +computeCost()\n        +setInflationParameters()\n        +inflateObstacles()\n    }\n```\n\nSources: [costmap_2d/include/costmap_2d/layer.h:49-147](), [costmap_2d/include/costmap_2d/static_layer.h:53-97](), [costmap_2d/include/costmap_2d/obstacle_layer.h:62-173](), [costmap_2d/include/costmap_2d/voxel_layer.h:61-146](), [costmap_2d/include/costmap_2d/inflation_layer.h:75-196]()\n\n### Update Process\n\nThe layered costmap coordinates the update process across all layers. This sequence ensures each layer contributes to the final costmap in the correct order.\n\n```mermaid\nsequenceDiagram\n    participant LC as \"LayeredCostmap\"\n    participant SL as \"StaticLayer\"\n    participant OL as \"ObstacleLayer\"\n    participant IL as \"InflationLayer\"\n    \n    LC-\u003e\u003eLC: updateMap(robot_x, robot_y, robot_yaw)\n    Note over LC: Reset bounds\n    \n    LC-\u003e\u003eSL: updateBounds(robot_x, robot_y, robot_yaw, \u0026min_x, \u0026min_y, \u0026max_x, \u0026max_y)\n    LC-\u003e\u003eOL: updateBounds(robot_x, robot_y, robot_yaw, \u0026min_x, \u0026min_y, \u0026max_x, \u0026max_y)\n    LC-\u003e\u003eIL: updateBounds(robot_x, robot_y, robot_yaw, \u0026min_x, \u0026min_y, \u0026max_x, \u0026max_y)\n    \n    Note over LC: Convert world bounds to map coordinates\n    LC-\u003e\u003eLC: worldToMapEnforceBounds(minx_, miny_, x0, y0)\n    LC-\u003e\u003eLC: worldToMapEnforceBounds(maxx_, maxy_, xn, yn)\n    \n    LC-\u003e\u003eLC: resetMap(x0, y0, xn, yn)\n    \n    LC-\u003e\u003eSL: updateCosts(costmap_, x0, y0, xn, yn)\n    LC-\u003e\u003eOL: updateCosts(costmap_, x0, y0, xn, yn)\n    LC-\u003e\u003eIL: updateCosts(costmap_, x0, y0, xn, yn)\n    \n    Note over LC: Update successful, set initialized_ = true\n```\n\nSources: [costmap_2d/src/layered_costmap.cpp:95-163]()\n\n## Standard Layer Types\n\nThe navigation stack includes four standard layer types, each fulfilling a specific role in the costmap generation process.\n\n### Static Layer\n\nThe Static Layer incorporates data from a static map, typically loaded from the map server.\n\nKey characteristics:\n- Loads a pregenerated occupancy grid map\n- Can subscribe to map updates\n- Translates occupancy values (0-100) to costmap values\n- Supports \"trinary\" mode (only free, occupied, unknown) or continuous cost values\n\n```mermaid\nflowchart LR\n    A[\"map_server\"] --\u003e|\"nav_msgs/OccupancyGrid\"| B[\"StaticLayer\"]\n    C[\"map_updates\"] --\u003e|\"Optional subscription\"| B\n    B --\u003e|\"interpretValue()\"| D[\"Costmap values\"]\n    \n    subgraph \"Value Translation\"\n        E[\"0-100 occupancy\"]\n        F[\"NO_INFORMATION (255)\"]\n        G[\"FREE_SPACE (0)\"]\n        H[\"LETHAL_OBSTACLE (254)\"]\n        I[\"1-252 (costs)\"]\n    end\n```\n\nSources: [costmap_2d/plugins/static_layer.cpp:62-102](), [costmap_2d/plugins/static_layer.cpp:150-164]()\n\n### Obstacle Layer\n\nThe Obstacle Layer integrates sensor data to detect obstacles in the robot's environment.\n\nKey characteristics:\n- Subscribes to multiple sensor sources (LaserScan, PointCloud, PointCloud2)\n- Maintains observation buffers for each sensor source\n- Marks detected obstacles as lethal in the costmap\n- Clears free space through raytracing\n- Supports clearing around the robot's footprint\n\n```mermaid\nflowchart LR\n    A[\"LaserScan\"] --\u003e|\"transformLaserScanToPointCloud\"| C[\"ObservationBuffer\"]\n    B[\"PointCloud/PointCloud2\"] --\u003e C\n    \n    C --\u003e|\"getMarkingObservations()\"| D[\"ObstacleLayer\"]\n    C --\u003e|\"getClearingObservations()\"| D\n    \n    D --\u003e|\"raytraceFreespace()\"| E[\"Clear cells\"]\n    D --\u003e|\"mark obstacles\"| F[\"Set LETHAL_OBSTACLE\"]\n    \n    G[\"Robot Footprint\"] --\u003e|\"footprint_clearing_enabled_\"| H[\"Clear footprint area\"]\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:57-219](), [costmap_2d/plugins/obstacle_layer.cpp:340-415]()\n\n### Inflation Layer\n\nThe Inflation Layer expands obstacles to account for the robot's size and to provide a gradient of costs around obstacles.\n\nKey characteristics:\n- Inflates lethal obstacles by the inflation radius\n- Creates a cost gradient that decreases with distance from obstacles\n- Uses an exponential decay function for costs\n- Caches distance and cost calculations for efficiency\n- Provides INSCRIBED_INFLATED_OBSTACLE values within the robot's inscribed radius\n\n```mermaid\nflowchart TD\n    A[\"Lethal Obstacles\"] --\u003e|\"enqueue()\"| B[\"Inflation Queue\"]\n    \n    B --\u003e|\"sorted by distance\"| C[\"Process Cells\"]\n    \n    C --\u003e|\"computeCost()\"| D[\"Assign cost value\"]\n    C --\u003e|\"Add neighbors to queue\"| B\n    \n    E[\"InflationLayer Parameters\"]\n    E --\u003e|\"inflation_radius_\"| F[\"Maximum inflation distance\"]\n    E --\u003e|\"cost_scaling_factor\"| G[\"Cost decay rate\"]\n    E --\u003e|\"inscribed_radius_\"| H[\"Robot size consideration\"]\n```\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:176-280](), [costmap_2d/include/costmap_2d/inflation_layer.h:104-119]()\n\n### Voxel Layer\n\nThe Voxel Layer extends the Obstacle Layer to provide 3D obstacle representation.\n\nKey characteristics:\n- Inherits functionality from ObstacleLayer\n- Uses a voxel grid to represent obstacles in 3D\n- Supports z-dimension for obstacles\n- Efficient clearing of 3D space\n- Can publish voxel data for visualization\n\n```mermaid\nflowchart TD\n    A[\"3D Sensor Data\"] --\u003e B[\"VoxelLayer\"]\n    \n    B --\u003e|\"worldToMap3D()\"| C[\"3D Coordinates\"]\n    C --\u003e|\"markVoxelInMap()\"| D[\"Voxel Grid\"]\n    \n    D --\u003e|\"if marked above threshold\"| E[\"Set as LETHAL_OBSTACLE\"]\n    \n    F[\"Clearing Operations\"] --\u003e|\"clearVoxelLineInMap()\"| G[\"Clear 3D ray\"]\n    G --\u003e D\n    \n    subgraph \"Optional Visualization\"\n        D --\u003e|\"publish_voxel_\"| H[\"VoxelGrid message\"]\n    end\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:55-107](), [costmap_2d/plugins/voxel_layer.cpp:116-215]()\n\n## Layer Interaction and Data Flow\n\nThe costmap layers interact in a specific sequence to build the final environment representation.\n\n```mermaid\nflowchart LR\n    subgraph \"Input Data\"\n        A[\"Static Map\"]\n        B[\"Sensor Data\"]\n        C[\"Robot Configuration\"]\n    end\n    \n    subgraph \"Processing Layers\"\n        D[\"StaticLayer\"]\n        E[\"ObstacleLayer/VoxelLayer\"]\n        F[\"InflationLayer\"]\n    end\n    \n    subgraph \"Final Output\"\n        G[\"Costmap2D\"]\n    end\n    \n    A --\u003e D\n    B --\u003e E\n    \n    D --\u003e|\"Base occupancy\"| G\n    E --\u003e|\"Dynamic obstacles\"| G\n    G --\u003e|\"Obstacles to inflate\"| F\n    F --\u003e|\"Inflated obstacles\"| G\n    \n    C --\u003e|\"Footprint\"| D\n    C --\u003e|\"Footprint\"| E\n    C --\u003e|\"Inflation parameters\"| F\n```\n\nSources: [costmap_2d/src/layered_costmap.cpp:95-163]()\n\n### Bounds Management\n\nLayers cooperate to determine which parts of the costmap need updating:\n\n1. Each layer's `updateBounds()` method expands a bounding box to include areas that have changed\n2. The LayeredCostmap converts world coordinates to map coordinates\n3. Only the relevant portion of the costmap is cleared and updated\n4. Layers' `updateCosts()` methods are called only for the bounded region\n\nThis approach significantly improves efficiency by avoiding full costmap updates when only small areas have changed.\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:340-415](), [costmap_2d/plugins/static_layer.cpp:270-292](), [costmap_2d/plugins/inflation_layer.cpp:129-162]()\n\n## Cost Combination Methods\n\nLayers can use different strategies to combine their costs with the master costmap:\n\n| Combination Method | Description | Used By |\n|--------------------|-------------|---------|\n| Overwrite | Simply overwrites existing costs | StaticLayer (configurable) |\n| Maximum | Takes maximum of existing and new cost | StaticLayer (configurable), ObstacleLayer |\n| True Overwrite | Overwrites regardless of existing value | StaticLayer |\n| Special Handling | Custom logic for combining costs | InflationLayer |\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:429-447](), [costmap_2d/plugins/static_layer.cpp:294-346]()\n\n## Layer Configuration\n\nEach layer type has specific configuration parameters that can be adjusted through ROS parameter server or dynamic reconfigure.\n\n### Static Layer Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| enabled | bool | Enable/disable the layer |\n| map_topic | string | Topic for the static map |\n| first_map_only | bool | Use only the first map received |\n| subscribe_to_updates | bool | Subscribe to map updates |\n| track_unknown_space | bool | Preserve unknown areas in the map |\n| use_maximum | bool | Use maximum when combining costs |\n| trinary_costmap | bool | Use only lethal/free/unknown values |\n| lethal_cost_threshold | int | Threshold for lethal obstacle values (0-100) |\n| unknown_cost_value | int | Value to interpret as unknown (-1 default) |\n\nSources: [costmap_2d/plugins/static_layer.cpp:62-102]()\n\n### Obstacle Layer Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| enabled | bool | Enable/disable the layer |\n| footprint_clearing_enabled | bool | Clear the robot footprint |\n| max_obstacle_height | double | Maximum height of obstacles to consider |\n| combination_method | int | Method to combine costs (0=overwrite, 1=maximum) |\n| observation_sources | string | List of sensor sources to use |\n\nFor each observation source:\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| topic | string | Topic name for the sensor |\n| sensor_frame | string | Frame of the sensor |\n| observation_persistence | double | Time to keep observations (seconds) |\n| expected_update_rate | double | Expected frequency of updates |\n| data_type | string | Type of data (LaserScan, PointCloud, PointCloud2) |\n| min_obstacle_height | double | Minimum height for points to be considered |\n| max_obstacle_height | double | Maximum height for points to be considered |\n| obstacle_range | double | Maximum range to mark obstacles |\n| raytrace_range | double | Maximum range to raytrace |\n| inf_is_valid | bool | Whether infinite ranges are valid (LaserScan only) |\n| clearing | bool | Use this source for clearing |\n| marking | bool | Use this source for marking |\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:57-219]()\n\n### Inflation Layer Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| enabled | bool | Enable/disable the layer |\n| inflation_radius | double | Radius to inflate obstacles |\n| cost_scaling_factor | double | Scaling factor for cost decay |\n| inflate_unknown | bool | Whether to inflate unknown space |\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:74-101](), [costmap_2d/plugins/inflation_layer.cpp:369-383]()\n\n### Voxel Layer Parameters\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| enabled | bool | Enable/disable the layer |\n| publish_voxel_map | bool | Publish the voxel grid for visualization |\n| z_voxels | int | Number of voxels in z-dimension |\n| z_resolution | double | Resolution of voxels in z-dimension |\n| origin_z | double | Origin of the voxel grid in z-dimension |\n| unknown_threshold | int | Number of empty voxels before a cell is unknown |\n| mark_threshold | int | Number of marked voxels before a cell is an obstacle |\n\nPlus all parameters from ObstacleLayer.\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:55-93]()\n\n## Layer Update Mechanics\n\nEach layer has specific update mechanics that determine how it contributes to the costmap.\n\n### Static Layer\n- Loads map data from map_server\n- Converts occupancy values to costmap values\n- Provides the baseline map for navigation\n- Can update based on map changes (if configured)\n\nSources: [costmap_2d/plugins/static_layer.cpp:166-244](), [costmap_2d/plugins/static_layer.cpp:270-346]()\n\n### Obstacle Layer\n- Integrates real-time sensor data\n- Marks detected obstacles and clears free space\n- Maintains temporal data with observation buffers\n- Operates in a 2D plane at a configurable height\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:340-415](), [costmap_2d/plugins/obstacle_layer.cpp:465-495]()\n\n### Inflation Layer\n- Processes after obstacle information is incorporated\n- Works by propagating costs outward from lethal obstacles\n- Uses a priority queue sorted by distance from obstacles\n- Creates a gradual cost gradient to guide planning\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:176-280](), [costmap_2d/plugins/inflation_layer.cpp:308-341]()\n\n### Voxel Layer\n- Extends obstacle layer with 3D representation\n- Manages z-dimension information\n- More accurate for complex environments\n- Useful for operating around overhanging obstacles\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:116-215](), [costmap_2d/plugins/voxel_layer.cpp:267-390]()\n\nThe costmap layers system provides a flexible framework for building and maintaining environment representations for robot navigation. Through proper configuration and layer selection, you can tailor the costmap to your specific robot and environment needs."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1c:T2ba7,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Static Layer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n- [map_server/CMakeLists.txt](map_server/CMakeLists.txt)\n- [map_server/include/map_server/image_loader.h](map_server/include/map_server/image_loader.h)\n- [map_server/src/image_loader.cpp](map_server/src/image_loader.cpp)\n- [map_server/src/main.cpp](map_server/src/main.cpp)\n- [map_server/src/map_saver.cpp](map_server/src/map_saver.cpp)\n- [map_server/src/map_server.dox](map_server/src/map_server.dox)\n- [map_server/test/rtest.cpp](map_server/test/rtest.cpp)\n- [map_server/test/rtest.xml](map_server/test/rtest.xml)\n- [map_server/test/spectrum.png](map_server/test/spectrum.png)\n- [map_server/test/test_constants.cpp](map_server/test/test_constants.cpp)\n- [map_server/test/test_constants.h](map_server/test/test_constants.h)\n- [map_server/test/testmap.yaml](map_server/test/testmap.yaml)\n- [map_server/test/testmap2.png](map_server/test/testmap2.png)\n- [map_server/test/testmap2.yaml](map_server/test/testmap2.yaml)\n- [map_server/test/utest.cpp](map_server/test/utest.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Static Layer is a fundamental component of the ROS Navigation Stack's costmap system that incorporates fixed map data into the robot's environment representation. It provides the persistent, unchanging obstacles and free space from pre-generated maps, typically loaded from files by the map server.\n\nFor information about other costmap layers, see:\n- [Obstacle Layer](#2.3.2)\n- [Inflation Layer](#2.3.3)\n- [Voxel Layer](#2.3.4)\n\n## Overview\n\nThe Static Layer loads map data from the ROS map server and integrates this information into the robot's costmap. This layer represents the static environment - walls, corridors, rooms, and other permanent features that don't change over time. \n\n```mermaid\ngraph TD\n    subgraph \"Costmap System\"\n        LC[\"LayeredCostmap\"]\n        SL[\"Static Layer\"]\n        OL[\"Obstacle Layer\"]\n        IL[\"Inflation Layer\"]\n        C2D[\"Costmap2D\"]\n        \n        LC --\u003e C2D\n        LC --\u003e SL\n        LC --\u003e OL\n        LC --\u003e IL\n    end\n    \n    subgraph \"Map Server\"\n        MS[\"map_server\"]\n        YAML[\"Map YAML\"]\n        IMG[\"Map Image\"]\n        \n        MS --\u003e YAML\n        YAML --\u003e IMG\n    end\n    \n    MS --\"map topic\u003cbr\u003e(nav_msgs/OccupancyGrid)\"--\u003e SL\n```\n\nSources: [costmap_2d/plugins/static_layer.cpp:62-91](), [costmap_2d/include/costmap_2d/static_layer.h:53-97]()\n\n## Class Structure\n\nThe Static Layer is implemented as a plugin for the layered costmap framework.\n\n```mermaid\nclassDiagram\n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +onInitialize()\n        +matchSize()\n        +reset()\n    }\n    \n    class CostmapLayer {\n        +updateWithMax()\n        +updateWithOverwrite()\n        +updateWithTrueOverwrite()\n    }\n    \n    class StaticLayer {\n        -map_frame_: string\n        -global_frame_: string\n        -subscribe_to_updates_: bool\n        -map_received_: bool\n        -has_updated_data_: bool\n        -track_unknown_space_: bool\n        -use_maximum_: bool\n        -first_map_only_: bool\n        -trinary_costmap_: bool\n        -lethal_threshold_: unsigned char\n        -unknown_cost_value_: unsigned char\n        +onInitialize()\n        +updateBounds()\n        +updateCosts()\n        +matchSize()\n        +reset()\n        -incomingMap()\n        -incomingUpdate()\n        -interpretValue()\n    }\n    \n    Layer \u003c|-- CostmapLayer\n    CostmapLayer \u003c|-- StaticLayer\n```\n\nSources: [costmap_2d/include/costmap_2d/static_layer.h:53-97](), [costmap_2d/plugins/static_layer.cpp:54-124]()\n\n## Initialization and Configuration\n\nThe Static Layer is initialized with parameters from the ROS parameter server. During initialization, it sets up subscribers to the map topics and waits to receive the initial map data.\n\nKey configuration parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| map_topic | string | \"map\" | Topic name for the static map |\n| first_map_only | bool | false | If true, only use the first map received |\n| subscribe_to_updates | bool | false | Whether to subscribe to map updates |\n| track_unknown_space | bool | true | Track unknown space in the costmap |\n| use_maximum | bool | false | When true, combines layers using maximum, otherwise uses additive |\n| lethal_cost_threshold | int | 100 | Values at or above this threshold are considered lethal obstacles |\n| unknown_cost_value | int | -1 | Value to return for unknown spaces in the map |\n| trinary_costmap | bool | true | When true, uses only free, occupied, or unknown values |\n\nSources: [costmap_2d/plugins/static_layer.cpp:62-124]()\n\n## Operation Process\n\n### Map Loading\n\nThe Static Layer receives map data from the map server, which loads maps from image files (PNG, BMP) and YAML configuration files. This process converts the graphical map into a costmap representation.\n\n```mermaid\nsequenceDiagram\n    participant MS as \"map_server\"\n    participant SL as \"StaticLayer\"\n    participant LC as \"LayeredCostmap\"\n    \n    MS-\u003e\u003eMS: \"Load map from file\"\n    MS-\u003e\u003eSL: \"Publish map (OccupancyGrid)\"\n    SL-\u003e\u003eSL: \"incomingMap()\"\n    SL-\u003e\u003eSL: \"interpretValue()\"\n    SL-\u003e\u003eLC: \"Update costmap with static data\"\n```\n\nSources: [costmap_2d/plugins/static_layer.cpp:166-225](), [map_server/src/main.cpp:138-169]()\n\n### Value Interpretation\n\nThe Static Layer interprets values from the map according to configured thresholds:\n\n```mermaid\nflowchart TD\n    start[\"Map Value\"]\n    trackUnknown{\"Track Unknown?\"}\n    isUnknown{\"Value == unknown_cost_value?\"}\n    isLethal{\"Value \u003e= lethal_threshold?\"}\n    isTrinary{\"Trinary Costmap?\"}\n    scaleValue[\"Scale value between FREE_SPACE and LETHAL_OBSTACLE\"]\n    \n    start --\u003e isUnknown\n    isUnknown -- \"Yes\" --\u003e trackUnknown\n    trackUnknown -- \"Yes\" --\u003e noInfo[\"Return NO_INFORMATION\"]\n    trackUnknown -- \"No\" --\u003e free[\"Return FREE_SPACE\"]\n    isUnknown -- \"No\" --\u003e isLethal\n    isLethal -- \"Yes\" --\u003e lethal[\"Return LETHAL_OBSTACLE\"]\n    isLethal -- \"No\" --\u003e isTrinary\n    isTrinary -- \"Yes\" --\u003e free\n    isTrinary -- \"No\" --\u003e scaleValue\n    scaleValue --\u003e returnValue[\"Return scaled value\"]\n```\n\nSources: [costmap_2d/plugins/static_layer.cpp:150-164]()\n\n### Updating the Costmap\n\nThe Static Layer updates the costmap in two steps:\n\n1. **Update Bounds** - Determines which area of the costmap needs to be updated\n2. **Update Costs** - Adds the static data to the master costmap, using either overwrite or maximum operations\n\n```mermaid\nflowchart TD\n    subgraph \"updateBounds\"\n        checkMap{\"Map received?\"}\n        computeBounds[\"Compute update bounds\"]\n    end\n    \n    subgraph \"updateCosts\"\n        isRolling{\"Rolling window?\"}\n        useMax{\"use_maximum?\"}\n        updateWithOverwrite[\"updateWithTrueOverwrite()\"]\n        updateWithMax[\"updateWithMax()\"]\n        transformAndUpdate[\"Transform coordinates and update cells\"]\n    end\n    \n    checkMap -- \"Yes\" --\u003e computeBounds\n    isRolling -- \"No\" --\u003e useMax\n    useMax -- \"Yes\" --\u003e updateWithMax\n    useMax -- \"No\" --\u003e updateWithOverwrite\n    isRolling -- \"Yes\" --\u003e transformAndUpdate\n```\n\nSources: [costmap_2d/plugins/static_layer.cpp:270-292](), [costmap_2d/plugins/static_layer.cpp:294-346]()\n\n## Rolling vs. Non-Rolling Windows\n\nThe Static Layer behaves differently depending on whether the costmap is configured to use a rolling window:\n\n### Non-Rolling Window\n- The entire static map is loaded into the costmap\n- The costmap size is determined by the map size\n- Map coordinates directly correspond to costmap coordinates\n\n### Rolling Window\n- The costmap moves with the robot\n- Only the portion of the static map that overlaps with the current costmap window is used\n- Requires coordinate transformations between the map frame and the global frame\n\nSources: [costmap_2d/plugins/static_layer.cpp:138-148](), [costmap_2d/plugins/static_layer.cpp:294-346]()\n\n## Integration with Map Server\n\nThe map server is responsible for loading map data from files and providing it to the Static Layer.\n\n### Map Format\n\nMaps are defined by two files:\n1. An image file (PNG, BMP) where:\n   - Black pixels (low values) represent obstacles\n   - White pixels (high values) represent free space\n   - Gray pixels (intermediate values) can represent unknown space\n\n2. A YAML configuration file specifying:\n   - Image file path\n   - Resolution (meters/pixel)\n   - Origin (position and orientation of the map)\n   - Threshold values for interpretation\n\nExample YAML file:\n```yaml\nimage: mymap.png\nresolution: 0.05\norigin: [0.0, 0.0, 0.0]\nnegate: 0\noccupied_thresh: 0.65\nfree_thresh: 0.196\n```\n\nSources: [map_server/src/main.cpp:186-282](), [map_server/test/testmap.yaml]()\n\n## Map Data Processing Flow\n\nThe following diagram shows how map data flows from files to the Static Layer and into the costmap:\n\n```mermaid\nflowchart LR\n    img[\"Image File\\n(.png/.bmp)\"] --\u003e ms[\"map_server\"]\n    yaml[\"YAML Config\"] --\u003e ms\n    ms --\"nav_msgs/OccupancyGrid\"--\u003e sl[\"StaticLayer\"]\n    sl --\"update_bounds()\"--\u003e lc[\"LayeredCostmap\"]\n    sl --\"update_costs()\"--\u003e lc\n    lc --\u003e c2d[\"Costmap2D\"]\n```\n\nSources: [map_server/src/image_loader.cpp:56-163](), [costmap_2d/plugins/static_layer.cpp:166-225]()\n\n## Troubleshooting and Common Issues\n\n### No Map Received\n- Ensure the map server is running and publishing on the correct topic\n- Check if the topic name in the Static Layer configuration matches what the map server is publishing\n- Verify that the map data is being published correctly using `rostopic echo /map`\n\n### Map and Costmap Size Mismatch\n- This can occur if the costmap size parameters don't match the map size\n- The Static Layer will attempt to resize the costmap to match the map if in non-rolling mode\n\n### Coordinate Frame Issues\n- Ensure the map frame and global frame are properly defined in the navigation configuration\n- If using a rolling window, check that transforms between frames are available\n\nSources: [costmap_2d/plugins/static_layer.cpp:294-346]()\n\n## Best Practices\n\n1. **Use Appropriate Resolution**: Choose a map resolution that balances detail and computational efficiency\n2. **Quality Map Data**: Ensure your map image is clean and accurate to avoid navigation issues\n3. **Frame Management**: Keep coordinate frame relationships consistent in your TF tree\n4. **Consider Memory Usage**: Very large maps with high resolution can consume significant memory\n\nSources: [costmap_2d/plugins/static_layer.cpp:172-196]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1d:T3124,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Obstacle Layer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Obstacle Layer is a key component of the ROS Navigation Stack's costmap system, responsible for incorporating sensor data about obstacles into the navigation costmap. This layer processes incoming sensor information from sources like laser scanners and point clouds to dynamically update the costmap with detected obstacles in the robot's environment. \n\nFor information about the 3D extension of this layer, see [Voxel Layer](#2.3.4). For more general information about the layered costmap architecture, see [Layered Costmap](#2.2).\n\n## Overview\n\nThe Obstacle Layer integrates real-time sensor data into the costmap, enabling robots to detect and avoid dynamic obstacles. Unlike the [Static Layer](#2.3.1) which represents permanent environmental features, the Obstacle Layer handles transient obstacles detected by the robot's sensors.\n\n```mermaid\nclassDiagram\n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +activate()\n        +deactivate()\n    }\n    \n    class CostmapLayer {\n        +updateWithOverwrite()\n        +updateWithMax()\n    }\n    \n    class ObstacleLayer {\n        -observation_buffers_\n        -marking_buffers_\n        -clearing_buffers_\n        +updateBounds()\n        +updateCosts()\n        +raytraceFreespace()\n        +getMarkingObservations()\n        +getClearingObservations()\n    }\n    \n    class VoxelLayer {\n        -voxel_grid_\n        +updateBounds()\n        +raytraceFreespace()\n    }\n    \n    Layer \u003c|-- CostmapLayer\n    CostmapLayer \u003c|-- ObstacleLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nSources: [costmap_2d/include/costmap_2d/obstacle_layer.h:62-173](), [costmap_2d/include/costmap_2d/voxel_layer.h:61-146]()\n\n## Working Principles\n\nThe Obstacle Layer processes sensor data through two main operations:\n\n1. **Marking**: Identifying and marking cells occupied by obstacles\n2. **Clearing**: Using raytracing to clear free space between the sensor and detected obstacles\n\n```mermaid\nflowchart TD\n    subgraph \"Sensor Data Processing\"\n        SensorInput[\"Sensor Input\"]\n        SensorInput --\u003e |\"LaserScan\"| LaserCallback[\"laserScanCallback()\"]\n        SensorInput --\u003e |\"PointCloud\"| PCCallback[\"pointCloudCallback()\"]\n        SensorInput --\u003e |\"PointCloud2\"| PC2Callback[\"pointCloud2Callback()\"]\n        \n        LaserCallback --\u003e |\"converts to\\nPointCloud2\"| ObservationBuffer[\"Observation Buffers\"]\n        PCCallback --\u003e ObservationBuffer\n        PC2Callback --\u003e ObservationBuffer\n        \n        ObservationBuffer --\u003e |\"getMarkingObservations()\"| MarkingObs[\"Marking Observations\"]\n        ObservationBuffer --\u003e |\"getClearingObservations()\"| ClearingObs[\"Clearing Observations\"]\n        \n        MarkingObs --\u003e MarkObstacles[\"Mark Obstacles\\non Costmap\"]\n        ClearingObs --\u003e Raytrace[\"Raytrace Freespace\"]\n        \n        MarkObstacles --\u003e UpdateCostmap[\"Update Costmap\"]\n        Raytrace --\u003e UpdateCostmap\n    end\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:242-338](), [costmap_2d/plugins/obstacle_layer.cpp:465-495]()\n\n### Observation Processing\n\nThe Obstacle Layer manages sensor data through observation buffers, which store and filter incoming observations:\n\n1. Each configured sensor source has an observation buffer\n2. Buffers can be designated for marking obstacles, clearing space, or both\n3. Observations have a configurable persistence time and expected update rate\n4. The system tracks whether observations are current based on their timestamps\n\n```mermaid\nclassDiagram\n    class ObservationBuffer {\n        +bufferCloud()\n        +getObservations()\n        +isCurrent()\n    }\n    \n    class Observation {\n        +cloud_\n        +origin_\n        +obstacle_range_\n        +raytrace_range_\n    }\n    \n    class ObstacleLayer {\n        -observation_buffers_\n        -marking_buffers_\n        -clearing_buffers_\n        +getMarkingObservations()\n        +getClearingObservations()\n    }\n    \n    ObstacleLayer --\u003e \"n\" ObservationBuffer : manages\n    ObservationBuffer --\u003e \"0..n\" Observation : contains\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:127-145](), [costmap_2d/plugins/obstacle_layer.cpp:465-495]()\n\n## Main Operations\n\n### Updating Bounds\n\nThe `updateBounds()` method determines the region of the costmap that needs to be updated:\n\n1. Updates the origin if using a rolling window\n2. Gets observations from both marking and clearing buffers\n3. Performs raytracing to clear freespace\n4. Processes observations to mark obstacles\n5. Updates the bounds to encompass all affected areas\n\n```mermaid\nsequenceDiagram\n    participant MB as move_base\n    participant OL as ObstacleLayer\n    participant MB2 as Master Costmap\n    \n    MB-\u003e\u003eOL: updateBounds(robot_x, robot_y, robot_yaw, ...)\n    OL-\u003e\u003eOL: getMarkingObservations()\n    OL-\u003e\u003eOL: getClearingObservations()\n    \n    loop For each clearing observation\n        OL-\u003e\u003eOL: raytraceFreespace()\n    end\n    \n    loop For each marking observation\n        OL-\u003e\u003eOL: Process points \u0026 mark obstacles\n    end\n    \n    OL-\u003e\u003eOL: updateFootprint()\n    OL-\u003e\u003eMB: Return updated bounds\n    \n    MB-\u003e\u003eOL: updateCosts(master_grid, min_i, min_j, max_i, max_j)\n    \n    alt if combination_method = Overwrite\n        OL-\u003e\u003eMB2: updateWithOverwrite()\n    else if combination_method = Maximum\n        OL-\u003e\u003eMB2: updateWithMax()\n    end\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:340-415](), [costmap_2d/plugins/obstacle_layer.cpp:429-447]()\n\n### Raytracing Freespace\n\nA key operation in the Obstacle Layer is raytracing, which clears the space between the sensor origin and detected points:\n\n1. For each point in a clearing observation, trace a line from the sensor origin to the point\n2. Mark all cells along this line as FREE_SPACE\n3. This enables the robot to know which areas are clear of obstacles\n\n```mermaid\nflowchart LR\n    subgraph \"Raytracing Process\"\n        Origin[\"Sensor Origin\"] --\u003e |\"raytrace line\"| Point[\"Detected Point\"]\n        \n        subgraph \"Costmap\"\n            C1[\"Cell (FREE_SPACE)\"]\n            C2[\"Cell (FREE_SPACE)\"]\n            C3[\"Cell (FREE_SPACE)\"]\n            C4[\"Cell (LETHAL_OBSTACLE)\"]\n            \n            C1 --\u003e C2 --\u003e C3 --\u003e C4\n        end\n        \n        Origin -.- C1\n        Point -.- C4\n    end\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:497-578]()\n\n## Configuration\n\nThe Obstacle Layer is highly configurable through ROS parameters and dynamic reconfiguration:\n\n### Observation Sources\n\nYou can configure multiple sensor sources, each with its own parameters:\n\n```\nobservation_sources: scan bump\nscan: {data_type: LaserScan, topic: /scan, marking: true, clearing: true, min_obstacle_height: 0.0, max_obstacle_height: 2.0}\nbump: {data_type: PointCloud2, topic: /bumper_pointcloud, marking: true, clearing: false}\n```\n\nEach source can have the following parameters:\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| topic | The sensor topic name | source name |\n| sensor_frame | Frame of the sensor (if empty, uses sensor frame) | \"\" |\n| observation_persistence | How long observations persist in the buffer (seconds) | 0.0 |\n| expected_update_rate | Expected rate at which data is received (Hz) | 0.0 |\n| data_type | Type of sensor data (LaserScan, PointCloud, PointCloud2) | \"PointCloud\" |\n| min_obstacle_height | Minimum height of obstacles to include (m) | 0.0 |\n| max_obstacle_height | Maximum height of obstacles to include (m) | 2.0 |\n| inf_is_valid | Whether infinite ranges in laser scans should be used | false |\n| clearing | Whether this source should be used for clearing free space | false |\n| marking | Whether this source should be used for marking obstacles | true |\n| obstacle_range | Maximum range to mark obstacles (m) | 2.5 |\n| raytrace_range | Maximum range to raytrace free space (m) | 3.0 |\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:76-206]()\n\n### General Parameters\n\nThe Obstacle Layer also has several general parameters:\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| enabled | Whether the layer is enabled | true |\n| footprint_clearing_enabled | Whether to clear the robot's footprint from the costmap | true |\n| max_obstacle_height | Maximum height of obstacles across all sources (m) | 2.0 |\n| combination_method | How to combine with the master costmap (0: Overwrite, 1: Maximum) | 1 |\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:234-240]()\n\n## Implementation Details\n\n### Marking Obstacles\n\nThe ObstacleLayer processes each point in marking observations:\n\n1. Checks if the point is within height limits\n2. Verifies the point is within the obstacle range\n3. Converts world coordinates to map coordinates\n4. Marks the corresponding cell as LETHAL_OBSTACLE\n5. Updates the affected bounds\n\n```cpp\n// Simplified code for marking obstacles\nfor (observation : marking_observations) {\n  for (each point in observation.cloud) {\n    if (point.z \u003e max_obstacle_height_)\n      continue;\n      \n    if (distance_from_origin \u003e obstacle_range)\n      continue;\n      \n    unsigned int mx, my;\n    if (worldToMap(point.x, point.y, mx, my)) {\n      costmap_[getIndex(mx, my)] = LETHAL_OBSTACLE;\n    }\n  }\n}\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:365-412]()\n\n### Sensor Callbacks\n\nThe ObstacleLayer handles different sensor types through specialized callbacks:\n\n1. **LaserScan**: Converts scans to point clouds using laser_geometry projector\n2. **PointCloud/PointCloud2**: Processes directly or converts as needed\n3. All data is buffered in the appropriate ObservationBuffer\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:242-338]()\n\n### Integration with Move Base\n\nThe ObstacleLayer integrates with the move_base node through the costmap_2d::LayeredCostmap system:\n\n1. move_base loads the ObstacleLayer as a plugin via pluginlib\n2. The LayeredCostmap calls updateBounds() on each layer to determine the update region\n3. It then calls updateCosts() to integrate each layer's data into the master costmap\n4. The combined costmap is used by planners to generate collision-free paths\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:45]()\n\n## Advanced Features\n\n### Footprint Clearing\n\nThe ObstacleLayer can automatically clear the robot's footprint from the costmap:\n\n1. The robot's footprint is transformed based on the current pose\n2. The transformed footprint is used to clear the corresponding area in the costmap\n3. This prevents the robot from thinking it's colliding with itself\n\n```mermaid\nflowchart TD\n    subgraph \"Footprint Clearing\"\n        GetFootprint[\"Get Robot Footprint\"]\n        Transform[\"Transform Based on Robot Pose\"]\n        ClearPolygon[\"Clear Convex Polygon in Costmap\"]\n        \n        GetFootprint --\u003e Transform\n        Transform --\u003e ClearPolygon\n    end\n```\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:417-427](), [costmap_2d/plugins/obstacle_layer.cpp:431-434]()\n\n### Static Observations\n\nFor testing purposes, the ObstacleLayer supports adding static observations:\n\n1. Static observations don't come from sensors but are added programmatically\n2. They can be used for both marking and clearing\n3. This is useful for testing and debugging\n\nSources: [costmap_2d/plugins/obstacle_layer.cpp:449-463]()\n\n## Relationship to Other Layers\n\nThe ObstacleLayer works together with other layers in the costmap system:\n\n1. **Static Layer**: Provides a base map of the environment\n2. **Obstacle Layer**: Adds dynamic obstacle information\n3. **Inflation Layer**: Inflates obstacles to account for robot size\n4. **Voxel Layer**: Extends ObstacleLayer with 3D representation\n\nThese layers are combined using the LayeredCostmap system to create a comprehensive representation of the environment for navigation.\n\nSources: [costmap_2d/include/costmap_2d/obstacle_layer.h:62-63]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1e:T2a6d,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Inflation Layer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Inflation Layer is a critical component of the ROS Navigation Stack's costmap system that expands obstacles to account for the robot's physical dimensions and create a safety buffer for navigation. This page explains how the Inflation Layer works, its configuration parameters, and its role in the layered costmap architecture.\n\nFor information about the overall layered costmap system, see [Costmap Layers](#2.3). For specific details about other layers, see [Static Layer](#2.3.1), [Obstacle Layer](#2.3.2), or [Voxel Layer](#2.3.4).\n\n## Purpose and Function\n\nThe Inflation Layer's primary responsibility is to take obstacles identified by other layers (such as the Static Layer or Obstacle Layer) and expand them by a configurable inflation radius. This expansion is crucial for two reasons:\n\n1. It ensures that the robot's planning systems account for the robot's physical footprint, not just its center point\n2. It creates a graduated cost gradient around obstacles, enabling smoother path planning that keeps the robot at a safe distance from obstacles\n\nWithout inflation, a planner might attempt to place the robot's center exactly at the edge of an obstacle, which would result in a collision since the robot has physical dimensions.\n\nSources: [costmap_2d/include/costmap_2d/inflation_layer.h:73-119](), [costmap_2d/plugins/inflation_layer.cpp:104-118]()\n\n## How the Inflation Layer Works\n\n```mermaid\nflowchart TD\n    subgraph \"Inflation Process\"\n        A[\"Initialize with\u003cbr\u003eLETHAL_OBSTACLE cells\"] --\u003e B[\"Place cells in\u003cbr\u003edistance-sorted queue\"]\n        B --\u003e C[\"Process cells in\u003cbr\u003eincreasing distance order\"]\n        C --\u003e D[\"Assign cost based\u003cbr\u003eon distance formula\"]\n        D --\u003e E[\"Add neighbors to queue\u003cbr\u003ewith appropriate distances\"]\n        E --\u003e |\"For each cell\"| C\n    end\n\n    subgraph \"Cost Assignment\"\n        X[\"If distance = 0\"] --\u003e Y[\"Cost = LETHAL_OBSTACLE\"]\n        X --\u003e Z[\"If distance \u003c= inscribed_radius\"]\n        Z --\u003e W[\"Cost = INSCRIBED_INFLATED_OBSTACLE\"]\n        Z --\u003e V[\"Else\"]\n        V --\u003e U[\"Cost = exponential decay\u003cbr\u003ebased on distance \u0026 weight\"]\n    end\n```\n\nThe inflation algorithm operates by:\n\n1. Identifying all lethal obstacle cells in the relevant area of the costmap\n2. Organizing these cells into a queue sorted by distance from obstacles \n3. Processing cells in order of increasing distance\n4. Assigning costs to cells based on their distance from the nearest obstacle\n5. Adding neighboring cells to the processing queue\n\nThe cost assigned to each cell follows these rules:\n- Cells containing obstacles (distance = 0) receive `LETHAL_OBSTACLE` cost (254)\n- Cells within the inscribed radius receive `INSCRIBED_INFLATED_OBSTACLE` cost (253)\n- Cells beyond the inscribed radius but within the inflation radius receive a cost that decays exponentially with distance\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:176-280](), [costmap_2d/include/costmap_2d/inflation_layer.h:104-119]()\n\n## Core Data Structures\n\n```mermaid\nclassDiagram\n    class InflationLayer {\n        +onInitialize()\n        +updateBounds()\n        +updateCosts()\n        +setInflationParameters()\n        -computeCaches()\n        -enqueue()\n        -inflation_radius_: double\n        -weight_: double\n        -inflate_unknown_: bool\n    }\n    \n    class CellData {\n        +index_: unsigned int\n        +x_: unsigned int\n        +y_: unsigned int\n        +src_x_: unsigned int\n        +src_y_: unsigned int\n    }\n    \n    InflationLayer -- CellData : uses\n    \n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +onInitialize()\n    }\n    \n    Layer \u003c|-- InflationLayer : implements\n```\n\nThe `InflationLayer` class inherits from the `Layer` interface and implements its required methods. It also uses a supporting `CellData` class to track cells during the inflation process.\n\nKey internal data structures:\n- `inflation_cells_`: A map of distance to vector of cells at that distance\n- `cached_costs_`: Precomputed costs based on distance\n- `cached_distances_`: Precomputed distances for efficiency\n- `seen_`: A boolean array to track which cells have been processed\n\nSources: [costmap_2d/include/costmap_2d/inflation_layer.h:54-73](), [costmap_2d/include/costmap_2d/inflation_layer.h:75-196]()\n\n## Inflation Cost Calculation\n\nThe cost of inflated cells is calculated using an exponential decay function:\n\n```\nIf distance == 0:\n    cost = LETHAL_OBSTACLE (254)\nElse if distance \u003c= inscribed_radius:\n    cost = INSCRIBED_INFLATED_OBSTACLE (253)\nElse:\n    factor = exp(-1.0 * weight * (distance - inscribed_radius))\n    cost = (INSCRIBED_INFLATED_OBSTACLE - 1) * factor\n```\n\nWhere:\n- `distance` is the Euclidean distance from the nearest obstacle\n- `inscribed_radius` is the radius of the robot's inscribed circle\n- `weight` is the cost scaling factor (higher values cause faster cost decay)\n\nThis creates a smooth gradient of costs that decreases as distance from obstacles increases.\n\nSources: [costmap_2d/include/costmap_2d/inflation_layer.h:104-119]()\n\n## Configuration Parameters\n\nThe Inflation Layer can be configured through the following parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `inflation_radius` | double | - | Maximum distance from an obstacle at which costs are incurred |\n| `cost_scaling_factor` | double | - | Scaling factor for the cost decay equation |\n| `inflate_unknown` | bool | false | Whether to inflate unknown space (represented by NO_INFORMATION) |\n| `enabled` | bool | true | Whether the layer is currently enabled |\n\nThese parameters can be dynamically reconfigured at runtime using ROS's dynamic_reconfigure system.\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:103-111](), [costmap_2d/plugins/inflation_layer.cpp:369-383]()\n\n## Inflation Layer in the Layered Costmap Architecture\n\n```mermaid\nflowchart TD\n    subgraph \"Costmap2D Processing\"\n        LC[\"LayeredCostmap\"] --\u003e |\"1. updateMap()\"| SL[\"StaticLayer\"]\n        LC --\u003e |\"2. updateMap()\"| OL[\"ObstacleLayer\"]\n        LC --\u003e |\"3. updateMap()\"| IL[\"InflationLayer\"]\n        \n        SL --\u003e |\"updateCosts()\"| CM[\"Master costmap\"]\n        OL --\u003e |\"updateCosts()\"| CM\n        IL --\u003e |\"updateCosts()\"| CM\n    end\n    \n    subgraph \"InflationLayer Processing\"\n        IL2[\"InflationLayer.updateCosts()\"] --\u003e F[\"Find lethal obstacles\"]\n        F --\u003e Q[\"Create distance-sorted queue\"]\n        Q --\u003e P[\"Process cells by distance\"]\n        P --\u003e C[\"Compute cost based on distance\"]\n        C --\u003e N[\"Process neighbors\"]\n        N --\u003e |\"loop\"| P\n    end\n```\n\nThe Inflation Layer typically operates after the Static Layer and Obstacle Layer have updated the master costmap. The sequence of operations is:\n\n1. The Static Layer adds information from the static map\n2. The Obstacle Layer adds information from sensor observations\n3. The Inflation Layer inflates obstacles from both static and sensor data\n4. The resulting costmap is used by planners for navigation\n\nThis ordering ensures that all obstacles are properly identified before inflation occurs.\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:176-280]()\n\n## Implementation Details\n\nThe Inflation Layer uses several optimizations to efficiently inflate obstacles:\n\n1. **Distance and Cost Caching**: The layer precomputes distances and costs for cells within the inflation radius to avoid repetitive calculations.\n\n2. **Distance-Sorted Cell Queue**: Cells are processed in order of increasing distance from obstacles, which ensures that closer cells are processed before their neighbors.\n\n3. **Seen Cells Tracking**: A boolean array tracks which cells have been processed to avoid redundant calculations.\n\n4. **Cell Inflation Radius**: The inflation radius is converted to cell units for more efficient grid operations.\n\nThe inflation process is thread-safe, using a recursive mutex to protect access during updates.\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:308-341](), [costmap_2d/plugins/inflation_layer.cpp:176-197]()\n\n## Common Issues and Troubleshooting\n\n### Appropriate Inflation Radius\n\nSetting the inflation radius is critical:\n- Too small: The robot may collide with obstacles or navigate too close to them\n- Too large: The robot may be unable to navigate through tight spaces\n\nThe inflation radius should generally be set to at least the robot's circumscribed radius (the radius of the smallest circle that completely contains the robot), plus a safety margin.\n\n### Cost Scaling Factor Tuning\n\nThe cost scaling factor controls how quickly costs decay as distance from obstacles increases:\n- Lower values: Costs decrease slowly, creating a wider high-cost area around obstacles\n- Higher values: Costs decrease quickly, creating a steeper gradient\n\nA typical starting value is 2.0, which can then be adjusted based on the robot's behavior.\n\n### Inflation and Map Resolution\n\nThe effectiveness of inflation is affected by the map resolution. Higher resolution maps (smaller cell sizes) allow for more precise inflation but require more computational resources.\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:369-383]()\n\n## Interaction with Robot Footprint Changes\n\nWhen the robot's footprint changes (e.g., when carrying a load that extends beyond its normal dimensions), the Inflation Layer automatically recomputes the inflation to account for the new dimensions. This is triggered by the `onFootprintChanged()` method.\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:164-173]()\n\n## Performance Considerations\n\nThe Inflation Layer can be computationally intensive, especially with large inflation radii or high-resolution maps. To optimize performance:\n\n- Use an appropriate inflation radius (not larger than necessary)\n- Consider the tradeoff between map resolution and computational load\n- Be aware that full reinflation is triggered when parameters change or when the robot's footprint changes\n\nSources: [costmap_2d/plugins/inflation_layer.cpp:128-161](), [costmap_2d/plugins/inflation_layer.cpp:176-280]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"1f:T2aca,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Voxel Layer\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/include/costmap_2d/inflation_layer.h](costmap_2d/include/costmap_2d/inflation_layer.h)\n- [costmap_2d/include/costmap_2d/obstacle_layer.h](costmap_2d/include/costmap_2d/obstacle_layer.h)\n- [costmap_2d/include/costmap_2d/static_layer.h](costmap_2d/include/costmap_2d/static_layer.h)\n- [costmap_2d/include/costmap_2d/voxel_layer.h](costmap_2d/include/costmap_2d/voxel_layer.h)\n- [costmap_2d/plugins/inflation_layer.cpp](costmap_2d/plugins/inflation_layer.cpp)\n- [costmap_2d/plugins/obstacle_layer.cpp](costmap_2d/plugins/obstacle_layer.cpp)\n- [costmap_2d/plugins/static_layer.cpp](costmap_2d/plugins/static_layer.cpp)\n- [costmap_2d/plugins/voxel_layer.cpp](costmap_2d/plugins/voxel_layer.cpp)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n\n\u003c/details\u003e\n\n\n\nThe Voxel Layer is a specialized costmap layer that extends the Obstacle Layer to provide three-dimensional obstacle representation. While the standard Obstacle Layer projects all sensor observations onto a 2D plane, the Voxel Layer maintains height information using a voxel grid (volumetric pixel grid), allowing for better handling of multi-level environments and overhanging obstacles.\n\nFor information about the general costmap system, see [Costmap2D](#2). For details on the standard Obstacle Layer that this class extends, see [Obstacle Layer](#2.3.2).\n\n## Class Hierarchy\n\nThe Voxel Layer inherits from Obstacle Layer and integrates with the layered costmap architecture of the navigation stack.\n\n```mermaid\nclassDiagram\n    class Layer {\n        \u003c\u003cinterface\u003e\u003e\n        +updateBounds()\n        +updateCosts()\n        +reset()\n        +matchSize()\n    }\n    \n    class CostmapLayer {\n        +updateWithMax()\n        +updateWithOverwrite()\n        +resetMaps()\n    }\n    \n    class ObstacleLayer {\n        +observation_buffers_\n        +marking_buffers_\n        +clearing_buffers_\n        +raytraceFreespace()\n        +getMarkingObservations()\n        +getClearingObservations()\n    }\n    \n    class VoxelLayer {\n        +voxel_grid_\n        +z_resolution_\n        +origin_z_\n        +size_z_\n        +mark_threshold_\n        +unknown_threshold_\n        +raytraceFreespace()\n        +worldToMap3D()\n        +worldToMap3DFloat()\n    }\n    \n    Layer \u003c|-- CostmapLayer\n    CostmapLayer \u003c|-- ObstacleLayer\n    ObstacleLayer \u003c|-- VoxelLayer\n```\n\nSources: [costmap_2d/include/costmap_2d/voxel_layer.h:61-146](), [costmap_2d/include/costmap_2d/obstacle_layer.h:62-173]()\n\n## Architecture and Data Flow\n\nThe Voxel Layer processes sensor data (laser scans, point clouds) in 3D, maintaining a volumetric representation before projecting it to the 2D costmap.\n\n```mermaid\nflowchart TD\n    subgraph \"Sensor Input\"\n        LS[\"Laser Scan\"]\n        PC[\"Point Cloud\"]\n        PC2[\"Point Cloud2\"]\n    end\n    \n    subgraph \"VoxelLayer\"\n        OB[\"Observation Buffers\"]\n        MO[\"Marking Observations\"]\n        CO[\"Clearing Observations\"]\n        VG[\"voxel_grid::VoxelGrid\"]\n        RT[\"3D Ray Tracing\"]\n        P2D[\"Projection to 2D\"]\n        CM[\"Costmap Cells\"]\n    end\n    \n    LS --\u003e OB\n    PC --\u003e OB\n    PC2 --\u003e OB\n    \n    OB --\u003e MO\n    OB --\u003e CO\n    \n    MO --\u003e VG\n    CO --\u003e RT\n    RT --\u003e VG\n    \n    VG --\u003e P2D\n    P2D --\u003e CM\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:55-215](), [costmap_2d/plugins/voxel_layer.cpp:268-390]()\n\n## 2D vs 3D Representation\n\nThe key difference between the standard Obstacle Layer and the Voxel Layer is how they handle vertical space:\n\n```mermaid\ngraph TD\n    subgraph \"Obstacle Layer (2D)\"\n        O2D1[\"2D cell: obstacle present\"]\n        O2D2[\"2D cell: obstacle present\"]\n    end\n    \n    subgraph \"Voxel Layer (3D)\"\n        V1[\"Voxel column\"]\n        V1A[\"Voxel at z=0.0m: free\"]\n        V1B[\"Voxel at z=0.5m: occupied\"]\n        V1C[\"Voxel at z=1.0m: free\"]\n        \n        V2[\"Voxel column\"]\n        V2A[\"Voxel at z=0.0m: free\"]\n        V2B[\"Voxel at z=0.5m: free\"]\n        V2C[\"Voxel at z=1.0m: occupied\"]\n        \n        V1 --- V1A\n        V1 --- V1B\n        V1 --- V1C\n        \n        V2 --- V2A\n        V2 --- V2B\n        V2 --- V2C\n    end\n    \n    O2D1 -.- V1\n    O2D2 -.- V2\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:116-188]()\n\n## Implementation Details\n\n### Initialization\n\nThe Voxel Layer initializes by first calling the parent ObstacleLayer's initialization and then setting up its own voxel-specific parameters.\n\n```mermaid\nsequenceDiagram\n    participant VL as VoxelLayer\n    participant OL as ObstacleLayer\n    participant Pub as ROS Publishers\n    \n    VL-\u003e\u003eOL: onInitialize()\n    VL-\u003e\u003eVL: Configure voxel-specific parameters\n    VL-\u003e\u003ePub: Create voxel_pub_ if publish_voxel_\n    VL-\u003e\u003ePub: Create clearing_endpoints_pub_\n    VL-\u003e\u003eVL: Setup dynamic_reconfigure\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:55-65]()\n\n### Key Member Variables\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `voxel_grid_` | `voxel_grid::VoxelGrid` | 3D grid structure to store occupancy information |\n| `z_resolution_` | `double` | Size of each voxel in the z-dimension |\n| `origin_z_` | `double` | Z-coordinate of the origin of the voxel grid |\n| `size_z_` | `unsigned int` | Number of voxels in the z-dimension |\n| `mark_threshold_` | `unsigned int` | Threshold for marking a cell as occupied |\n| `unknown_threshold_` | `unsigned int` | Threshold for marking a cell as unknown |\n| `publish_voxel_` | `bool` | Whether to publish the voxel grid for visualization |\n\nSources: [costmap_2d/include/costmap_2d/voxel_layer.h:97-104]()\n\n### Key Methods\n\n#### updateBounds\n\nThe `updateBounds` method processes sensor data and integrates it into the voxel grid. It overrides the parent class's method to handle 3D data.\n\n1. Gets marking and clearing observations\n2. Performs 3D raytracing for clearing operations\n3. Processes marking observations in 3D\n4. Projects 3D information to the 2D costmap\n5. Optionally publishes the voxel grid for visualization\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:116-215]()\n\n#### raytraceFreespace\n\nThis method performs 3D raytracing from the sensor origin to endpoints, clearing voxels along the way.\n\n1. Converts sensor origin to 3D map coordinates\n2. For each point in the clearing observation:\n   - Scales the point if necessary\n   - Adjusts for map boundaries and maximum height\n   - Converts to map coordinates\n   - Clears voxels along the ray\n   - Updates bounds\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:268-390]()\n\n#### worldToMap3D and worldToMap3DFloat\n\nThese methods convert world coordinates to voxel grid coordinates:\n\n```cpp\nbool worldToMap3D(double wx, double wy, double wz, unsigned int\u0026 mx, unsigned int\u0026 my, unsigned int\u0026 mz)\nbool worldToMap3DFloat(double wx, double wy, double wz, double\u0026 mx, double\u0026 my, double\u0026 mz)\n```\n\nSources: [costmap_2d/include/costmap_2d/voxel_layer.h:106-117](), [costmap_2d/include/costmap_2d/voxel_layer.h:119-132]()\n\n#### clearNonLethal\n\nClears non-lethal obstacles in a specified window:\n\n1. Converts window coordinates to map coordinates\n2. Loops through cells in the window\n3. Clears non-lethal cells in the costmap\n4. Clears corresponding voxel columns in the voxel grid\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:217-266]()\n\n## Configuration\n\nThe Voxel Layer uses dynamic reconfigure to allow parameter changes at runtime.\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `enabled` | Enable/disable the layer | true |\n| `footprint_clearing_enabled` | Clear the robot's footprint | true |\n| `max_obstacle_height` | Maximum height of obstacles (m) | 2.0 |\n| `z_voxels` | Number of voxels in z dimension | 10 |\n| `z_resolution` | Resolution in z dimension (m) | 0.2 |\n| `origin_z` | Origin in z dimension (m) | 0.0 |\n| `unknown_threshold` | Threshold for unknown voxels | 15 |\n| `mark_threshold` | Threshold for occupied voxels | 0 |\n| `combination_method` | How to combine with other layers | 1 (maximum) |\n| `publish_voxel_map` | Publish voxel grid for visualization | false |\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:81-92]()\n\n## Integration with the Navigation Stack\n\nTo use Voxel Layer in your costmap configuration, specify it in your costmap configuration YAML file:\n\n```yaml\ncostmap:\n  plugins:\n    - {name: static_layer, type: \"costmap_2d::StaticLayer\"}\n    - {name: voxel_layer, type: \"costmap_2d::VoxelLayer\"}\n    - {name: inflation_layer, type: \"costmap_2d::InflationLayer\"}\n  \n  voxel_layer:\n    enabled: true\n    publish_voxel_map: true\n    z_resolution: 0.2\n    z_voxels: 10\n    unknown_threshold: 15\n    mark_threshold: 0\n    max_obstacle_height: 2.0\n    observation_sources: point_cloud_sensor\n    \n    point_cloud_sensor:\n      data_type: PointCloud2\n      topic: /sensor/point_cloud\n      marking: true\n      clearing: true\n      min_obstacle_height: 0.0\n      max_obstacle_height: 2.0\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:55-65](), [costmap_2d/CMakeLists.txt:57]()\n\n## Voxel Grid Visualization\n\nWhen `publish_voxel_map` is set to true, the Voxel Layer publishes a `costmap_2d::VoxelGrid` message that can be visualized in RViz:\n\n```mermaid\nsequenceDiagram\n    participant VL as VoxelLayer\n    participant RViz as RViz Visualization\n    \n    VL-\u003e\u003eVL: updateBounds()\n    Note over VL: Process sensor data\n    \n    alt publish_voxel_ is true\n        VL-\u003e\u003eVL: Create VoxelGrid message\n        VL-\u003e\u003eVL: Copy voxel data\n        VL-\u003e\u003eVL: Set origin and resolution\n        VL-\u003e\u003eRViz: Publish to voxel_pub_\n    end\n```\n\nSources: [costmap_2d/plugins/voxel_layer.cpp:192-212]()\n\n## When to Use Voxel Layer\n\nThe Voxel Layer is particularly useful in environments with:\n\n1. Overhanging obstacles (like tree branches, shelves, or tables)\n2. Multi-level structures where obstacles exist at different heights\n3. Complex 3D environments where 2D representations would fail\n4. Scenarios where clearing 3D space is important (e.g., navigating under obstacles)\n\nBy representing obstacles in 3D, the Voxel Layer allows for more accurate navigation in complex environments while still integrating with the 2D costmap system used by the ROS navigation stack.\n\nSources: [costmap_2d/include/costmap_2d/voxel_layer.h:38-150](), [costmap_2d/plugins/voxel_layer.cpp:38-449]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"20:T4369,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Move Base\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_base/cfg/MoveBase.cfg](move_base/cfg/MoveBase.cfg)\n- [move_base/include/move_base/move_base.h](move_base/include/move_base/move_base.h)\n- [move_base/src/move_base.cpp](move_base/src/move_base.cpp)\n- [move_base/src/move_base_node.cpp](move_base/src/move_base_node.cpp)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n\n\u003c/details\u003e\n\n\n\nMove Base is the central coordination node of the ROS Navigation Stack. It takes in navigation goals and combines global and local planning to safely navigate a robot through its environment. This page covers the architecture, behavior, configuration, and API of the move_base node.\n\nFor information about global planning algorithms, see [Global Planners](#4), and for local planning details, see [Local Planners](#5).\n\n## Architecture\n\nMove Base acts as a coordinator that connects multiple navigation components together. It manages global and local planners as plugins, handles recovery behaviors, maintains two separate costmaps, and exposes a ROS Action Server interface to receive navigation goals.\n\n### Core Components\n\n```mermaid\nclassDiagram\n    class MoveBase {\n        -MoveBaseState state_\n        -RecoveryTrigger recovery_trigger_\n        -vector\u003cPoseStamped\u003e planner_plan_\n        -vector\u003cPoseStamped\u003e controller_plan_\n        +executeCb(MoveBaseGoal)\n        +planThread()\n        +executeCycle()\n        +makePlan()\n    }\n\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +makePlan()\n        +initialize()\n    }\n\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +initialize()\n    }\n\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +runBehavior()\n        +initialize()\n    }\n\n    class Costmap2DROS {\n        +getCostmap()\n        +update()\n        +start()\n        +stop()\n    }\n\n    MoveBase --\u003e \"1\" Costmap2DROS: \"planner_costmap_ros_\"\n    MoveBase --\u003e \"1\" Costmap2DROS: \"controller_costmap_ros_\"\n    MoveBase --\u003e \"1\" BaseGlobalPlanner: \"planner_\"\n    MoveBase --\u003e \"1\" BaseLocalPlanner: \"tc_\"\n    MoveBase --\u003e \"*\" RecoveryBehavior: \"recovery_behaviors_\"\n```\n\nSources: [move_base/include/move_base/move_base.h:64-236](), [move_base/src/move_base.cpp:51-180]()\n\n### State Machine\n\nMove Base operates as a state machine with three primary states:\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e PLANNING: \"Navigation goal received\"\n    \n    PLANNING --\u003e CONTROLLING: \"Global plan succeeded\"\n    CONTROLLING --\u003e PLANNING: \"Local planner cannot find path\"\n    \n    PLANNING --\u003e CLEARING: \"Planning failed (timeout/retries exceeded)\"\n    CONTROLLING --\u003e CLEARING: \"Control failed (timeout)\"\n    CONTROLLING --\u003e CLEARING: \"Oscillation detected\"\n    \n    CLEARING --\u003e PLANNING: \"After recovery behavior\"\n    \n    CONTROLLING --\u003e [*]: \"Goal reached\"\n    CLEARING --\u003e [*]: \"All recovery behaviors failed\"\n```\n\nSources: [move_base/include/move_base/move_base.h:66-70](), [move_base/src/move_base.cpp:797-944]()\n\n### Data Flow\n\n```mermaid\nflowchart TD\n    subgraph \"External Interfaces\"\n        AS[\"Action Server\\n(/move_base/goal)\"]\n        ST[\"Simple Topic\\n(/move_base_simple/goal)\"]\n        VP[\"Velocity Publisher\\n(/cmd_vel)\"]\n        PS[\"Plan Service\\n(/make_plan)\"]\n        CS[\"Clear Costmaps Service\\n(/clear_costmaps)\"]\n    end\n\n    subgraph \"MoveBase Node\"\n        EC[\"executeCycle()\"]\n        PT[\"planThread()\"]\n        MP[\"makePlan()\"]\n        PC[\"planner_cond_\"]\n    end\n\n    subgraph \"Planners\"\n        GP[\"Global Planner\\n(e.g., NavfnROS)\"]\n        LP[\"Local Planner\\n(e.g., TrajectoryPlannerROS)\"]\n    end\n\n    subgraph \"Costmaps\"\n        PCM[\"planner_costmap_ros_\"]\n        CCM[\"controller_costmap_ros_\"]\n    end\n\n    subgraph \"Recovery Behaviors\"\n        RB1[\"recover1 (e.g., ClearCostmapRecovery)\"]\n        RB2[\"recover2 (e.g., RotateRecovery)\"]\n        RB3[\"recover3 (e.g., AggressiveReset)\"]\n    end\n\n    AS --\u003e EC\n    ST --\u003e EC\n    \n    EC --\u003e PT: \"triggers via\\nrunPlanner_\"\n    PT --\u003e PC: \"waits on condition\"\n    PC --\u003e PT: \"notifies\"\n    \n    PT --\u003e MP\n    MP --\u003e GP\n    GP --\u003e PCM: \"queries\"\n    MP --\u003e PT: \"returns plan\"\n    \n    EC --\u003e LP: \"computeVelocityCommands()\"\n    LP --\u003e CCM: \"queries\"\n    LP --\u003e EC: \"returns velocity\"\n    EC --\u003e VP: \"publishes cmd_vel\"\n    \n    EC --\u003e RB1: \"if stuck\"\n    EC --\u003e RB2: \"if still stuck\"\n    EC --\u003e RB3: \"if still stuck\"\n    \n    PS --\u003e MP\n```\n\nSources: [move_base/src/move_base.cpp:569-648](), [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:802-944]()\n\n## Plugin System\n\nMove Base uses a plugin architecture to allow easy customization of planning and recovery behaviors. The system loads plugins via the `pluginlib` framework.\n\n### Plugin Types\n\n```mermaid\nclassDiagram\n    class MoveBase {\n        -bgp_loader_\n        -blp_loader_\n        -recovery_loader_\n        +loadRecoveryBehaviors()\n        +loadDefaultRecoveryBehaviors()\n    }\n\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +makePlan()\n        +initialize()\n    }\n\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +initialize()\n    }\n\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +runBehavior()\n        +initialize()\n    }\n\n    class NavfnROS {\n        +makePlan()\n        +initialize()\n    }\n\n    class GlobalPlanner {\n        +makePlan()\n        +initialize()\n    }\n\n    class CarrotPlanner {\n        +makePlan()\n        +initialize()\n    }\n\n    class TrajectoryPlannerROS {\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +initialize()\n    }\n\n    class DWAPlannerROS {\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +initialize()\n    }\n\n    class ClearCostmapRecovery {\n        +runBehavior()\n        +initialize()\n    }\n\n    class RotateRecovery {\n        +runBehavior()\n        +initialize()\n    }\n\n    class MoveSlowAndClear {\n        +runBehavior()\n        +initialize()\n    }\n\n    BaseGlobalPlanner \u003c|.. NavfnROS\n    BaseGlobalPlanner \u003c|.. GlobalPlanner\n    BaseGlobalPlanner \u003c|.. CarrotPlanner\n    \n    BaseLocalPlanner \u003c|.. TrajectoryPlannerROS\n    BaseLocalPlanner \u003c|.. DWAPlannerROS\n    \n    RecoveryBehavior \u003c|.. ClearCostmapRecovery\n    RecoveryBehavior \u003c|.. RotateRecovery\n    RecoveryBehavior \u003c|.. MoveSlowAndClear\n    \n    MoveBase --\u003e BaseGlobalPlanner\n    MoveBase --\u003e BaseLocalPlanner\n    MoveBase --\u003e RecoveryBehavior\n```\n\nSources: [move_base/src/move_base.cpp:55-57](), [move_base/src/move_base.cpp:124-144](), [move_base/src/move_base.cpp:164-166]()\n\n### Loading Plugins\n\nMove Base loads plugins dynamically at runtime:\n\n1. **Global Planner**: Default is `navfn/NavfnROS`\n2. **Local Planner**: Default is `base_local_planner/TrajectoryPlannerROS`\n3. **Recovery Behaviors**: Default sequence includes costmap clearing, rotation, and aggressive clearing\n\nThe plugins can be specified through ROS parameters or dynamic reconfigure.\n\nSources: [move_base/src/move_base.cpp:69-71](), [move_base/cfg/MoveBase.cfg:9-10]()\n\n## Operation\n\n### Navigation Process\n\n1. **Goal Reception**: Goals are received via the ROS Action interface or a simple topic\n2. **Global Planning**: A global path is planned from the current position to the goal\n3. **Local Planning**: The local planner follows the global path while avoiding obstacles\n4. **Execution**: Velocity commands are sent to the robot's base\n5. **Recovery**: If the robot gets stuck, recovery behaviors are triggered\n6. **Completion**: The process ends when the goal is reached, preempted, or deemed impossible\n\nSources: [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:802-944]()\n\n### Triple Buffer Plan Coordination\n\nMove Base uses a triple-buffer approach for plan coordination:\n\n```mermaid\nflowchart LR\n    subgraph \"Global Planner Thread\"\n        PP[\"planner_plan_\"]\n    end\n    \n    subgraph \"Controller Thread\"\n        LP[\"latest_plan_\"]\n        CP[\"controller_plan_\"]\n    end\n    \n    PP --\u003e|\"swap pointers\"| LP\n    LP --\u003e|\"swap pointers\"| CP\n    CP --\u003e|\"used by local planner\"| BaseLocalPlanner\n```\n\nThis approach allows the planner thread to generate new plans asynchronously while the control thread executes the current plan.\n\nSources: [move_base/src/move_base.cpp:87-90](), [move_base/src/move_base.cpp:597-602](), [move_base/src/move_base.cpp:843-848]()\n\n### Recovery Behavior Sequence\n\nWhen the robot gets stuck, Move Base executes recovery behaviors in sequence:\n\n```mermaid\nsequenceDiagram\n    participant MB as MoveBase\n    participant GP as GlobalPlanner\n    participant LP as LocalPlanner\n    participant CR as ClearCostmapRecovery\n    participant RR as RotateRecovery\n    participant MSC as MoveSlowAndClear\n\n    MB-\u003e\u003eGP: Plan path\n    activate GP\n    GP--\u003e\u003eMB: Planning failed\n    deactivate GP\n    \n    Note over MB: recovery_index_ = 0\n    \n    MB-\u003e\u003eCR: Run conservative reset\n    activate CR\n    CR--\u003e\u003eMB: Recovery complete\n    deactivate CR\n    \n    MB-\u003e\u003eGP: Plan path again\n    activate GP\n    GP--\u003e\u003eMB: Still failed\n    deactivate GP\n    \n    Note over MB: recovery_index_ = 1\n    \n    MB-\u003e\u003eRR: Run rotate recovery\n    activate RR\n    RR--\u003e\u003eMB: Recovery complete\n    deactivate RR\n    \n    MB-\u003e\u003eGP: Plan path again\n    activate GP\n    GP--\u003e\u003eMB: Still failed\n    deactivate GP\n    \n    Note over MB: recovery_index_ = 2\n    \n    MB-\u003e\u003eMSC: Run aggressive reset\n    activate MSC\n    MSC--\u003e\u003eMB: Recovery complete\n    deactivate MSC\n    \n    alt Plan succeeds\n        MB-\u003e\u003eGP: Plan path again\n        activate GP\n        GP--\u003e\u003eMB: Planning succeeded\n        deactivate GP\n        \n        MB-\u003e\u003eLP: Execute plan\n        activate LP\n        LP--\u003e\u003eMB: Controlling\n        deactivate LP\n    else Plan still fails\n        MB--\u003e\u003eMB: Abort navigation\n    end\n```\n\nSources: [move_base/src/move_base.cpp:164-166](), [move_base/src/move_base.cpp:979-1063]()\n\n## Configuration\n\nMove Base is highly configurable through ROS parameters and dynamic reconfigure. Key parameters include:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `base_global_planner` | string | \"navfn/NavfnROS\" | Global planner plugin to use |\n| `base_local_planner` | string | \"base_local_planner/TrajectoryPlannerROS\" | Local planner plugin to use |\n| `planner_frequency` | double | 0.0 | Rate (Hz) at which to run global planning (0 = only plan when needed) |\n| `controller_frequency` | double | 20.0 | Rate (Hz) at which to run local planning loop |\n| `planner_patience` | double | 5.0 | Seconds to wait for valid plan before recovery |\n| `controller_patience` | double | 15.0 | Seconds to wait for valid control before recovery |\n| `max_planning_retries` | int | -1 | Maximum planning attempts before recovery (-1 = unlimited) |\n| `recovery_behavior_enabled` | bool | true | Whether to use recovery behaviors |\n| `clearing_rotation_allowed` | bool | true | Whether to allow rotation recovery behavior |\n| `shutdown_costmaps` | bool | false | Whether to shut down costmaps when inactive |\n| `oscillation_timeout` | double | 0.0 | Seconds to allow oscillation before recovery |\n| `oscillation_distance` | double | 0.5 | Meters robot must move to be considered not oscillating |\n\nSources: [move_base/cfg/MoveBase.cfg:9-32](), [move_base/src/move_base.cpp:69-81]()\n\n## API\n\n### ROS Action Server\n\n```\n/move_base/goal (move_base_msgs/MoveBaseActionGoal)\n/move_base/cancel (actionlib_msgs/GoalID)\n/move_base/feedback (move_base_msgs/MoveBaseFeedback)\n/move_base/status (actionlib_msgs/GoalStatusArray)\n/move_base/result (move_base_msgs/MoveBaseResult)\n```\n\nThe main interface for commanding Move Base is through the ROS Action Server framework, which provides goal tracking, feedback, and cancellation.\n\nSources: [move_base/src/move_base.cpp:61](), [move_base/src/move_base.cpp:651-795]()\n\n### Simple Topic Interface\n\n```\n/move_base_simple/goal (geometry_msgs/PoseStamped)\n```\n\nA simplified interface that allows sending goals without using the Action Server framework. This doesn't provide feedback or status updates.\n\nSources: [move_base/src/move_base.cpp:106-107](), [move_base/src/move_base.cpp:275-282]()\n\n### Services\n\n```\n/move_base/make_plan (nav_msgs/GetPlan)\n/move_base/clear_costmaps (std_srvs/Empty)\n```\n\nAdditional services for planning without execution and manual costmap clearing.\n\nSources: [move_base/src/move_base.cpp:151-152](), [move_base/src/move_base.cpp:350-445](), [move_base/src/move_base.cpp:339-347]()\n\n### Publishers\n\n```\n/cmd_vel (geometry_msgs/Twist)\n/move_base/current_goal (geometry_msgs/PoseStamped)\n/move_base/recovery_status (move_base_msgs/RecoveryStatus)\n```\n\nTopics where Move Base publishes robot commands and status information.\n\nSources: [move_base/src/move_base.cpp:96-101]()\n\n## Implementation Details\n\n### Threading Model\n\nMove Base uses a multi-threaded approach:\n\n1. **Main Thread**: Manages the ROS Action Server and runs the controller loop\n2. **Planner Thread**: Runs global planning in the background to avoid blocking the controller\n\nThis allows the robot to continue executing the current plan while computing new plans.\n\nSources: [move_base/src/move_base.cpp:93](), [move_base/src/move_base.cpp:569-648]()\n\n### Plan Triple Buffer\n\nTo coordinate between the planning and control threads, Move Base uses three plan buffers:\n\n1. `planner_plan_`: Used by the planner thread to store the newly generated plan\n2. `latest_plan_`: Intermediate buffer for thread-safe plan transfers\n3. `controller_plan_`: Used by the controller to execute the current plan\n\nPlans are swapped between these buffers using pointer swaps to avoid copying large plan data.\n\nSources: [move_base/src/move_base.cpp:87-90](), [move_base/src/move_base.cpp:597-602](), [move_base/src/move_base.cpp:843-848]()\n\n### Recovery Triggers\n\nMove Base defines three triggers for recovery behaviors:\n\n1. `PLANNING_R`: Triggered when planning fails (timeout or max retries)\n2. `CONTROLLING_R`: Triggered when local planning fails to find valid controls\n3. `OSCILLATION_R`: Triggered when the robot is detected to be oscillating\n\nEach trigger can reset the recovery behavior sequence differently.\n\nSources: [move_base/include/move_base/move_base.h:72-77](), [move_base/src/move_base.cpp:631-632](), [move_base/src/move_base.cpp:906-907](), [move_base/src/move_base.cpp:930-931]()\n\n## Usage Examples\n\n### Basic Launch File\n\nA typical launch file for Move Base would include:\n\n```xml\n\u003cnode pkg=\"move_base\" type=\"move_base\" respawn=\"false\" name=\"move_base\" output=\"screen\"\u003e\n  \u003cparam name=\"base_global_planner\" value=\"navfn/NavfnROS\"/\u003e\n  \u003cparam name=\"base_local_planner\" value=\"base_local_planner/TrajectoryPlannerROS\"/\u003e\n  \n  \u003c!-- Planner and controller frequencies --\u003e\n  \u003cparam name=\"planner_frequency\" value=\"1.0\"/\u003e\n  \u003cparam name=\"controller_frequency\" value=\"5.0\"/\u003e\n  \n  \u003c!-- Patience parameters --\u003e\n  \u003cparam name=\"planner_patience\" value=\"5.0\"/\u003e\n  \u003cparam name=\"controller_patience\" value=\"15.0\"/\u003e\n  \n  \u003c!-- Oscillation parameters --\u003e\n  \u003cparam name=\"oscillation_timeout\" value=\"10.0\"/\u003e\n  \u003cparam name=\"oscillation_distance\" value=\"0.2\"/\u003e\n  \n  \u003c!-- Link to costmap parameters --\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/costmap_common_params.yaml\" command=\"load\" ns=\"global_costmap\"/\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/costmap_common_params.yaml\" command=\"load\" ns=\"local_costmap\"/\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/local_costmap_params.yaml\" command=\"load\"/\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/global_costmap_params.yaml\" command=\"load\"/\u003e\n  \n  \u003c!-- Link to planner parameters --\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/base_local_planner_params.yaml\" command=\"load\"/\u003e\n\u003c/node\u003e\n```\n\n### Sending Navigation Goals\n\nTo send a goal using the ROS Action Server:\n\n```python\nimport rospy\nimport actionlib\nfrom move_base_msgs.msg import MoveBaseAction, MoveBaseGoal\n\ndef send_goal():\n    client = actionlib.SimpleActionClient('move_base', MoveBaseAction)\n    client.wait_for_server()\n    \n    goal = MoveBaseGoal()\n    goal.target_pose.header.frame_id = \"map\"\n    goal.target_pose.header.stamp = rospy.Time.now()\n    goal.target_pose.pose.position.x = 1.0\n    goal.target_pose.pose.position.y = 1.0\n    goal.target_pose.pose.orientation.w = 1.0\n    \n    client.send_goal(goal)\n    client.wait_for_result()\n    return client.get_state()\n\nif __name__ == '__main__':\n    rospy.init_node('send_navigation_goal')\n    result = send_goal()\n    print(\"Result:\", result)\n```"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"21:T3417,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# State Machine\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [move_base/cfg/MoveBase.cfg](move_base/cfg/MoveBase.cfg)\n- [move_base/include/move_base/move_base.h](move_base/include/move_base/move_base.h)\n- [move_base/src/move_base.cpp](move_base/src/move_base.cpp)\n- [move_base/src/move_base_node.cpp](move_base/src/move_base_node.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Move Base State Machine is the core control logic governing the navigation behavior in the ROS Navigation Stack. This page documents the internal state machine that manages the robot's navigation process, including planning paths, controlling robot motion, and executing recovery behaviors when navigation fails.\n\nFor information about the overall Move Base node and its action interface, see [Move Base](#3) and [Action Interface](#3.2).\n\n## Overview\n\nThe Move Base node uses a state machine to coordinate the various aspects of robot navigation. This state machine has three main states and handles transitions between them based on navigation progress, failures, and time constraints.\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    \n    [*] --\u003e \"PLANNING\"\n    \n    \"PLANNING\" --\u003e \"CONTROLLING\": Valid plan found\n    \"PLANNING\" --\u003e \"CLEARING\": Planning failed for timeout period\n    \n    \"CONTROLLING\" --\u003e [*]: Goal reached\n    \"CONTROLLING\" --\u003e \"PLANNING\": Local planning failed\n    \"CONTROLLING\" --\u003e \"CLEARING\": Control failed for timeout period\n    \"CONTROLLING\" --\u003e \"CLEARING\": Oscillation detected\n    \n    \"CLEARING\" --\u003e \"PLANNING\": After executing recovery behavior\n    \"CLEARING\" --\u003e [*]: All recovery behaviors failed\n```\n\nSources: [move_base/include/move_base/move_base.h:66-70](), [move_base/src/move_base.cpp:870-1003]()\n\n## State Machine States\n\nThe state machine consists of three primary states, each representing a different phase of the navigation process:\n\n| State | Enum Value | Description |\n|-------|------------|-------------|\n| PLANNING | `PLANNING` | Global path planning phase |\n| CONTROLLING | `CONTROLLING` | Local trajectory execution phase |\n| CLEARING | `CLEARING` | Recovery behavior execution phase |\n\nSources: [move_base/include/move_base/move_base.h:66-70]()\n\n### PLANNING State\n\nIn the PLANNING state, Move Base attempts to create a global path from the robot's current position to the goal. This state activates the planner thread which calls the global planner plugin to generate a valid path.\n\nKey behaviors in this state:\n- The planner thread is activated via the `runPlanner_` flag\n- The global planner attempts to find a valid path to the goal\n- Success transitions to CONTROLLING state\n- Failure for longer than `planner_patience_` transitions to CLEARING state\n\n```mermaid\nflowchart TD\n    subgraph \"PLANNING State Logic\"\n        A[\"Start Planning\"] --\u003e B[\"Activate planner thread\"]\n        B --\u003e C[\"Wait for planner result\"]\n        C --\u003e D{\"Valid plan found?\"}\n        D --\u003e|\"Yes\"| E[\"Set state = CONTROLLING\"]\n        D --\u003e|\"No\"| F{\"Planning timeout exceeded?\"}\n        F --\u003e|\"No\"| C\n        F --\u003e|\"Yes\"| G[\"Set state = CLEARING\\nSet recovery_trigger = PLANNING_R\"]\n    end\n```\n\nSources: [move_base/src/move_base.cpp:569-649](), [move_base/src/move_base.cpp:872-880]()\n\n### CONTROLLING State\n\nIn the CONTROLLING state, Move Base follows the global path using the local planner. The local planner generates velocity commands that are sent to the robot base to follow the planned trajectory while avoiding obstacles.\n\nKey behaviors in this state:\n- Local planner computes velocity commands to follow the global path\n- Checks if the goal has been reached\n- Monitors for oscillation (robot moving back and forth without progress)\n- If local planner fails to find valid controls for longer than `controller_patience_`, transitions to CLEARING\n\n```mermaid\nflowchart TD\n    subgraph \"CONTROLLING State Logic\"\n        A[\"Start Controlling\"] --\u003e B{\"Is goal reached?\"}\n        B --\u003e|\"Yes\"| C[\"Success!\\nGoal reached\"]\n        B --\u003e|\"No\"| D{\"Oscillating?\"}\n        D --\u003e|\"Yes\"| E[\"Set state = CLEARING\\nSet recovery_trigger = OSCILLATION_R\"]\n        D --\u003e|\"No\"| F{\"Compute velocity commands\"}\n        F --\u003e|\"Success\"| G[\"Send commands to robot\"]\n        F --\u003e|\"Failure\"| H{\"Control timeout exceeded?\"}\n        H --\u003e|\"Yes\"| I[\"Set state = CLEARING\\nSet recovery_trigger = CONTROLLING_R\"]\n        H --\u003e|\"No\"| J[\"Set state = PLANNING\"]\n    end\n```\n\nSources: [move_base/src/move_base.cpp:882-947]()\n\n### CLEARING State\n\nIn the CLEARING state, Move Base executes recovery behaviors sequentially to attempt to resolve navigation failures. Recovery behaviors may include clearing costmap sections, rotating in place to find a clear path, or other custom behaviors.\n\nKey behaviors in this state:\n- Executes the current recovery behavior in the sequence\n- After each behavior, transitions back to PLANNING\n- If all recovery behaviors fail, aborts the navigation goal\n\n```mermaid\nflowchart TD\n    subgraph \"CLEARING State Logic\"\n        A[\"Start Clearing\"] --\u003e B{\"Recovery behaviors enabled?\"}\n        B --\u003e|\"No\"| C[\"Abort navigation\"]\n        B --\u003e|\"Yes\"| D{\"Any remaining behaviors?\"}\n        D --\u003e|\"No\"| E[\"Abort navigation\"]\n        D --\u003e|\"Yes\"| F[\"Execute next recovery behavior\"]\n        F --\u003e G[\"Reset oscillation timeout\"]\n        G --\u003e H[\"Set state = PLANNING\"]\n        H --\u003e I[\"Increment recovery_index_\"]\n    end\n```\n\nSources: [move_base/src/move_base.cpp:951-1003]()\n\n## Recovery Triggers\n\nThe state machine uses recovery triggers to track what caused the transition to the CLEARING state. This information helps determine appropriate recovery actions and when to reset recovery indices.\n\n| Trigger | Enum Value | Description | Origin |\n|---------|------------|-------------|--------|\n| Planning Recovery | `PLANNING_R` | Triggered when planning fails | PLANNING state timeout |\n| Controlling Recovery | `CONTROLLING_R` | Triggered when execution fails | CONTROLLING state timeout |\n| Oscillation Recovery | `OSCILLATION_R` | Triggered when robot oscillates | Oscillation detection |\n\nSources: [move_base/include/move_base/move_base.h:72-77]()\n\n## State Transitions\n\nThe state machine transitions are managed in the `executeCycle` method, which is called repeatedly at the controller frequency. The current state determines the action to take, and various conditions trigger state transitions.\n\n```mermaid\nsequenceDiagram\n    participant MoveBase\n    participant Planner as Global Planner\n    participant Controller as Local Planner\n    participant Recovery as Recovery Behaviors\n    \n    Note over MoveBase: Receives navigation goal\n    MoveBase-\u003e\u003eMoveBase: state_ = PLANNING\n    \n    loop executeCycle\n        Note over MoveBase: Check current state\n        \n        alt state_ == PLANNING\n            MoveBase-\u003e\u003ePlanner: Run global planner\n            Planner--\u003e\u003eMoveBase: Return plan\n            \n            alt valid plan\n                MoveBase-\u003e\u003eMoveBase: state_ = CONTROLLING\n            else planning timeout\n                MoveBase-\u003e\u003eMoveBase: state_ = CLEARING\n                MoveBase-\u003e\u003eMoveBase: recovery_trigger_ = PLANNING_R\n            end\n            \n        else state_ == CONTROLLING\n            MoveBase-\u003e\u003eController: Compute velocity commands\n            Controller--\u003e\u003eMoveBase: Return commands\n            \n            alt goal reached\n                MoveBase-\u003e\u003eMoveBase: Success! Goal reached\n            else oscillation detected\n                MoveBase-\u003e\u003eMoveBase: state_ = CLEARING\n                MoveBase-\u003e\u003eMoveBase: recovery_trigger_ = OSCILLATION_R\n            else control failure\n                alt controller timeout\n                    MoveBase-\u003e\u003eMoveBase: state_ = CLEARING\n                    MoveBase-\u003e\u003eMoveBase: recovery_trigger_ = CONTROLLING_R\n                else temporary failure\n                    MoveBase-\u003e\u003eMoveBase: state_ = PLANNING\n                end\n            end\n            \n        else state_ == CLEARING\n            MoveBase-\u003e\u003eRecovery: Execute recovery behavior\n            Recovery--\u003e\u003eMoveBase: Completed\n            \n            alt more recovery behaviors available\n                MoveBase-\u003e\u003eMoveBase: state_ = PLANNING\n                MoveBase-\u003e\u003eMoveBase: recovery_index_++\n            else all behaviors failed\n                MoveBase-\u003e\u003eMoveBase: Abort navigation\n            end\n        end\n    end\n```\n\nSources: [move_base/src/move_base.cpp:802-1017]()\n\n## Recovery Behaviors\n\nRecovery behaviors are critical components of the state machine that help the robot recover from navigation failures. They are executed sequentially when in the CLEARING state.\n\n### Default Recovery Sequence\n\nIf no custom recovery behaviors are specified, Move Base loads these default behaviors:\n\n1. **Conservative Reset**: Clears obstacles within a small radius\n2. **Rotate Recovery**: Rotates in place to find a clear path (if enabled)\n3. **Aggressive Reset**: Clears obstacles within a larger radius\n4. **Rotate Recovery**: Rotates again (if enabled)\n\nThe recovery behavior sequence can be customized through the ROS parameter server.\n\n```mermaid\nflowchart LR\n    subgraph \"Default Recovery Sequence\"\n        A[\"Failure\"] --\u003e B[\"Conservative Reset\"]\n        B --\u003e C[\"Rotate in Place\"]\n        C --\u003e D[\"Aggressive Reset\"]\n        D --\u003e E[\"Rotate in Place\"]\n        E --\u003e F[\"Planning\"]\n    end\n```\n\nSources: [move_base/src/move_base.cpp:1104-1146](), [move_base/src/move_base.cpp:163-166]()\n\n## State Machine Implementation\n\nThe state machine is implemented within the `MoveBase` class. The current state is stored in the `state_` member variable, and transitions are triggered based on various conditions in the `executeCycle` method.\n\n### Key Class Members\n\n| Member | Type | Description |\n|--------|------|-------------|\n| `state_` | `MoveBaseState` | Current state of the state machine |\n| `recovery_trigger_` | `RecoveryTrigger` | What triggered the recovery |\n| `recovery_index_` | `unsigned int` | Index of current recovery behavior |\n| `recovery_behaviors_` | `std::vector\u003c...\u003e` | List of recovery behavior plugins |\n| `planner_patience_` | `double` | Time to wait for valid plan before recovery |\n| `controller_patience_` | `double` | Time to wait for valid control before recovery |\n| `oscillation_timeout_` | `double` | Time to detect oscillation |\n| `oscillation_distance_` | `double` | Min distance to reset oscillation timeout |\n\nSources: [move_base/include/move_base/move_base.h:204-205](), [move_base/include/move_base/move_base.h:187-207]()\n\n### State Machine Execution\n\nThe state machine execution happens in the `executeCycle` method, which is called repeatedly from the `executeCb` action callback. This method:\n\n1. Gets the current robot pose\n2. Checks for new global plans\n3. Switches on the current state to execute appropriate behavior\n4. Handles state transitions based on various conditions\n\n```mermaid\nflowchart TD\n    subgraph \"MoveBase Class State Machine\"\n        A[\"executeCb\"] --\u003e B[\"Setup navigation context\"]\n        B --\u003e C[\"Loop at controller_frequency_\"]\n        C --\u003e D[\"executeCycle\"]\n        D --\u003e E{\"Check state_\"}\n        \n        E --\u003e|\"PLANNING\"| F[\"Activate planner thread\"]\n        E --\u003e|\"CONTROLLING\"| G[\"Get velocity commands from local planner\"]\n        E --\u003e|\"CLEARING\"| H[\"Execute recovery behaviors\"]\n        \n        F --\u003e I[\"Wait for result\"]\n        G --\u003e J[\"Send commands to robot or handle failures\"]\n        H --\u003e K[\"Return to PLANNING after recovery\"]\n        \n        I --\u003e L[\"Continue loop\"]\n        J --\u003e L\n        K --\u003e L\n        \n        L --\u003e M{\"Navigation complete?\"}\n        M --\u003e|\"No\"| C\n        M --\u003e|\"Yes\"| N[\"Return result\"]\n    end\n```\n\nSources: [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:802-1017]()\n\n## Configuration Parameters\n\nThe state machine behavior can be configured through several ROS parameters:\n\n| Parameter | Type | Description | Default |\n|-----------|------|-------------|---------|\n| `planner_frequency` | double | Rate at which to run the global planner (Hz) | 0.0 |\n| `controller_frequency` | double | Rate at which to run the controller (Hz) | 20.0 |\n| `planner_patience` | double | How long to wait for a valid plan (seconds) | 5.0 |\n| `controller_patience` | double | How long to wait for valid control (seconds) | 15.0 |\n| `max_planning_retries` | int | Maximum number of planning attempts | -1 (unlimited) |\n| `oscillation_timeout` | double | Time to detect oscillation (seconds) | 0.0 |\n| `oscillation_distance` | double | Distance to reset oscillation timer (meters) | 0.5 |\n| `recovery_behavior_enabled` | bool | Whether to enable recovery behaviors | true |\n| `clearing_rotation_allowed` | bool | Whether rotation recovery is allowed | true |\n\nThese parameters can be set in the launch file or via dynamic reconfigure.\n\nSources: [move_base/src/move_base.cpp:66-81](), [move_base/cfg/MoveBase.cfg:14-27]()\n\n## Debugging the State Machine\n\nThe Move Base node publishes status information that can help debug the state machine:\n\n1. Current goal via the `current_goal` topic\n2. Recovery status via the `recovery_status` topic\n3. Debug messages indicating state transitions and timeouts\n\nAdditionally, the Move Base Action Server publishes feedback containing the current robot pose, which can be used to track navigation progress.\n\nSources: [move_base/src/move_base.cpp:97-101]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"22:T3399,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Action Interface\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [move_base/cfg/MoveBase.cfg](move_base/cfg/MoveBase.cfg)\n- [move_base/include/move_base/move_base.h](move_base/include/move_base/move_base.h)\n- [move_base/src/move_base.cpp](move_base/src/move_base.cpp)\n- [move_base/src/move_base_node.cpp](move_base/src/move_base_node.cpp)\n\n\u003c/details\u003e\n\n\n\nThis document describes the ROS Action interface provided by the `move_base` node in the ROS Navigation Stack. The Action interface is the primary method for commanding the robot to navigate to a specific location. For information about the overall architecture of the Move Base node, see [Move Base](#3).\n\n## Purpose and Functionality\n\nThe Action interface allows client applications to:\n- Send navigation goals to the robot\n- Receive continuous feedback during navigation\n- Cancel or replace goals while in progress\n- Get final results of navigation attempts\n\nSources: [move_base/include/move_base/move_base.h:64-65](), [move_base/include/move_base/move_base.h:179]()\n\n## Interface Overview\n\nThe `move_base` node implements a ROS Action Server that uses the `move_base_msgs/MoveBaseAction` message type. This follows the standard ROS Action protocol which consists of three parts:\n\n1. **Goal** - The navigation target (a pose in the map)\n2. **Feedback** - Regular updates on the robot's position during navigation\n3. **Result** - The final outcome of the navigation attempt\n\n```mermaid\nsequenceDiagram\n    participant \"Client\" as client\n    participant \"MoveBaseActionServer\" as as\n    participant \"MoveBase\" as mb\n    \n    client-\u003e\u003eas: \"Send Goal\"\n    as-\u003e\u003emb: \"executeCb(goal)\"\n    mb-\u003e\u003eclient: \"Accept Goal\"\n    \n    loop Until Goal Reached or Aborted\n        mb-\u003e\u003eclient: \"Publish Feedback\"\n    end\n    \n    alt Goal Succeeded\n        mb-\u003e\u003eclient: \"Set Succeeded (result)\"\n    else Goal Aborted\n        mb-\u003e\u003eclient: \"Set Aborted (result)\"\n    else Goal Preempted\n        mb-\u003e\u003eclient: \"Set Preempted (result)\"\n    end\n```\n\nSources: [move_base/src/move_base.cpp:61](), [move_base/src/move_base.cpp:651-795]()\n\n## Message Structure\n\nThe Action interface is based on the following message types:\n\n### Goal Message\n```\n# move_base_msgs/MoveBaseActionGoal\nHeader header\nGoalID goal_id\nMoveBaseGoal goal\n  geometry_msgs/PoseStamped target_pose\n    Header header\n    Pose pose\n      Point position\n        float64 x\n        float64 y\n        float64 z\n      Quaternion orientation\n        float64 x\n        float64 y\n        float64 z\n        float64 w\n```\n\n### Feedback Message\n```\n# move_base_msgs/MoveBaseFeedback\ngeometry_msgs/PoseStamped base_position\n  Header header\n  Pose pose\n    Point position\n      float64 x\n      float64 y\n      float64 z\n    Quaternion orientation\n      float64 x\n      float64 y\n      float64 z\n      float64 w\n```\n\n### Result Message\n```\n# move_base_msgs/MoveBaseResult\n# Empty message, the result is determined by the action status\n```\n\nSources: [move_base/src/move_base.cpp:813-815]()\n\n## Action Server Implementation\n\nThe `move_base` node implements an action server that coordinates the navigation process when goals are received.\n\n```mermaid\nclassDiagram\n    class MoveBase {\n        -MoveBaseActionServer* as_\n        -state_: MoveBaseState\n        -executeCb(goal)\n        -executeCycle(goal)\n        -makePlan(goal, plan)\n        -resetState()\n    }\n    \n    class MoveBaseActionServer {\n        +setSucceeded(result)\n        +setAborted(result)\n        +setPreempted()\n        +publishFeedback(feedback)\n        +isPreemptRequested()\n        +isNewGoalAvailable()\n        +acceptNewGoal()\n    }\n    \n    MoveBase --* MoveBaseActionServer : \"contains\"\n```\n\nThe action server is initialized during the construction of the `MoveBase` object:\n\n```cpp\nas_ = new MoveBaseActionServer(ros::NodeHandle(), \"move_base\", \n                              [this](auto\u0026 goal){ executeCb(goal); }, false);\n```\n\nAnd is started at the end of the constructor:\n\n```cpp\nas_-\u003estart();\n```\n\nSources: [move_base/src/move_base.cpp:61](), [move_base/src/move_base.cpp:175]()\n\n## Goal Processing Flow\n\nWhen a goal is received by the action server, it triggers the following sequence:\n\n1. The `executeCb` method is called with the goal\n2. The quaternion in the goal is validated\n3. The goal is transformed to the global frame\n4. The planner thread is activated to generate a path\n5. A control loop runs at a configured frequency (default 20Hz)\n6. Feedback is published during navigation\n7. Upon completion, the appropriate result status is set\n\n```mermaid\nflowchart TD\n    A[\"receive goal\"] --\u003e B[\"validate quaternion\"]\n    B --\u003e|\"valid\"| C[\"transform to global frame\"]\n    B --\u003e|\"invalid\"| X[\"abort with error\"]\n    C --\u003e D[\"initialize navigation state\"]\n    D --\u003e E[\"start planner thread\"]\n    E --\u003e F[\"execute control loop\"]\n    \n    F --\u003e G{\"is goal reached?\"}\n    G --\u003e|\"yes\"| H[\"setSucceeded()\"]\n    G --\u003e|\"no\"| I{\"is goal preempted?\"}\n    I --\u003e|\"yes\"| J[\"setPreempted()\"]\n    I --\u003e|\"no\"| K{\"is navigation failed?\"}\n    K --\u003e|\"yes\"| L[\"setAborted()\"]\n    K --\u003e|\"no\"| M[\"publish feedback\"]\n    M --\u003e F\n    \n    H --\u003e Z[\"return\"]\n    J --\u003e Z\n    L --\u003e Z\n    X --\u003e Z\n```\n\nSources: [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:802-1017]()\n\n## State Machine\n\nThe `move_base` node uses a state machine to manage the navigation process. The Action interface interacts with this state machine to coordinate planning, control, and recovery behaviors.\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e PLANNING\n    PLANNING --\u003e CONTROLLING: \"Valid Plan Found\"\n    CONTROLLING --\u003e PLANNING: \"Unable to Find Valid Control\"\n    CONTROLLING --\u003e [*]: \"Goal Reached\"\n    PLANNING --\u003e CLEARING: \"Planning Failed\"\n    CONTROLLING --\u003e CLEARING: \"Control Failed / Oscillation\"\n    CLEARING --\u003e PLANNING: \"Recovery Behavior Executed\"\n    CLEARING --\u003e [*]: \"All Recovery Behaviors Failed\"\n```\n\nThe state transitions affect how the action server responds:\n- When the state is CONTROLLING and the goal is reached, the action succeeds\n- When recovery behaviors are exhausted, the action is aborted\n- When a new goal is received while navigating, the previous goal is preempted\n\nSources: [move_base/include/move_base/move_base.h:66-70](), [move_base/src/move_base.cpp:870-1013]()\n\n## Action Client Interactions\n\n### Sending Goals\n\nClients can send goals to the move_base action server using the standard actionlib client interface:\n\n```cpp\n// Example client code (not part of move_base)\nactionlib::SimpleActionClient\u003cmove_base_msgs::MoveBaseAction\u003e ac(\"move_base\", true);\nac.waitForServer();\n\nmove_base_msgs::MoveBaseGoal goal;\ngoal.target_pose.header.frame_id = \"map\";\ngoal.target_pose.header.stamp = ros::Time::now();\ngoal.target_pose.pose.position.x = 1.0;\ngoal.target_pose.pose.position.y = 1.0;\ngoal.target_pose.pose.orientation.w = 1.0;\n\nac.sendGoal(goal);\n```\n\n### Receiving Feedback\n\nDuring navigation, the move_base node publishes feedback containing the current robot position:\n\n```cpp\n// In move_base.cpp\nmove_base_msgs::MoveBaseFeedback feedback;\nfeedback.base_position = current_position;\nas_-\u003epublishFeedback(feedback);\n```\n\nSources: [move_base/src/move_base.cpp:813-815]()\n\n### Preempting Goals\n\nWhen a client sends a new goal while the robot is already navigating to a previous goal, the move_base action server handles this by preempting the current goal and accepting the new one:\n\n```cpp\n// From move_base.cpp\nif(as_-\u003eisPreemptRequested()){\n  if(as_-\u003eisNewGoalAvailable()){\n    //if we're active and a new goal is available, we'll accept it\n    move_base_msgs::MoveBaseGoal new_goal = *as_-\u003eacceptNewGoal();\n    // ... process the new goal ...\n  }\n  else {\n    //if we've been preempted explicitly we need to shut things down\n    resetState();\n    //notify the ActionServer that we've successfully preempted\n    as_-\u003esetPreempted();\n    return;\n  }\n}\n```\n\nSources: [move_base/src/move_base.cpp:693-736]()\n\n### Goal Completion\n\nUpon completion of a navigation attempt, the action server sets one of three possible outcomes:\n\n1. **Success** - When the robot reaches the goal\n   ```cpp\n   // In move_base.cpp\n   if(tc_-\u003eisGoalReached()){\n     ROS_DEBUG_NAMED(\"move_base\",\"Goal reached!\");\n     resetState();\n     as_-\u003esetSucceeded(move_base_msgs::MoveBaseResult(), \"Goal reached.\");\n     return true;\n   }\n   ```\n\n2. **Abort** - When navigation fails due to planning or control problems\n   ```cpp\n   // In move_base.cpp\n   as_-\u003esetAborted(move_base_msgs::MoveBaseResult(), \n       \"Failed to find a valid plan. Even after executing recovery behaviors.\");\n   ```\n\n3. **Preempt** - When the current goal is canceled in favor of a new goal\n   ```cpp\n   // In move_base.cpp\n   as_-\u003esetPreempted();\n   ```\n\nSources: [move_base/src/move_base.cpp:886-897](), [move_base/src/move_base.cpp:989-999](), [move_base/src/move_base.cpp:732]()\n\n## Simple Topic Interface\n\nIn addition to the Action interface, the move_base node provides a simpler topic-based interface for sending goals:\n\n```cpp\n// In move_base.cpp\nros::NodeHandle simple_nh(\"move_base_simple\");\ngoal_sub_ = simple_nh.subscribe\u003cgeometry_msgs::PoseStamped\u003e(\"goal\", 1, \n                              [this](auto\u0026 goal){ goalCB(goal); });\n```\n\nWhen a message is received on the `/move_base_simple/goal` topic, it is wrapped in an action goal and sent to the action server:\n\n```cpp\nvoid MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr\u0026 goal){\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  \n  action_goal_pub_.publish(action_goal);\n}\n```\n\nThis topic interface is primarily intended for tools like rviz that need a simple way to send navigation goals without the full action client capabilities.\n\nSources: [move_base/src/move_base.cpp:106-107](), [move_base/src/move_base.cpp:275-282]()\n\n## Configuration Parameters\n\nThe action interface behavior can be influenced by several configuration parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `planner_frequency` | double | 0.0 | Rate in Hz at which to run the planning loop (0 = only plan when needed) |\n| `controller_frequency` | double | 20.0 | Rate in Hz at which to run the control loop |\n| `planner_patience` | double | 5.0 | How long to wait for a plan before clearing space |\n| `controller_patience` | double | 15.0 | How long to wait for valid control before clearing space |\n| `max_planning_retries` | int | -1 | Maximum planning attempts before giving up (-1 = unlimited) |\n| `oscillation_timeout` | double | 0.0 | How long to allow oscillation before recovery |\n| `oscillation_distance` | double | 0.5 | How far the robot must move to be considered not oscillating |\n\nThese parameters can be set in the launch file or dynamically reconfigured at runtime.\n\nSources: [move_base/src/move_base.cpp:74-78](), [move_base/src/move_base.cpp:80-81](), [move_base/cfg/MoveBase.cfg:14-27]()\n\n## Integration with Other Components\n\nThe action interface serves as the main entry point for controlling the navigation stack, connecting client applications with the internal components of move_base.\n\n```mermaid\nflowchart TB\n    subgraph \"Client Applications\"\n        AC[\"Action Client\"]\n        TS[\"Topic Subscriber\"]\n    end\n    \n    subgraph \"move_base Node\"\n        AS[\"MoveBaseActionServer\"]\n        GP[\"Global Planner\"]\n        LP[\"Local Planner\"]\n        RB[\"Recovery Behaviors\"]\n        SM[\"State Machine\"]\n    end\n    \n    AC --\u003e|\"send goal\"| AS\n    TS --\u003e|\"publish goal\"| AS\n    AS --\u003e|\"executeCb()\"| SM\n    SM --\u003e|\"PLANNING state\"| GP\n    SM --\u003e|\"CONTROLLING state\"| LP\n    SM --\u003e|\"CLEARING state\"| RB\n    LP --\u003e|\"isGoalReached()\"| AS\n    AS --\u003e|\"feedback\"| AC\n    AS --\u003e|\"result\"| AC\n```\n\nSources: [move_base/src/move_base.cpp:61](), [move_base/src/move_base.cpp:651-795](), [move_base/src/move_base.cpp:870-1013]()\n\n## Common Usage Patterns\n\n### Basic Goal Sending\nThe most common way to use the action interface is to send a goal and wait for the result:\n\n```cpp\n// Wait for the action server to become available\nac.waitForServer();\n\n// Send a goal\nac.sendGoal(goal);\n\n// Wait for the result\nac.waitForResult();\n\n// Check the result\nif(ac.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)\n    ROS_INFO(\"Robot has reached the goal!\");\nelse\n    ROS_INFO(\"The base failed to reach the goal for some reason\");\n```\n\n### Feedback Monitoring\nFor monitoring progress during navigation:\n\n```cpp\n// Define a feedback callback\nvoid feedbackCb(const move_base_msgs::MoveBaseFeedbackConstPtr\u0026 feedback) {\n    ROS_INFO(\"Current robot position: x = %f, y = %f\", \n             feedback-\u003ebase_position.pose.position.x, \n             feedback-\u003ebase_position.pose.position.y);\n}\n\n// Send a goal with the feedback callback\nac.sendGoal(goal, \n            boost::bind(\u0026doneCallback, _1, _2),  // Done callback\n            boost::bind(\u0026activeCallback),        // Active callback\n            boost::bind(\u0026feedbackCb, _1));       // Feedback callback\n```\n\n### Goal Cancellation\nTo cancel a goal in progress:\n\n```cpp\n// Cancel the goal\nac.cancelGoal();\n```\n\nSources: [move_base/src/move_base.cpp:693-736]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"23:T2f66,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Configuration\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [costmap_2d/test/costmap_params.yaml](costmap_2d/test/costmap_params.yaml)\n- [costmap_2d/test/simple_driving_test.xml](costmap_2d/test/simple_driving_test.xml)\n- [move_base/cfg/MoveBase.cfg](move_base/cfg/MoveBase.cfg)\n- [move_base/include/move_base/move_base.h](move_base/include/move_base/move_base.h)\n- [move_base/src/move_base.cpp](move_base/src/move_base.cpp)\n- [move_base/src/move_base_node.cpp](move_base/src/move_base_node.cpp)\n\n\u003c/details\u003e\n\n\n\nThis page describes how to configure the `move_base` node, which is the central coordinator of the ROS navigation stack. The `move_base` node integrates global and local planning components, manages navigation state transitions, and executes recovery behaviors when necessary. Proper configuration of this node is essential for effective robot navigation.\n\nFor information about the overall architecture of `move_base`, see [Move Base](#3). For details on configuring costmaps, refer to [Costmap2DROS](#2.1).\n\n## Configuration Parameters Overview\n\nThe `move_base` node offers a comprehensive set of configuration parameters that control its behavior. These parameters can be set via the ROS parameter server or dynamically reconfigured at runtime.\n\n```mermaid\ngraph TD\n    subgraph \"Move Base Configuration Categories\"\n        A[\"Planner Selection\"]\n        B[\"Frequency Control\"]\n        C[\"Patience Settings\"]\n        D[\"Recovery Behavior\"]\n        E[\"Oscillation Control\"]\n        F[\"Service Behavior\"]\n        G[\"Costmap Configuration\"]\n    end\n    \n    A --\u003e A1[\"base_global_planner\"]\n    A --\u003e A2[\"base_local_planner\"]\n    \n    B --\u003e B1[\"planner_frequency\"]\n    B --\u003e B2[\"controller_frequency\"]\n    \n    C --\u003e C1[\"planner_patience\"]\n    C --\u003e C2[\"controller_patience\"]\n    C --\u003e C3[\"max_planning_retries\"]\n    \n    D --\u003e D1[\"recovery_behavior_enabled\"]\n    D --\u003e D2[\"clearing_rotation_allowed\"]\n    D --\u003e D3[\"conservative_reset_dist\"]\n    \n    E --\u003e E1[\"oscillation_timeout\"]\n    E --\u003e E2[\"oscillation_distance\"]\n    \n    F --\u003e F1[\"make_plan_clear_costmap\"]\n    F --\u003e F2[\"make_plan_add_unreachable_goal\"]\n    \n    G --\u003e G1[\"Global Costmap\"]\n    G --\u003e G2[\"Local Costmap\"]\n```\n\nSources: [move_base/cfg/MoveBase.cfg:8-32](), [move_base/src/move_base.cpp:68-86]()\n\n## Planner Selection\n\n`move_base` uses a plugin-based architecture for both global and local planners. You must specify which plugins to use:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `base_global_planner` | string | \"navfn/NavfnROS\" | The plugin to use for global planning |\n| `base_local_planner` | string | \"base_local_planner/TrajectoryPlannerROS\" | The plugin to use for local planning |\n\nWhen you change these parameters, `move_base` will unload the current planner and load the new one.\n\nSources: [move_base/cfg/MoveBase.cfg:9-10](), [move_base/src/move_base.cpp:224-267]()\n\n## Frequency Control\n\nThese parameters determine how often the planning and control loops run:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `planner_frequency` | double | 0.0 | Rate in Hz for the planning loop (0.0 means planning only when needed) |\n| `controller_frequency` | double | 20.0 | Rate in Hz for the control loop that sends velocity commands |\n\nSources: [move_base/cfg/MoveBase.cfg:14-15](), [move_base/src/move_base.cpp:74-75]()\n\n## Patience and Retry Settings\n\nThese parameters control how long `move_base` will try to find a path before initiating recovery behaviors:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `planner_patience` | double | 5.0 | Seconds to wait for a valid plan before space-clearing |\n| `controller_patience` | double | 15.0 | Seconds to wait for valid control before space-clearing |\n| `max_planning_retries` | int | -1 | Maximum planning attempts before space-clearing (-1 for unlimited) |\n\nSources: [move_base/cfg/MoveBase.cfg:16-18](), [move_base/src/move_base.cpp:76-78]()\n\n## Recovery Behavior Configuration\n\nRecovery behaviors are executed when the robot gets stuck or can't find a valid plan:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `recovery_behavior_enabled` | bool | true | Whether to use recovery behaviors |\n| `clearing_rotation_allowed` | bool | true | Whether robot can rotate in place during recovery |\n| `conservative_reset_dist` | double | 3.0 | Distance in meters at which obstacles will be cleared during recovery |\n| `shutdown_costmaps` | bool | false | Whether to shutdown costmaps when move_base is inactive |\n\n```mermaid\nflowchart LR\n    subgraph \"Recovery Behavior Sequence\"\n        S[\"Start\"] --\u003e R1[\"conservative_reset\"]\n        R1 --\u003e R2[\"rotate_recovery\"]\n        R2 --\u003e R3[\"aggressive_reset\"]\n        R3 --\u003e E[\"If still stuck, abort\"]\n    end\n    \n    subgraph \"MoveBase State Machine\"\n        PLANNING[\"PLANNING State\"]\n        CONTROLLING[\"CONTROLLING State\"]\n        CLEARING[\"CLEARING State\"]\n        \n        PLANNING --\u003e|\"Valid plan\"| CONTROLLING\n        CONTROLLING --\u003e|\"Can't execute plan\"| PLANNING\n        PLANNING --\u003e|\"Can't find plan\"| CLEARING\n        CONTROLLING --\u003e|\"Stuck/Oscillating\"| CLEARING\n        CLEARING --\u003e|\"Recovery successful\"| PLANNING\n    end\n    \n    CLEARING --\u003e R1\n```\n\nSources: [move_base/cfg/MoveBase.cfg:21-24](), [move_base/src/move_base.cpp:115-117](), [move_base/include/move_base/move_base.h:66-77]()\n\n### Custom Recovery Behaviors\n\nYou can specify custom recovery behaviors in your launch file by setting the `recovery_behaviors` parameter as an array of behavior specifications:\n\n```xml\n\u003crosparam param=\"move_base/recovery_behaviors\"\u003e[\n  {name: conservative_reset, type: clear_costmap_recovery/ClearCostmapRecovery},\n  {name: rotate_recovery, type: rotate_recovery/RotateRecovery},\n  {name: aggressive_reset, type: clear_costmap_recovery/ClearCostmapRecovery}\n]\u003c/rosparam\u003e\n```\n\nEach behavior must implement the `nav_core::RecoveryBehavior` interface.\n\nSources: [move_base/src/move_base.cpp:163-166]()\n\n## Oscillation Control\n\nThese parameters prevent the robot from getting stuck in a loop:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `oscillation_timeout` | double | 0.0 | Seconds to allow oscillation before recovery (0.0 to disable) |\n| `oscillation_distance` | double | 0.5 | Distance in meters robot must move to reset oscillation timer |\n\nSources: [move_base/cfg/MoveBase.cfg:26-27](), [move_base/src/move_base.cpp:80-81](), [move_base/src/move_base.cpp:817-826]()\n\n## Service Behavior Control\n\nThese parameters configure how the `make_plan` service behaves:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `make_plan_clear_costmap` | bool | true | Whether to clear costmap when service is called |\n| `make_plan_add_unreachable_goal` | bool | true | Whether to add unreachable goal to path |\n\nSources: [move_base/cfg/MoveBase.cfg:29-30](), [move_base/src/move_base.cpp:84-85](), [move_base/src/move_base.cpp:350-445]()\n\n## Costmap Configuration\n\n`move_base` uses two costmap instances:\n\n1. **Global Costmap**: Used by the global planner to create long-term paths\n2. **Local Costmap**: Used by the local planner for obstacle avoidance\n\nEach costmap has its own set of parameters under the `global_costmap` and `local_costmap` namespaces. For details on costmap configuration, see [Costmap2DROS](#2.1).\n\nCommon costmap parameters that affect move_base behavior:\n\n| Parameter | Related move_base parameter | Notes |\n|-----------|---------------------------|-------|\n| `global_costmap/robot_base_frame` | `robot_base_frame_` | Frame ID of the robot base |\n| `global_costmap/global_frame` | `global_frame_` | Global reference frame for planning |\n| `local_costmap/inscribed_radius` | `inscribed_radius_` | Radius of the inscribed circle of the robot |\n| `local_costmap/circumscribed_radius` | `circumscribed_radius_` | Radius of the circumscribed circle of the robot |\n\nSources: [move_base/src/move_base.cpp:72-73](), [move_base/src/move_base.cpp:110-112]()\n\n## Dynamic Reconfiguration\n\nAll of the parameters above can be dynamically reconfigured at runtime using ROS's dynamic_reconfigure framework:\n\n```mermaid\nsequenceDiagram\n    participant User as \"User/Node\"\n    participant DRS as \"Dynamic Reconfigure Server\"\n    participant MB as \"MoveBase\"\n    participant GP as \"Global Planner Plugin\"\n    participant LP as \"Local Planner Plugin\"\n    \n    User-\u003e\u003eDRS: \"Set parameter (e.g., planner_frequency)\"\n    DRS-\u003e\u003eMB: \"reconfigureCB(config, level)\"\n    \n    alt Change planner_frequency\n        MB-\u003e\u003eMB: \"planner_frequency_ = config.planner_frequency\"\n        MB-\u003e\u003eMB: \"p_freq_change_ = true\"\n    else Change controller_frequency\n        MB-\u003e\u003eMB: \"controller_frequency_ = config.controller_frequency\"\n        MB-\u003e\u003eMB: \"c_freq_change_ = true\"\n    else Change base_global_planner\n        MB-\u003e\u003eGP: \"Unload old planner\"\n        MB-\u003e\u003eMB: \"Reset plans and state\"\n        MB-\u003e\u003eGP: \"Load and initialize new planner\"\n    else Change base_local_planner\n        MB-\u003e\u003eLP: \"Unload old planner\"\n        MB-\u003e\u003eMB: \"Reset plans and state\"\n        MB-\u003e\u003eLP: \"Load and initialize new planner\"\n    end\n```\n\nSources: [move_base/src/move_base.cpp:177-273]()\n\nYou can use the `rqt_reconfigure` tool to dynamically adjust these parameters:\n\n```bash\nrosrun rqt_reconfigure rqt_reconfigure\n```\n\n## Example Configuration\n\nHere's a complete example of `move_base` parameters in a launch file:\n\n```xml\n\u003cnode pkg=\"move_base\" type=\"move_base\" respawn=\"false\" name=\"move_base\" output=\"screen\"\u003e\n  \u003c!-- Planner selection --\u003e\n  \u003cparam name=\"base_global_planner\" value=\"navfn/NavfnROS\"/\u003e\n  \u003cparam name=\"base_local_planner\" value=\"dwa_local_planner/DWAPlannerROS\"/\u003e\n  \n  \u003c!-- Frequency control --\u003e\n  \u003cparam name=\"planner_frequency\" value=\"1.0\"/\u003e\n  \u003cparam name=\"controller_frequency\" value=\"5.0\"/\u003e\n  \n  \u003c!-- Patience settings --\u003e\n  \u003cparam name=\"planner_patience\" value=\"5.0\"/\u003e\n  \u003cparam name=\"controller_patience\" value=\"15.0\"/\u003e\n  \u003cparam name=\"max_planning_retries\" value=\"10\"/\u003e\n  \n  \u003c!-- Recovery behavior --\u003e\n  \u003cparam name=\"recovery_behavior_enabled\" value=\"true\"/\u003e\n  \u003cparam name=\"clearing_rotation_allowed\" value=\"true\"/\u003e\n  \u003cparam name=\"conservative_reset_dist\" value=\"3.0\"/\u003e\n  \n  \u003c!-- Oscillation control --\u003e\n  \u003cparam name=\"oscillation_timeout\" value=\"10.0\"/\u003e\n  \u003cparam name=\"oscillation_distance\" value=\"0.5\"/\u003e\n  \n  \u003c!-- Costmap configurations --\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/global_costmap_params.yaml\" command=\"load\" /\u003e\n  \u003crosparam file=\"$(find my_robot_navigation)/config/local_costmap_params.yaml\" command=\"load\" /\u003e\n\u003c/node\u003e\n```\n\nSources: [costmap_2d/test/simple_driving_test.xml:1-14](), [costmap_2d/test/costmap_params.yaml:1-30]()\n\n## Debugging Configuration Issues\n\nCommon configuration issues and how to resolve them:\n\n1. **Robot not moving**: Check controller_frequency and planner_frequency. If set too low, the robot may not respond quickly.\n\n2. **Excessive oscillation**: Adjust oscillation_timeout and oscillation_distance parameters.\n\n3. **Getting stuck frequently**: Ensure recovery_behavior_enabled is true and review costmap parameters.\n\n4. **Slow navigation**: Tune the patience parameters to make the system less patient or the frequency parameters to make it more responsive.\n\n5. **Parameter changes not taking effect**: Some parameters (like planner plugins) require restarting the node to take effect if changed outside of dynamic reconfiguration.\n\nSources: [move_base/src/move_base.cpp:682-794]()\n\n## Summary\n\nProperly configuring `move_base` is critical for effective navigation. Start with the default values provided above and fine-tune based on your robot's behavior in the environment. Most parameters can be adjusted at runtime using dynamic reconfiguration, allowing for iterative optimization.\n\nFor more advanced navigation strategies, consider creating different parameter sets for different environments or navigation scenarios, and switching between them as needed."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"24:T5460,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Global Planners\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [carrot_planner/include/carrot_planner/carrot_planner.h](carrot_planner/include/carrot_planner/carrot_planner.h)\n- [carrot_planner/src/carrot_planner.cpp](carrot_planner/src/carrot_planner.cpp)\n- [global_planner/include/global_planner/astar.h](global_planner/include/global_planner/astar.h)\n- [global_planner/include/global_planner/dijkstra.h](global_planner/include/global_planner/dijkstra.h)\n- [global_planner/include/global_planner/expander.h](global_planner/include/global_planner/expander.h)\n- [global_planner/include/global_planner/gradient_path.h](global_planner/include/global_planner/gradient_path.h)\n- [global_planner/include/global_planner/grid_path.h](global_planner/include/global_planner/grid_path.h)\n- [global_planner/include/global_planner/planner_core.h](global_planner/include/global_planner/planner_core.h)\n- [global_planner/include/global_planner/traceback.h](global_planner/include/global_planner/traceback.h)\n- [global_planner/src/astar.cpp](global_planner/src/astar.cpp)\n- [global_planner/src/dijkstra.cpp](global_planner/src/dijkstra.cpp)\n- [global_planner/src/gradient_path.cpp](global_planner/src/gradient_path.cpp)\n- [global_planner/src/grid_path.cpp](global_planner/src/grid_path.cpp)\n- [global_planner/src/plan_node.cpp](global_planner/src/plan_node.cpp)\n- [global_planner/src/planner_core.cpp](global_planner/src/planner_core.cpp)\n- [nav_core/include/nav_core/base_global_planner.h](nav_core/include/nav_core/base_global_planner.h)\n- [nav_core/include/nav_core/base_local_planner.h](nav_core/include/nav_core/base_local_planner.h)\n- [nav_core/include/nav_core/recovery_behavior.h](nav_core/include/nav_core/recovery_behavior.h)\n- [navfn/include/navfn/navfn_ros.h](navfn/include/navfn/navfn_ros.h)\n- [navfn/src/navfn_ros.cpp](navfn/src/navfn_ros.cpp)\n\n\u003c/details\u003e\n\n\n\nGlobal Planners are components of the ROS Navigation Stack responsible for generating a path from the robot's current position to a goal position. These planners work with the global costmap to produce a sequence of waypoints that navigate the robot efficiently to its destination while avoiding obstacles. Unlike Local Planners which generate velocity commands over short time horizons, Global Planners focus on the entire path from start to finish.\n\nFor information about how global planners interact with other components, see [Move Base](#3). For details on local planners, see [Local Planners](#5).\n\nSources: [nav_core/include/nav_core/base_global_planner.h:44-91]()\n\n## BaseGlobalPlanner Interface\n\nAll global planners in the navigation stack implement the `BaseGlobalPlanner` interface defined in the `nav_core` package. This interface specifies the methods that must be implemented by any global planner plugin.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n      \u003c\u003cinterface\u003e\u003e\n      +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n      +makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan) bool\n      +makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan, double\u0026 cost) bool\n    }\n    \n    class NavfnROS {\n      -costmap_2d::Costmap2D* costmap_\n      -boost::shared_ptr\u003cNavFn\u003e planner_\n      -bool initialized_\n      -bool allow_unknown_\n      +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n      +makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan) bool\n    }\n    \n    class GlobalPlanner {\n      -costmap_2d::Costmap2D* costmap_\n      -PotentialCalculator* p_calc_\n      -Expander* planner_\n      -Traceback* path_maker_\n      -OrientationFilter* orientation_filter_\n      -bool initialized_\n      +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n      +makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan) bool\n    }\n    \n    class CarrotPlanner {\n      -costmap_2d::Costmap2DROS* costmap_ros_\n      -costmap_2d::Costmap2D* costmap_\n      -base_local_planner::WorldModel* world_model_\n      -bool initialized_\n      +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n      +makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan) bool\n    }\n    \n    BaseGlobalPlanner \u003c|.. NavfnROS\n    BaseGlobalPlanner \u003c|.. GlobalPlanner\n    BaseGlobalPlanner \u003c|.. CarrotPlanner\n```\n\nThe key methods in this interface are:\n\n- `initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)`: Sets up the planner with a name and a reference to the costmap.\n- `makePlan(const geometry_msgs::PoseStamped\u0026 start, const geometry_msgs::PoseStamped\u0026 goal, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan)`: Generates a path from start pose to goal pose, storing the result in the plan vector.\n\nSources: [nav_core/include/nav_core/base_global_planner.h:44-91]()\n\n## Available Global Planner Implementations\n\nThe navigation stack includes three global planner implementations, each with different characteristics and use cases:\n\n| Planner | Algorithm | Characteristics | Best Use Case |\n|---------|-----------|-----------------|---------------|\n| NavfnROS | Navigation function (Dijkstra's algorithm) | Efficient and reliable for most environments | Default choice for general navigation |\n| GlobalPlanner | Configurable (Dijkstra's or A*) | Highly customizable with multiple algorithm options | When fine-tuned planning behavior is needed |\n| CarrotPlanner | Simple line-of-sight | Minimal computation, generates straight-line path | Simple scenarios with few obstacles |\n\nSources: [navfn/include/navfn/navfn_ros.h:52-186](), [global_planner/include/global_planner/planner_core.h:66-208](), [carrot_planner/include/carrot_planner/carrot_planner.h:52-106]()\n\n## NavfnROS\n\nThe `NavfnROS` planner is the original global planner implementation in the navigation stack. It creates a navigation function (potential field) over the costmap and follows its gradient to find a path.\n\n### Operation Workflow\n\n```mermaid\nflowchart TD\n    start[\"Initialize NavfnROS\"]\n    costmap[\"Get costmap from costmap_ros\"]\n    makePlan[\"makePlan called with start and goal\"]\n    checkFrames[\"Check if start and goal in global frame\"]\n    worldToMap[\"Convert start and goal to map coordinates\"]\n    clearRobot[\"Clear robot cell in costmap\"]\n    setupNavfn[\"Set up NavFn with costmap dimensions\"]\n    setCostmap[\"Load costmap data into NavFn\"]\n    setGoal[\"Set start and goal in NavFn (swapped due to planning direction)\"]\n    calcPath[\"Calculate path using Dijkstra's algorithm\"]\n    findValidGoal[\"Find valid goal point within tolerance\"]\n    extractPath[\"Extract path from potential field\"]\n    publishPlan[\"Publish plan for visualization\"]\n    returnPlan[\"Return plan to caller\"]\n    \n    start --\u003e costmap\n    costmap --\u003e makePlan\n    makePlan --\u003e checkFrames\n    checkFrames --\u003e worldToMap\n    worldToMap --\u003e clearRobot\n    clearRobot --\u003e setupNavfn\n    setupNavfn --\u003e setCostmap\n    setCostmap --\u003e setGoal\n    setGoal --\u003e calcPath\n    calcPath --\u003e findValidGoal\n    findValidGoal --\u003e extractPath\n    extractPath --\u003e publishPlan\n    publishPlan --\u003e returnPlan\n```\n\nKey methods:\n- `initialize`: Sets up the planner with a costmap and configures parameters.\n- `makePlan`: Calculates a path from start to goal.\n- `computePotential`: Computes the navigation function.\n- `getPlanFromPotential`: Extracts a path from the computed potential field.\n\nThe NavfnROS planner performs well in most environments and is the default choice for the navigation stack.\n\nSources: [navfn/src/navfn_ros.cpp:46-432]()\n\n## GlobalPlanner\n\nThe `GlobalPlanner` is a more flexible and configurable implementation that builds upon the concepts of NavfnROS. It provides multiple algorithm options and path extraction methods.\n\n### Architecture\n\n```mermaid\nclassDiagram\n    class GlobalPlanner {\n        -costmap_2d::Costmap2D* costmap_\n        -PotentialCalculator* p_calc_\n        -Expander* planner_\n        -Traceback* path_maker_\n        -OrientationFilter* orientation_filter_\n        -float* potential_array_\n        +initialize(string name, costmap_2d::Costmap2DROS* costmap_ros)\n        +makePlan(...) bool\n        -getPlanFromPotential(...) bool\n    }\n    \n    class PotentialCalculator {\n        \u003c\u003cabstract\u003e\u003e\n        +calculatePotential(float* potential, unsigned char cost, int n, float prev_potential) float\n    }\n    \n    class QuadraticCalculator {\n        +calculatePotential(float* potential, unsigned char cost, int n, float prev_potential) float\n    }\n    \n    class Expander {\n        \u003c\u003cabstract\u003e\u003e\n        +calculatePotentials(...) bool\n        +setSize(int nx, int ny)\n        +setLethalCost(unsigned char lethal_cost)\n        +setNeutralCost(unsigned char neutral_cost)\n    }\n    \n    class DijkstraExpansion {\n        +calculatePotentials(...) bool\n        -updateCell(unsigned char* costs, float* potential, int n)\n    }\n    \n    class AStarExpansion {\n        +calculatePotentials(...) bool\n        -add(unsigned char* costs, float* potential, float prev_potential, int next_i, int end_x, int end_y)\n    }\n    \n    class Traceback {\n        \u003c\u003cabstract\u003e\u003e\n        +getPath(float* potential, double start_x, double start_y, double end_x, double end_y, std::vector\u003cstd::pair\u003cfloat, float\u003e\u003e\u0026 path) bool\n    }\n    \n    class GridPath {\n        +getPath(...) bool\n    }\n    \n    class GradientPath {\n        -float* gradx_\n        -float* grady_\n        +getPath(...) bool\n        -gradCell(float* potential, int n) float\n    }\n    \n    class OrientationFilter {\n        +processPath(const geometry_msgs::PoseStamped\u0026 start, std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 path)\n    }\n    \n    GlobalPlanner --\u003e PotentialCalculator\n    GlobalPlanner --\u003e Expander\n    GlobalPlanner --\u003e Traceback\n    GlobalPlanner --\u003e OrientationFilter\n    \n    PotentialCalculator \u003c|-- QuadraticCalculator\n    Expander \u003c|-- DijkstraExpansion\n    Expander \u003c|-- AStarExpansion\n    Traceback \u003c|-- GridPath\n    Traceback \u003c|-- GradientPath\n```\n\nThe `GlobalPlanner` consists of several key components:\n\n1. **PotentialCalculator**: Computes potential values for cells. The default implementation is `QuadraticCalculator`.\n\n2. **Expander**: Propagates potential values across the grid. Two implementations are available:\n   - `DijkstraExpansion`: Uses Dijkstra's algorithm for broader search.\n   - `AStarExpansion`: Uses A* algorithm with a heuristic for more focused search.\n\n3. **Traceback**: Extracts a path from the potential field. Two options are available:\n   - `GridPath`: Follows grid cells with lowest potential, resulting in a more angular path.\n   - `GradientPath`: Follows the gradient of the potential field, producing a smoother path.\n\n4. **OrientationFilter**: Processes the final path to add orientation data to waypoints.\n\nThe `GlobalPlanner` is highly configurable through ROS parameters, including algorithm selection, cost factors, and various behavior options.\n\nSources: [global_planner/src/planner_core.cpp:52-437](), [global_planner/include/global_planner/planner_core.h:66-208](), [global_planner/include/global_planner/dijkstra.h:56-108](), [global_planner/include/global_planner/astar.h:63-72](), [global_planner/include/global_planner/gradient_path.h:47-75](), [global_planner/include/global_planner/grid_path.h:45-53]()\n\n## CarrotPlanner\n\nThe `CarrotPlanner` is a simple, straightforward planner that doesn't compute a complex path through obstacles. Instead, it attempts to find a valid point along the straight line between the robot and the goal.\n\n### Operation Workflow\n\n```mermaid\nsequenceDiagram\n    participant move_base as \"move_base\"\n    participant CarrotPlanner as \"CarrotPlanner\"\n    participant CostmapModel as \"base_local_planner::CostmapModel\"\n    \n    move_base-\u003e\u003eCarrotPlanner: makePlan(start, goal, plan)\n    CarrotPlanner-\u003e\u003eCarrotPlanner: Calculate vector from start to goal\n    CarrotPlanner-\u003e\u003eCarrotPlanner: Initialize target at goal position\n    loop Until valid point found or scale \u003c 0\n        CarrotPlanner-\u003e\u003eCarrotPlanner: Scale the vector (reduce distance)\n        CarrotPlanner-\u003e\u003eCarrotPlanner: Calculate new target position\n        CarrotPlanner-\u003e\u003eCostmapModel: footprintCost(target_x, target_y, target_yaw)\n        CostmapModel--\u003e\u003eCarrotPlanner: Return cost (collision or free)\n        alt Cost \u003e= 0 (valid point)\n            CarrotPlanner-\u003e\u003eCarrotPlanner: Set target as done\n        else Cost \u003c 0 (invalid point)\n            CarrotPlanner-\u003e\u003eCarrotPlanner: Reduce scale and try again\n        end\n    end\n    CarrotPlanner-\u003e\u003eCarrotPlanner: plan.push_back(start)\n    CarrotPlanner-\u003e\u003eCarrotPlanner: plan.push_back(target)\n    CarrotPlanner--\u003e\u003emove_base: Return plan\n```\n\nThe `CarrotPlanner` works by:\n1. Calculating a vector from start to goal\n2. Testing points along this vector, starting from the goal\n3. Moving progressively closer to the start until a valid (collision-free) point is found\n4. Creating a plan that simply consists of the start and the valid target point\n\nThis planner is useful in simple environments or as a fallback option when more complex planners fail.\n\nSources: [carrot_planner/src/carrot_planner.cpp:49-175]()\n\n## Integration with Navigation Stack\n\nGlobal planners are used by the `move_base` node to generate paths that the robot will follow. The planner to use is specified as a plugin through ROS parameters.\n\n```mermaid\nsequenceDiagram\n    participant ROS_Client as \"ROS Client\"\n    participant move_base as \"move_base\"\n    participant GlobalPlanner as \"BaseGlobalPlanner Plugin\"\n    participant LocalPlanner as \"BaseLocalPlanner Plugin\"\n    participant GlobalCostmap as \"Global Costmap\"\n    \n    ROS_Client-\u003e\u003emove_base: Send goal (MoveBaseAction)\n    activate move_base\n    \n    move_base-\u003e\u003eGlobalCostmap: Get current costmap\n    GlobalCostmap--\u003e\u003emove_base: Return costmap\n    \n    move_base-\u003e\u003emove_base: Get current robot pose\n    move_base-\u003e\u003eGlobalPlanner: makePlan(current_pose, goal, plan)\n    activate GlobalPlanner\n    \n    GlobalPlanner-\u003e\u003eGlobalCostmap: Query costmap data\n    GlobalCostmap--\u003e\u003eGlobalPlanner: Return costmap data\n    \n    GlobalPlanner-\u003e\u003eGlobalPlanner: Calculate path\n    GlobalPlanner--\u003e\u003emove_base: Return plan\n    deactivate GlobalPlanner\n    \n    loop Until goal reached or failure\n        move_base-\u003e\u003eLocalPlanner: setPlan(global_plan)\n        move_base-\u003e\u003eLocalPlanner: computeVelocityCommands(cmd_vel)\n        LocalPlanner--\u003e\u003emove_base: Return velocity commands\n        move_base-\u003e\u003eROS_Client: Publish feedback\n        \n        alt Plan needs to be replanned\n            move_base-\u003e\u003eGlobalPlanner: makePlan(current_pose, goal, plan)\n            GlobalPlanner--\u003e\u003emove_base: Return updated plan\n        end\n    end\n    \n    move_base-\u003e\u003eROS_Client: Send result (success/failure)\n    deactivate move_base\n```\n\nTo configure which global planner to use, set the `base_global_planner` parameter in the `move_base` node configuration:\n\n```xml\n\u003cparam name=\"base_global_planner\" value=\"navfn/NavfnROS\"/\u003e\n\u003c!-- OR --\u003e\n\u003cparam name=\"base_global_planner\" value=\"global_planner/GlobalPlanner\"/\u003e\n\u003c!-- OR --\u003e\n\u003cparam name=\"base_global_planner\" value=\"carrot_planner/CarrotPlanner\"/\u003e\n```\n\nSources: [nav_core/include/nav_core/base_global_planner.h:44-91]()\n\n## Configuration Parameters\n\n### NavfnROS Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `allow_unknown` | bool | true | Whether to allow planning through unknown space |\n| `planner_window_x` | double | 0.0 | Size of the x window in meters to restrict planning (0.0 means no restriction) |\n| `planner_window_y` | double | 0.0 | Size of the y window in meters to restrict planning (0.0 means no restriction) |\n| `default_tolerance` | double | 0.0 | Goal tolerance in meters |\n| `visualize_potential` | bool | false | Whether to publish the potential field for visualization |\n\nSources: [navfn/src/navfn_ros.cpp:63-89]()\n\n### GlobalPlanner Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `old_navfn_behavior` | bool | false | Whether to use the old NavFn behavior for compatibility |\n| `use_quadratic` | bool | true | Whether to use the quadratic potential calculator |\n| `use_dijkstra` | bool | true | Whether to use Dijkstra's algorithm (true) or A* (false) |\n| `use_grid_path` | bool | false | Whether to use grid path (true) or gradient path (false) |\n| `allow_unknown` | bool | true | Whether to allow planning through unknown space |\n| `planner_window_x` | double | 0.0 | Size of the x window to restrict planning |\n| `planner_window_y` | double | 0.0 | Size of the y window to restrict planning |\n| `default_tolerance` | double | 0.0 | Goal tolerance |\n| `lethal_cost` | int | 253 | Cost at which a cell is considered lethal |\n| `neutral_cost` | int | 50 | Cost factor for neutral cells |\n| `cost_factor` | float | 3.0 | Factor to scale the cost |\n| `orientation_mode` | int | 0 | Mode for setting orientations (0=None, 1=Forward, 2=Interpolate, 3=ForwardThenInterpolate, 4=Backward, 5=Leftward, 6=Rightward) |\n| `orientation_window_size` | int | 1 | Window size for orientation filter |\n\nSources: [global_planner/src/planner_core.cpp:92-169]()\n\n### CarrotPlanner Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `step_size` | double | costmap resolution | Size of steps to take when checking for a valid point |\n| `min_dist_from_robot` | double | 0.10 | Minimum distance from the robot to consider a point valid |\n\nSources: [carrot_planner/src/carrot_planner.cpp:62-72]()\n\n## Comparison and Selection Guidelines\n\nWhen selecting a global planner for your application, consider the following factors:\n\n| Planner | Strengths | Limitations | When to Use |\n|---------|-----------|-------------|-------------|\n| NavfnROS | - Reliable in most environments\u003cbr\u003e- Efficient computation\u003cbr\u003e- Robust implementation | - Less customizable\u003cbr\u003e- Limited configuration options | - Default choice for most applications\u003cbr\u003e- When reliability is important |\n| GlobalPlanner | - Highly configurable\u003cbr\u003e- Multiple algorithm options\u003cbr\u003e- Path smoothness control\u003cbr\u003e- Orientation filtering | - More complex configuration\u003cbr\u003e- Potentially higher computational cost | - When specific path characteristics are needed\u003cbr\u003e- When NavfnROS doesn't perform well\u003cbr\u003e- For customizing orientation handling |\n| CarrotPlanner | - Extremely simple\u003cbr\u003e- Minimal computation\u003cbr\u003e- Fast response | - No obstacle avoidance\u003cbr\u003e- Only works in simple environments | - As a fallback planner\u003cbr\u003e- In very simple environments\u003cbr\u003e- For debugging or testing |\n\nFor most applications, `NavfnROS` or `GlobalPlanner` are recommended. The `CarrotPlanner` should generally be used only in specific scenarios where a simple path is sufficient or as a fallback option.\n\nSources: [navfn/src/navfn_ros.cpp](), [global_planner/src/planner_core.cpp](), [carrot_planner/src/carrot_planner.cpp]()\n\n## Troubleshooting\n\n### Common Issues and Solutions\n\n| Issue | Possible Causes | Solutions |\n|-------|----------------|-----------|\n| Planner fails to find a path | - Goal in obstacle/unreachable area\u003cbr\u003e- Inflation radius too large\u003cbr\u003e- Costmap issues | - Check if goal is in valid area\u003cbr\u003e- Reduce inflation radius\u003cbr\u003e- Set `allow_unknown` to true if appropriate |\n| Path is not optimal | - Cost parameters need tuning\u003cbr\u003e- Using wrong algorithm\u003cbr\u003e- Path extraction method not optimal | - Adjust cost parameters\u003cbr\u003e- Switch between Dijkstra and A*\u003cbr\u003e- Try different path extraction (grid vs. gradient) |\n| Planning takes too long | - Map too large\u003cbr\u003e- Too many obstacles\u003cbr\u003e- Using Dijkstra on large maps | - Reduce costmap size/resolution\u003cbr\u003e- Use A* instead of Dijkstra\u003cbr\u003e- Increase lethal cost to avoid exploring unnecessary areas |\n| Path oscillates or changes frequently | - Costmap updates too frequent\u003cbr\u003e- Sensor noise\u003cbr\u003e- Planning triggering too often | - Adjust costmap update frequency\u003cbr\u003e- Filter sensor data\u003cbr\u003e- Adjust replanning frequency |\n| Robot doesn't follow plan properly | - Plan may be valid but difficult to follow\u003cbr\u003e- Local planner issues | - Switch to GradientPath for smoother paths\u003cbr\u003e- Use orientation filtering\u003cbr\u003e- Check local planner configuration |\n\nSources: [navfn/src/navfn_ros.cpp:193-340](), [global_planner/src/planner_core.cpp:213-322]()\n\n## Conclusion\n\nThe ROS Navigation Stack provides three global planner implementations, each with different strengths and use cases. The `NavfnROS` planner offers a reliable solution for most navigation tasks, while the `GlobalPlanner` provides more flexibility and configuration options. The `CarrotPlanner` offers a simple alternative for basic scenarios.\n\nUnderstanding the characteristics and configuration options of each planner allows you to select the most appropriate one for your robot's navigation requirements. In most cases, starting with the default `NavfnROS` planner and then moving to `GlobalPlanner` if more customization is needed provides a good approach.\n\nFor more information on how global planners interact with the rest of the navigation stack, refer to the [Move Base](#3) page, which details the central coordination node that utilizes these planners.\n\nSources: [navfn/src/navfn_ros.cpp](), [global_planner/src/planner_core.cpp](), [carrot_planner/src/carrot_planner.cpp]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"25:T2839,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Navfn\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [carrot_planner/include/carrot_planner/carrot_planner.h](carrot_planner/include/carrot_planner/carrot_planner.h)\n- [carrot_planner/src/carrot_planner.cpp](carrot_planner/src/carrot_planner.cpp)\n- [nav_core/include/nav_core/base_global_planner.h](nav_core/include/nav_core/base_global_planner.h)\n- [nav_core/include/nav_core/base_local_planner.h](nav_core/include/nav_core/base_local_planner.h)\n- [nav_core/include/nav_core/recovery_behavior.h](nav_core/include/nav_core/recovery_behavior.h)\n- [navfn/include/navfn/navfn_ros.h](navfn/include/navfn/navfn_ros.h)\n- [navfn/src/navfn_ros.cpp](navfn/src/navfn_ros.cpp)\n\n\u003c/details\u003e\n\n\n\nNavfn is a global path planner for the ROS navigation stack that implements the navigation function approach to path planning. It provides efficient path finding between start and goal poses by using Dijkstra's algorithm to compute the shortest path across a costmap. Navfn serves as one of the primary global planners in the system, alongside the more configurable Global Planner (see [Global Planner](#4.2)) and the simpler Carrot Planner (see [Carrot Planner](#4.3)).\n\n## Overview\n\nNavfn implements a fast, interpolated navigation function on a costmap. It uses a wavefront propagation algorithm (specifically Dijkstra's algorithm) to compute paths that efficiently navigate around obstacles while maintaining optimality. The planning component includes both a core navigation function implementation (`NavFn`) and a ROS wrapper (`NavfnROS`) that interfaces with the rest of the navigation stack.\n\n```mermaid\ngraph TD\n    subgraph \"Navigation Stack Components\"\n        MB[\"move_base\"]\n        COST[\"costmap_2d\"]\n        LP[\"Local Planners\"]\n    end\n    \n    subgraph \"Global Planners\"\n        BGP[\"nav_core::BaseGlobalPlanner\"]\n        NF[\"NavfnROS\"]\n        GP[\"global_planner::GlobalPlanner\"]\n        CP[\"carrot_planner::CarrotPlanner\"]\n    end\n    \n    BGP --\u003e NF\n    BGP --\u003e GP\n    BGP --\u003e CP\n    \n    MB --\u003e BGP\n    NF --\u003e COST\n    NF --\u003e NFCore[\"NavFn (Core Implementation)\"]\n    \n    NF -. \"provides path\" .-\u003e LP\n```\n\nDiagram: Navfn in the Navigation Stack Architecture\n\nSources: [navfn/include/navfn/navfn_ros.h:52-56](), [nav_core/include/nav_core/base_global_planner.h:44-48]()\n\n## NavfnROS Class\n\nThe `NavfnROS` class serves as the interface between the navigation stack and the core navigation function algorithm. It implements the `BaseGlobalPlanner` interface defined in the `nav_core` package, making it usable as a plugin for the `move_base` node.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(string name, Costmap2DROS* costmap_ros)\n        +makePlan(PoseStamped start, PoseStamped goal, vector\u003cPoseStamped\u003e\u0026 plan) bool\n    }\n    \n    class NavfnROS {\n        -Costmap2D* costmap_\n        -shared_ptr\u003cNavFn\u003e planner_\n        -bool initialized_\n        -bool allow_unknown_\n        -bool visualize_potential_\n        -double default_tolerance_\n        +NavfnROS()\n        +NavfnROS(string name, Costmap2DROS* costmap_ros)\n        +initialize(string name, Costmap2DROS* costmap_ros)\n        +makePlan(PoseStamped start, PoseStamped goal, vector\u003cPoseStamped\u003e\u0026 plan) bool\n        +makePlan(PoseStamped start, PoseStamped goal, double tolerance, vector\u003cPoseStamped\u003e\u0026 plan) bool\n        +computePotential(Point\u0026 world_point) bool\n        +getPlanFromPotential(PoseStamped\u0026 goal, vector\u003cPoseStamped\u003e\u0026 plan) bool\n    }\n    \n    BaseGlobalPlanner \u003c|-- NavfnROS\n```\n\nDiagram: NavfnROS Class Structure\n\nSources: [navfn/include/navfn/navfn_ros.h:52-185](), [nav_core/include/nav_core/base_global_planner.h:48-90]()\n\n### Key Methods\n\nThe NavfnROS class provides several important methods:\n\n1. **initialize** - Sets up the planner with a costmap and parameters\n   ```cpp\n   void initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros);\n   ```\n\n2. **makePlan** - Computes a path from start to goal\n   ```cpp\n   bool makePlan(const geometry_msgs::PoseStamped\u0026 start, \n                const geometry_msgs::PoseStamped\u0026 goal, \n                std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan);\n   ```\n\n3. **computePotential** - Computes the navigation function (potential field)\n   ```cpp\n   bool computePotential(const geometry_msgs::Point\u0026 world_point);\n   ```\n\n4. **getPlanFromPotential** - Extracts a path from the computed potential field\n   ```cpp\n   bool getPlanFromPotential(const geometry_msgs::PoseStamped\u0026 goal, \n                            std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan);\n   ```\n\nSources: [navfn/include/navfn/navfn_ros.h:83-127]()\n\n## Path Planning Process\n\nThe path planning process in Navfn consists of the following steps:\n\n```mermaid\nsequenceDiagram\n    participant MB as move_base\n    participant NFROS as NavfnROS\n    participant NF as NavFn\n    participant CM as Costmap2D\n    \n    MB-\u003e\u003eNFROS: makePlan(start, goal)\n    NFROS-\u003e\u003eCM: getCostmap()\n    NFROS-\u003e\u003eCM: worldToMap(start)\n    NFROS-\u003e\u003eCM: worldToMap(goal)\n    NFROS-\u003e\u003eNF: setNavArr(costmap size)\n    NFROS-\u003e\u003eNF: setCostmap(costmap data)\n    NFROS-\u003e\u003eNF: setStart(goal position)\n    NFROS-\u003e\u003eNF: setGoal(start position)\n    NFROS-\u003e\u003eNF: calcNavFnDijkstra()\n    \n    Note over NFROS,NF: Note the reversed start/goal in internal NavFn call\n    \n    loop Find valid goal point\n        NFROS-\u003e\u003eNFROS: Check potential around goal\n    end\n    \n    alt Valid goal found\n        NFROS-\u003e\u003eNF: setStart(goal)\n        NFROS-\u003e\u003eNF: calcPath()\n        NFROS-\u003e\u003eNF: getPathX(), getPathY()\n        NFROS-\u003e\u003eNFROS: Convert path to world coordinates\n    end\n    \n    NFROS-\u003e\u003eMB: Return path\n```\n\nDiagram: Navfn Path Planning Process\n\nSources: [navfn/src/navfn_ros.cpp:193-341](), [navfn/src/navfn_ros.cpp:370-431]()\n\n### Planning Algorithm\n\nNavfn uses Dijkstra's algorithm to compute the shortest path through the costmap. The implementation has these noteworthy characteristics:\n\n1. The algorithm operates on a grid-based representation of the environment (costmap).\n2. It computes a potential field (navigation function) that represents the distance to the goal from any point.\n3. It uses a reversed approach where the algorithm treats the goal as the source and the start as the destination.\n4. Once the potential field is computed, the path is extracted by gradient descent from the start to the goal.\n\nSources: [navfn/src/navfn_ros.cpp:260-264](), [navfn/src/navfn_ros.cpp:402-408]()\n\n## Configuration Parameters\n\nNavfnROS can be configured with the following parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `allow_unknown` | bool | true | Whether to allow planning through unknown space |\n| `planner_window_x` | double | 0.0 | Size of the x-window to use (in meters) |\n| `planner_window_y` | double | 0.0 | Size of the y-window to use (in meters) |\n| `default_tolerance` | double | 0.0 | Goal tolerance in meters |\n| `visualize_potential` | bool | false | Whether to publish the potential array for visualization |\n\nSources: [navfn/src/navfn_ros.cpp:69-82]()\n\n## Usage\n\nNavfn can be used as a plugin for the `move_base` node by specifying it in the configuration. Here's an example of how to specify Navfn as the global planner in a launch file or parameter server:\n\n```xml\n\u003cparam name=\"base_global_planner\" value=\"navfn/NavfnROS\"/\u003e\n```\n\n### Service Interface\n\nNavfnROS also provides a service interface to compute plans:\n\n```\n/make_plan (nav_msgs/GetPlan)\n```\n\nThis allows clients to request paths without going through the full `move_base` action interface.\n\nSources: [navfn/src/navfn_ros.cpp:84](), [navfn/src/navfn_ros.cpp:179-186]()\n\n## Visualization\n\nWhen the `visualize_potential` parameter is set to true, NavfnROS publishes the computed potential field as a PointCloud2 message on the `potential` topic. This can be useful for debugging and understanding how the planner is working.\n\n```mermaid\nflowchart LR\n    NF[\"NavfnROS\"] -- \"nav_msgs/Path\" --\u003e P[\"plan topic\"]\n    NF -- \"sensor_msgs/PointCloud2\" --\u003e V[\"potential topic\"]\n    NF -- \"service\" --\u003e S[\"make_plan\"]\n```\n\nDiagram: Navfn Output Interfaces\n\nSources: [navfn/src/navfn_ros.cpp:71](), [navfn/src/navfn_ros.cpp:76-77](), [navfn/src/navfn_ros.cpp:303-335]()\n\n## Implementation Details\n\n### Path Extraction\n\nAfter computing the potential field, the path is extracted by following the gradient of the potential from the start to the goal. The resulting path is a series of waypoints that represent the optimal path through the costmap.\n\nThe path extraction process converts the grid coordinates returned by the NavFn core algorithm back to world coordinates, and creates a vector of PoseStamped messages that can be used by the local planner.\n\nSources: [navfn/src/navfn_ros.cpp:404-425]()\n\n### Tolerance Handling\n\nThe planner supports a goal tolerance parameter that allows it to find a valid plan even if the exact goal location is in an obstacle. It searches around the goal location within the tolerance distance for a valid point with the lowest potential.\n\nSources: [navfn/src/navfn_ros.cpp:273-288]()\n\n### Reversed Start and Goal\n\nAn interesting implementation detail is that internally, the NavFn planner reverses the start and goal when calling the core algorithm. This is because the algorithm computes the distance from a source point to all other points, and it's more efficient to start from the goal and search for the start. When the path is extracted, it's reversed back to the correct order.\n\nSources: [navfn/src/navfn_ros.cpp:260-261](), [navfn/src/navfn_ros.cpp:410-425]()\n\n## Comparison with Other Planners\n\nNavfn is one of three global planners provided in the navigation stack:\n\n| Planner | Algorithm | Strengths | Weaknesses |\n|---------|-----------|-----------|------------|\n| Navfn | Dijkstra's | Fast, optimal paths | Limited configuration options |\n| Global Planner | A*/Dijkstra's | Highly configurable | More complex to set up |\n| Carrot Planner | Simple line search | Very simple, fast | Non-optimal, can get stuck |\n\nNavfn is a good default choice when you need efficient, optimal path planning without extensive customization.\n\nSources: [navfn/include/navfn/navfn_ros.h:52-56](), [carrot_planner/include/carrot_planner/carrot_planner.h:50-54]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"26:T30c9,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Global Planner\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [global_planner/include/global_planner/astar.h](global_planner/include/global_planner/astar.h)\n- [global_planner/include/global_planner/dijkstra.h](global_planner/include/global_planner/dijkstra.h)\n- [global_planner/include/global_planner/expander.h](global_planner/include/global_planner/expander.h)\n- [global_planner/include/global_planner/gradient_path.h](global_planner/include/global_planner/gradient_path.h)\n- [global_planner/include/global_planner/grid_path.h](global_planner/include/global_planner/grid_path.h)\n- [global_planner/include/global_planner/planner_core.h](global_planner/include/global_planner/planner_core.h)\n- [global_planner/include/global_planner/traceback.h](global_planner/include/global_planner/traceback.h)\n- [global_planner/src/astar.cpp](global_planner/src/astar.cpp)\n- [global_planner/src/dijkstra.cpp](global_planner/src/dijkstra.cpp)\n- [global_planner/src/gradient_path.cpp](global_planner/src/gradient_path.cpp)\n- [global_planner/src/grid_path.cpp](global_planner/src/grid_path.cpp)\n- [global_planner/src/plan_node.cpp](global_planner/src/plan_node.cpp)\n- [global_planner/src/planner_core.cpp](global_planner/src/planner_core.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Global Planner is a flexible implementation of a global path planner that computes paths from a start point to a goal point in a 2D grid costmap. It serves as an alternative to the Navfn planner (see [Navfn](#4.1)) with additional configuration options and algorithmic choices. The Global Planner finds the shortest path through a cost field representing the environment while avoiding obstacles.\n\n## 1. Overview\n\nThe Global Planner operates as a plugin to the ROS Navigation Stack, implementing the `nav_core::BaseGlobalPlanner` interface. The planner takes the start and goal poses, along with a costmap representation of the environment, and produces a path connecting these points.\n\n```mermaid\nflowchart TD\n    subgraph \"Global Planning Process\"\n        direction LR\n        START[\"Start Pose\"] --\u003e GP[\"GlobalPlanner\"]\n        COST[\"Costmap2D\"] --\u003e GP\n        GOAL[\"Goal Pose\"] --\u003e GP\n        GP --\u003e POT[\"Calculate Potential Field\"]\n        POT --\u003e EXTRACT[\"Extract Path\"]\n        EXTRACT --\u003e PATH[\"Path\"]\n    end\n```\n\nSources: [global_planner/src/planner_core.cpp:213-321](), [global_planner/include/global_planner/planner_core.h:102-114]()\n\nThe Global Planner is modular and offers multiple algorithm choices for different stages of the planning process. Unlike Navfn, the Global Planner allows switching between Dijkstra's algorithm and A* for computing the potential field, and between different methods for extracting a path from this field.\n\n## 2. Architecture\n\nThe Global Planner consists of several components that work together to create a path:\n\n```mermaid\nclassDiagram\n    class GlobalPlanner {\n        +initialize()\n        +makePlan()\n        +reconfigureCB()\n    }\n    \n    class PotentialCalculator {\n        +calculatePotential()\n    }\n    \n    class Expander {\n        \u003c\u003cabstract\u003e\u003e\n        +calculatePotentials()\n        +setSize()\n    }\n    \n    class Traceback {\n        \u003c\u003cabstract\u003e\u003e\n        +getPath()\n        +setSize()\n    }\n    \n    class OrientationFilter {\n        +processPath()\n    }\n    \n    class DijkstraExpansion {\n        +calculatePotentials()\n        +updateCell()\n    }\n    \n    class AStarExpansion {\n        +calculatePotentials()\n        +add()\n    }\n    \n    class GradientPath {\n        +getPath()\n        +gradCell()\n    }\n    \n    class GridPath {\n        +getPath()\n    }\n    \n    GlobalPlanner --\u003e \"1\" PotentialCalculator : uses\n    GlobalPlanner --\u003e \"1\" Expander : uses\n    GlobalPlanner --\u003e \"1\" Traceback : uses\n    GlobalPlanner --\u003e \"1\" OrientationFilter : uses\n    \n    Expander \u003c|-- DijkstraExpansion\n    Expander \u003c|-- AStarExpansion\n    \n    Traceback \u003c|-- GradientPath\n    Traceback \u003c|-- GridPath\n```\n\nSources: [global_planner/include/global_planner/planner_core.h:65-208](), [global_planner/src/planner_core.cpp:69-169]()\n\nThe main components are:\n\n1. **PotentialCalculator**: Calculates the potential values for cells in the grid\n2. **Expander**: Implements the search algorithm to calculate the potential field\n3. **Traceback**: Extracts a path from the potential field\n4. **OrientationFilter**: Adds orientation information to the path\n\n## 3. Core Components\n\n### 3.1 GlobalPlanner Class\n\nThe `GlobalPlanner` class serves as the main entry point and coordinates the planning process:\n\n```mermaid\nsequenceDiagram\n    participant MB as move_base\n    participant GP as GlobalPlanner\n    participant EX as Expander\n    participant TB as Traceback\n    participant OF as OrientationFilter\n    \n    MB-\u003e\u003eGP: makePlan(start, goal)\n    GP-\u003e\u003eGP: clearRobotCell()\n    GP-\u003e\u003eEX: calculatePotentials()\n    EX-\u003e\u003eGP: Return potential field\n    GP-\u003e\u003eTB: getPath()\n    TB-\u003e\u003eGP: Return path points\n    GP-\u003e\u003eOF: processPath()\n    OF-\u003e\u003eGP: Return path with orientations\n    GP-\u003e\u003eMB: Return completed path\n```\n\nSources: [global_planner/src/planner_core.cpp:213-321](), [global_planner/include/global_planner/planner_core.h:69-208]()\n\nKey methods:\n- `initialize()`: Sets up the planner components based on parameters\n- `makePlan()`: The main planning function that generates a path\n- `getPlanFromPotential()`: Extracts a path from the potential field\n\n### 3.2 Potential Calculation\n\nThe Global Planner uses a potential field approach where:\n- The goal has the lowest potential (0)\n- Obstacles have high potential (near infinity)\n- The potential gradually increases with distance from the goal\n\nThe planner offers two methods for calculating potentials:\n- **QuadraticCalculator**: Uses a quadratic distance formula (default)\n- **PotentialCalculator**: Uses a simpler linear distance formula\n\nSources: [global_planner/src/planner_core.cpp:110-115]()\n\n### 3.3 Expansion Methods\n\nTwo search algorithms are available for computing the potential field:\n\n1. **Dijkstra's Algorithm** (`DijkstraExpansion`): \n   - Breadth-first wavefront expansion from the goal\n   - Uses priority queues to efficiently manage the expansion\n   - Generally faster but generates less optimal paths\n\n2. **A* Algorithm** (`AStarExpansion`):\n   - Uses a heuristic to guide the search toward the start point\n   - Often finds more optimal paths but can be slower\n   - Uses a priority queue with Manhattan distance heuristic\n\n```mermaid\nflowchart LR\n    subgraph \"Dijkstra Expansion\"\n        direction TB\n        D_START[\"Start\"] --\u003e D_INIT[\"Initialize Potential Field\"]\n        D_INIT --\u003e D_QUEUE[\"Process Priority Queues\"]\n        D_QUEUE --\u003e D_UPDATE[\"Update Cell Potentials\"]\n        D_UPDATE --\u003e D_CHECK{\"Reached Start?\"}\n        D_CHECK --\u003e|\"No\"| D_QUEUE\n        D_CHECK --\u003e|\"Yes\"| D_END[\"Return Potential Field\"]\n    end\n    \n    subgraph \"A* Expansion\"\n        direction TB\n        A_START[\"Start\"] --\u003e A_INIT[\"Initialize Potential \u0026 Queue\"]\n        A_INIT --\u003e A_POP[\"Pop Best Cell\"]\n        A_POP --\u003e A_CHECK{\"Goal Found?\"}\n        A_CHECK --\u003e|\"Yes\"| A_END[\"Return Potential Field\"]\n        A_CHECK --\u003e|\"No\"| A_EXPAND[\"Expand Neighbors\"]\n        A_EXPAND --\u003e A_POP\n    end\n```\n\nSources: [global_planner/src/dijkstra.cpp:80-232](), [global_planner/src/astar.cpp:47-96]()\n\n### 3.4 Path Extraction\n\nAfter computing the potential field, the planner extracts a path using one of two methods:\n\n1. **Gradient Path** (`GradientPath`):\n   - Follows the gradient of the potential field from start to goal\n   - Creates smoother paths but more complex\n   - Uses interpolation between grid cells for more precise paths\n\n2. **Grid Path** (`GridPath`):\n   - Simple grid-based path following\n   - Always moves from one cell to a neighboring cell\n   - Faster but produces less smooth paths\n\nSources: [global_planner/src/gradient_path.cpp:68-234](), [global_planner/src/grid_path.cpp:43-82]()\n\n### 3.5 Orientation Filter\n\nThe `OrientationFilter` adds orientation information to the path points:\n- Can use different modes to calculate orientations\n- Smooths the path headings\n- Ensures the path is suitable for robot execution\n\nSources: [global_planner/src/planner_core.cpp:316]()\n\n## 4. Configuration\n\nThe Global Planner offers many configuration options through ROS parameters and dynamic reconfigure:\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `use_dijkstra` | Use Dijkstra's algorithm instead of A* | `true` |\n| `use_quadratic` | Use the quadratic potential calculator | `true` |\n| `use_grid_path` | Use grid path instead of gradient path | `false` |\n| `old_navfn_behavior` | Revert to navfn's behavior | `false` |\n| `lethal_cost` | Cost value considered lethal | `253` |\n| `neutral_cost` | Cost considered neutral | `50` |\n| `cost_factor` | Factor to scale cost values | `3.0` |\n| `publish_potential` | Whether to publish the potential grid | `false` |\n| `orientation_mode` | How to set path orientations | `0` |\n| `orientation_window_size` | Window size for orientation filter | `1` |\n\nSources: [global_planner/src/planner_core.cpp:102-169](), [global_planner/src/planner_core.cpp:162-169]()\n\n## 5. Integration with Navigation Stack\n\nThe Global Planner is designed to be used as a plugin within the Navigation Stack's move_base node:\n\n```mermaid\nflowchart LR\n    subgraph \"Navigation Stack Integration\"\n        direction TB\n        MB[\"move_base\"] --\u003e|\"requests path\"| GP[\"GlobalPlanner\"]\n        CM[\"costmap_2d\"] --\u003e|\"provides map\"| GP\n        GP --\u003e|\"returns path\"| MB\n        MB --\u003e|\"follows path with\"| LP[\"Local Planner\"]\n    end\n```\n\nTo configure move_base to use the Global Planner, set the following parameter:\n```\nbase_global_planner: \"global_planner/GlobalPlanner\"\n```\n\nSources: [global_planner/src/planner_core.cpp:39-50]()\n\n## 6. Algorithm Details\n\n### 6.1 Potential Field Calculation\n\nThe potential field is calculated by propagating values from the goal (lowest potential) outwards:\n\n1. Initialize the potential field with high values\n2. Set the goal potential to 0\n3. Expand the wavefront using either Dijkstra or A*\n4. Each cell's potential is calculated based on its cost and neighbors' potentials\n\nFor Dijkstra, the expansion uses three priority buffers to efficiently process cells in order of increasing potential.\n\nSources: [global_planner/src/dijkstra.cpp:80-180](), [global_planner/src/astar.cpp:47-77]()\n\n### 6.2 Path Extraction Process\n\nFor the gradient path method:\n1. Start at the start position\n2. Calculate the gradient at the current position\n3. Take a step in the direction of steepest descent\n4. Repeat until reaching the goal\n\n```mermaid\nflowchart TD\n    subgraph \"Gradient Path Extraction\"\n        direction TB\n        GP_START[\"Start at Initial Position\"] --\u003e GP_LOOP[\"For Each Step\"]\n        GP_LOOP --\u003e GP_GRAD[\"Calculate Gradient at Current Position\"]\n        GP_GRAD --\u003e GP_STEP[\"Take Step in Direction of Steepest Descent\"]\n        GP_STEP --\u003e GP_CHECK{\"Reached Goal?\"}\n        GP_CHECK --\u003e|\"No\"| GP_LOOP\n        GP_CHECK --\u003e|\"Yes\"| GP_END[\"Return Path\"]\n    end\n```\n\nSources: [global_planner/src/gradient_path.cpp:68-235]()\n\n## 7. Usage Example\n\nThe Global Planner can be used directly from code:\n\n```cpp\n// Create a global planner\nglobal_planner::GlobalPlanner planner;\n\n// Initialize it with costmap\nplanner.initialize(\"my_planner\", costmap, \"map\");\n\n// Create a plan\nstd::vector\u003cgeometry_msgs::PoseStamped\u003e path;\nplanner.makePlan(start, goal, path);\n```\n\nOr it can be accessed through a ROS service:\n\n```bash\nrosservice call /move_base/make_plan \"start:\n  header:\n    frame_id: 'map'\n  pose:\n    position: {x: 1.0, y: 1.0, z: 0.0}\n    orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\ngoal:\n  header:\n    frame_id: 'map'\n  pose:\n    position: {x: 5.0, y: 5.0, z: 0.0}\n    orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\"\n```\n\nSources: [global_planner/src/planner_core.cpp:183-189](), [global_planner/src/plan_node.cpp:67-79]()\n\n## 8. Summary\n\nThe Global Planner offers a flexible path planning solution for the ROS Navigation Stack with multiple algorithm choices and configuration options. It provides:\n\n1. Choice between Dijkstra and A* algorithms for potential field computation\n2. Different path extraction methods (gradient or grid-based)\n3. Configurable cost parameters\n4. Compatibility with the ROS Navigation Stack plugin architecture\n\nThis flexibility makes it suitable for a wide range of robotic navigation scenarios, from simple indoor navigation to more complex environments."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"27:T1e47,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Carrot Planner\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [carrot_planner/include/carrot_planner/carrot_planner.h](carrot_planner/include/carrot_planner/carrot_planner.h)\n- [carrot_planner/src/carrot_planner.cpp](carrot_planner/src/carrot_planner.cpp)\n- [nav_core/include/nav_core/base_global_planner.h](nav_core/include/nav_core/base_global_planner.h)\n- [nav_core/include/nav_core/base_local_planner.h](nav_core/include/nav_core/base_local_planner.h)\n- [nav_core/include/nav_core/recovery_behavior.h](nav_core/include/nav_core/recovery_behavior.h)\n- [navfn/include/navfn/navfn_ros.h](navfn/include/navfn/navfn_ros.h)\n- [navfn/src/navfn_ros.cpp](navfn/src/navfn_ros.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Carrot Planner is a simple global path planning plugin for the ROS Navigation Stack. It provides a straightforward approach to generating paths by finding a valid goal point that the local planner can navigate to. Unlike more sophisticated global planners like [Navfn](#4.1) or [Global Planner](#4.2) that create complete paths through complex environments, the Carrot Planner focuses on finding a single valid intermediate goal point.\n\n## Overview\n\nThe Carrot Planner gets its name from the metaphor of \"dangling a carrot\" in front of the robot. Instead of planning a complex path through the environment, it attempts to find a valid point along the straight line between the robot and the goal. If the goal is unreachable due to obstacles, the planner \"pulls back\" the goal along this line until it finds a valid position.\n\n```mermaid\nflowchart LR\n    A[\"Robot Start Position\"] --\u003e B[\"Carrot Planner\"]\n    G[\"Global Goal\"] --\u003e B\n    B --\u003e C[\"Adjusted Valid Goal\"]\n    C --\u003e D[\"Local Planner\"]\n    \n    subgraph \"Carrot Planning Process\"\n        direction TB\n        E[\"Calculate vector\\nfrom start to goal\"] --\u003e F[\"Search along vector\\nfor valid position\"]\n    end\n```\n\nSources: [carrot_planner/src/carrot_planner.cpp:95-173](), [carrot_planner/include/carrot_planner/carrot_planner.h:49-54]()\n\n## Implementation Details\n\nThe Carrot Planner is implemented as a plugin to the Navigation Stack's global planner framework. It inherits from the `nav_core::BaseGlobalPlanner` interface, making it a drop-in replacement for other global planners.\n\n```mermaid\nclassDiagram\n    class BaseGlobalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan) bool\n    }\n    \n    class CarrotPlanner {\n        -costmap_ros_: Costmap2DROS*\n        -costmap_: Costmap2D*\n        -world_model_: WorldModel*\n        -step_size_: double\n        -min_dist_from_robot_: double\n        -initialized_: bool\n        +initialize(name, costmap_ros)\n        +makePlan(start, goal, plan) bool\n        -footprintCost(x_i, y_i, theta_i) double\n    }\n    \n    BaseGlobalPlanner \u003c|-- CarrotPlanner\n```\n\nSources: [carrot_planner/include/carrot_planner/carrot_planner.h:54-105](), [nav_core/include/nav_core/base_global_planner.h:48-90]()\n\n### Algorithm\n\nThe algorithm works as follows:\n\n1. Calculate the vector (difference in position and orientation) from start to goal\n2. Start with the original goal position and orientation\n3. Check if the robot's footprint at this position is collision-free\n4. If not, scale back the vector from start to goal incrementally\n5. Continue until finding a valid position or reaching the start position\n6. Return a plan consisting of just two points: the start and the valid goal position\n\n```mermaid\nflowchart TD\n    A[\"Get start and goal poses\"] --\u003e B[\"Calculate vector from start to goal\"]\n    B --\u003e C[\"Set target = goal\"]\n    C --\u003e D{\"Is footprint at target\\nposition collision-free?\"}\n    D --\u003e|\"Yes\"| E[\"Plan found: return path\\n[start, target]\"]\n    D --\u003e|\"No\"| F[\"Scale back target towards start\"]\n    F --\u003e G{\"Scale \u003c 0?\"}\n    G --\u003e|\"Yes\"| H[\"No valid plan found:\\nreturn [start, start]\"]\n    G --\u003e|\"No\"| D\n```\n\nSources: [carrot_planner/src/carrot_planner.cpp:95-173]()\n\n### Key Classes and Methods\n\nThe `CarrotPlanner` class implements the following key methods:\n\n- **initialize**: Sets up the planner with the costmap and parameters\n  ```cpp\n  void initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros)\n  ```\n\n- **makePlan**: Generates a plan from start to goal\n  ```cpp\n  bool makePlan(const geometry_msgs::PoseStamped\u0026 start, \n                const geometry_msgs::PoseStamped\u0026 goal, \n                std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan)\n  ```\n\n- **footprintCost**: Checks if a position is valid based on the robot's footprint\n  ```cpp\n  double footprintCost(double x_i, double y_i, double theta_i)\n  ```\n\nSources: [carrot_planner/include/carrot_planner/carrot_planner.h:77-102](), [carrot_planner/src/carrot_planner.cpp:62-93]()\n\n## Configuration Parameters\n\nThe Carrot Planner is configured with the following parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `step_size` | double | Costmap resolution | Step size used in the search for a valid position |\n| `min_dist_from_robot` | double | 0.10 | Minimum distance (meters) the goal can be from the robot |\n\nThese parameters are loaded in the `initialize()` method:\n\n```cpp\nprivate_nh.param(\"step_size\", step_size_, costmap_-\u003egetResolution());\nprivate_nh.param(\"min_dist_from_robot\", min_dist_from_robot_, 0.10);\n```\n\nSources: [carrot_planner/src/carrot_planner.cpp:68-69]()\n\n## Integration with Navigation Stack\n\nThe Carrot Planner is registered as a plugin to the Navigation Stack using the `pluginlib` framework. This registration allows the planner to be loaded dynamically by the move_base node.\n\n```mermaid\nflowchart TB\n    subgraph \"Navigation Stack\"\n        A[\"move_base\"]\n        \n        subgraph \"Global Planners\"\n            B[\"nav_core::BaseGlobalPlanner\"]\n            B --\u003e C[\"NavfnROS\"]\n            B --\u003e D[\"GlobalPlanner\"]\n            B --\u003e E[\"CarrotPlanner\"]\n        end\n        \n        A --\u003e B\n        \n        subgraph \"Local Planners\"\n            F[\"nav_core::BaseLocalPlanner\"]\n        end\n        \n        A --\u003e F\n    end\n    \n    G[\"costmap_2d::Costmap2DROS\"] --\u003e A\n    E --\u003e H[\"base_local_planner::CostmapModel\"]\n```\n\nSources: [carrot_planner/src/carrot_planner.cpp:44-45](), [nav_core/include/nav_core/base_global_planner.h:48-90]()\n\n## Usage Example\n\nTo use the Carrot Planner with the Navigation Stack, you can set it as the global planner in your move_base configuration:\n\n```xml\n\u003cnode pkg=\"move_base\" type=\"move_base\" respawn=\"false\" name=\"move_base\" output=\"screen\"\u003e\n  \u003cparam name=\"base_global_planner\" value=\"carrot_planner/CarrotPlanner\"/\u003e\n  \u003c!-- Other parameters --\u003e\n\u003c/node\u003e\n```\n\n## When to Use\n\nThe Carrot Planner is particularly useful in the following scenarios:\n\n1. **Simple environments** with few obstacles\n2. **Edge cases** where more complex planners fail to find a path\n3. **Recovery behaviors** when other planners cannot generate a path\n4. **Testing and debugging** the navigation stack with a minimal planner\n\n## Limitations\n\nWhile the Carrot Planner is simple to use, it has several limitations:\n\n1. **No path optimization** - it simply generates a straight line to a valid goal point\n2. **May not find a path** when the goal is behind obstacles\n3. **Inefficient in complex environments** where a more sophisticated path is needed\n\n## Visualization\n\nThe planner returns a simple path consisting of two poses: the start and the adjusted goal. This path can be visualized in RViz as a straight line.\n\n```mermaid\ngraph LR\n    A[\"Robot\\nStart\"] --- B[\"Adjusted\\nGoal\"]\n    C[\"Original\\nGoal\"] -.-\u003e B\n    \n    style A fill:white\n    style B fill:white\n    style C fill:white\n```\n\nSources: [carrot_planner/src/carrot_planner.cpp:157-172]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"28:T3cd7,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Local Planners\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/include/base_local_planner/odometry_helper_ros.h](base_local_planner/include/base_local_planner/odometry_helper_ros.h)\n- [base_local_planner/include/base_local_planner/trajectory_planner.h](base_local_planner/include/base_local_planner/trajectory_planner.h)\n- [base_local_planner/include/base_local_planner/trajectory_planner_ros.h](base_local_planner/include/base_local_planner/trajectory_planner_ros.h)\n- [base_local_planner/src/odometry_helper_ros.cpp](base_local_planner/src/odometry_helper_ros.cpp)\n- [base_local_planner/src/trajectory_planner.cpp](base_local_planner/src/trajectory_planner.cpp)\n- [base_local_planner/src/trajectory_planner_ros.cpp](base_local_planner/src/trajectory_planner_ros.cpp)\n- [dwa_local_planner/cfg/DWAPlanner.cfg](dwa_local_planner/cfg/DWAPlanner.cfg)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner.h](dwa_local_planner/include/dwa_local_planner/dwa_planner.h)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h](dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h)\n- [dwa_local_planner/src/dwa_planner.cpp](dwa_local_planner/src/dwa_planner.cpp)\n- [dwa_local_planner/src/dwa_planner_ros.cpp](dwa_local_planner/src/dwa_planner_ros.cpp)\n\n\u003c/details\u003e\n\n\n\n## Overview\n\nLocal planners in the ROS navigation stack are responsible for calculating and executing the immediate motion commands required to move a robot along a global path while avoiding obstacles. Unlike global planners (covered in [Global Planners](#4)) which generate a full path from start to goal, local planners focus on short-term trajectory generation and obstacle avoidance.\n\nThe navigation stack includes two main local planner implementations:\n1. **TrajectoryPlannerROS** - A trajectory-based planner using the Trajectory Rollout approach\n2. **DWAPlannerROS** - A planner implementing the Dynamic Window Approach (DWA)\n\nBoth planners implement the same interface and can be swapped in the navigation configuration without changing other components.\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner_ros.h:62-230](), [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h:62-158]()\n\n## Local Planner Interface\n\nAll local planners in the navigation stack implement the `nav_core::BaseLocalPlanner` interface, which defines the standard methods required to function as a local planner plugin.\n\n### Local Planner Interface Diagram\n\n```mermaid\nclassDiagram\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n    }\n    \n    class TrajectoryPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n        +checkTrajectory(vx, vy, vtheta) bool\n        +scoreTrajectory(vx, vy, vtheta) double\n    }\n    \n    class DWAPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n        +dwaComputeVelocityCommands(pose, cmd_vel) bool\n    }\n    \n    BaseLocalPlanner \u003c|-- TrajectoryPlannerROS\n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n```\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner_ros.h:78-162](), [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h:66-122]()\n\nThe key methods of the BaseLocalPlanner interface are:\n- **initialize** - Sets up the planner with required resources\n- **setPlan** - Takes a global plan from a global planner as input\n- **computeVelocityCommands** - Generates velocity commands to execute\n- **isGoalReached** - Determines if the goal has been reached\n\n## Local Planner Architecture\n\nThe following diagram illustrates the overall architecture and data flow in the local planners:\n\n```mermaid\nflowchart TD\n    GP[\"Global Plan\"] --\u003e LP[\"Local Planner\"]\n    COSTMAP[\"Costmap2DROS\"] --\u003e LP\n    ODOMETRY[\"Odometry Data\"] --\u003e LP\n    \n    subgraph \"Local Planner Process\"\n        LP --\u003e UPD[\"Update Plan\"]\n        UPD --\u003e GEN[\"Generate Trajectories\"]\n        GEN --\u003e EVAL[\"Evaluate Trajectories\"]\n        EVAL --\u003e SELECT[\"Select Best Trajectory\"]\n        SELECT --\u003e VEL[\"Velocity Command\"]\n    end\n    \n    VEL --\u003e ROBOT[\"Robot Base\"]\n```\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:399-553](), [dwa_local_planner/src/dwa_planner_ros.cpp:264-312]()\n\n## TrajectoryPlannerROS\n\nThe TrajectoryPlannerROS (also called Trajectory Rollout) is the original local planner in the ROS navigation stack. It samples trajectories across the robot's velocity space and selects the optimal trajectory based on various cost functions.\n\n### TrajectoryPlannerROS Components\n\n```mermaid\nclassDiagram\n    class TrajectoryPlannerROS {\n        -TrajectoryPlanner* tc_\n        -WorldModel* world_model_\n        -costmap_2d::Costmap2DROS* costmap_ros_\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n        -generateTrajectory()\n        -scoreTrajectory()\n    }\n    \n    class TrajectoryPlanner {\n        -MapGrid path_map_\n        -MapGrid goal_map_\n        -Costmap2D costmap_\n        -WorldModel world_model_\n        +createTrajectories()\n        +generateTrajectory()\n        +findBestPath()\n        +checkTrajectory() bool\n        +scoreTrajectory() double\n    }\n    \n    class WorldModel {\n        \u003c\u003cinterface\u003e\u003e\n        +footprintCost() double\n    }\n    \n    class CostmapModel {\n        +footprintCost() double\n    }\n    \n    TrajectoryPlannerROS --\u003e TrajectoryPlanner : contains\n    TrajectoryPlannerROS --\u003e WorldModel : contains\n    WorldModel \u003c|-- CostmapModel\n```\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner_ros.h:78-229](), [base_local_planner/include/base_local_planner/trajectory_planner.h:66-382]()\n\n### Trajectory Generation Process\n\nThe TrajectoryPlannerROS generates trajectories by:\n\n1. Sampling various possible velocity commands (x, y, theta velocities)\n2. For each velocity sample, simulating the robot's motion over a short time period\n3. Checking each trajectory against the costmap for collisions\n4. Scoring each valid trajectory based on:\n   - Proximity to the global path\n   - Progress toward the goal\n   - Distance from obstacles\n   - Heading alignment\n5. Selecting the highest-scoring trajectory\n\n```mermaid\nflowchart TD\n    START[\"Start\"] --\u003e SAMPLE[\"Sample Velocities\"]\n    SAMPLE --\u003e LOOP[\"For Each Velocity Sample\"]\n    LOOP --\u003e SIM[\"Simulate Trajectory\"]\n    SIM --\u003e CHECK[\"Check Collisions\"]\n    CHECK --\u003e SCORE[\"Score Trajectory\"]\n    SCORE --\u003e NEXT[\"Next Sample\"]\n    NEXT --\u003e LOOP\n    LOOP --\u003e SELECT[\"Select Best Trajectory\"]\n    SELECT --\u003e CMD[\"Return Velocity Command\"]\n```\n\nSources: [base_local_planner/src/trajectory_planner.cpp:536-749](), [base_local_planner/src/trajectory_planner_ros.cpp:399-553]()\n\n## DWAPlannerROS\n\nThe DWAPlannerROS implements the Dynamic Window Approach (DWA), which limits velocity sampling to a \"dynamic window\" of achievable velocities given the robot's current state and acceleration limits. This makes it more efficient than the Trajectory Rollout planner.\n\n### DWAPlannerROS Components\n\n```mermaid\nclassDiagram\n    class DWAPlannerROS {\n        +initialize(name, tf, costmap_ros)\n        +computeVelocityCommands(cmd_vel) bool\n        +setPlan(plan) bool\n        +isGoalReached() bool\n        -dwaComputeVelocityCommands()\n        -boost::shared_ptr\u003cDWAPlanner\u003e dp_\n    }\n    \n    class DWAPlanner {\n        -LocalPlannerUtil* planner_util_\n        -SimpleTrajectoryGenerator generator_\n        -ObstacleCostFunction obstacle_costs_\n        -MapGridCostFunction path_costs_\n        -MapGridCostFunction goal_costs_\n        -TwirlingCostFunction twirling_costs_\n        -SimpleScoredSamplingPlanner scored_sampling_planner_\n        +findBestPath()\n        +checkTrajectory() bool\n        +reconfigure()\n    }\n    \n    class LocalPlannerUtil {\n        -costmap_2d::Costmap2D* costmap_\n        -tf2_ros::Buffer* tf_\n        -std::string global_frame_\n        +getLocalPlan() bool\n        +getGoal()\n        +setCostmap()\n        +getGlobalFrame()\n    }\n    \n    class SimpleScoredSamplingPlanner {\n        -std::vector\u003cTrajectorySampleGenerator*\u003e gen_list_\n        -std::vector\u003cTrajectoryCostFunction*\u003e critics_\n        +findBestTrajectory()\n        +scoreTrajectory()\n    }\n    \n    DWAPlannerROS --\u003e DWAPlanner : contains\n    DWAPlanner --\u003e LocalPlannerUtil : uses\n    DWAPlanner --\u003e SimpleScoredSamplingPlanner : uses\n```\n\nSources: [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h:66-157](), [dwa_local_planner/include/dwa_local_planner/dwa_planner.h:70-184]()\n\n### Cost Functions\n\nThe DWA planner uses a more modular approach with separate cost function classes:\n\n```mermaid\nflowchart TD\n    subgraph \"DWA Cost Functions\"\n        OCF[\"ObstacleCostFunction\"]\n        PCF[\"PathCostFunction\u003cbr\u003e(path_costs_)\"]\n        GCF[\"GoalCostFunction\u003cbr\u003e(goal_costs_)\"]\n        GFC[\"GoalFrontCostFunction\u003cbr\u003e(goal_front_costs_)\"]\n        ACF[\"AlignmentCostFunction\u003cbr\u003e(alignment_costs_)\"]\n        TCF[\"TwirlingCostFunction\u003cbr\u003e(twirling_costs_)\"]\n        OSCF[\"OscillationCostFunction\u003cbr\u003e(oscillation_costs_)\"]\n    end\n    \n    TRAJ[\"Generated\u003cbr\u003eTrajectories\"] --\u003e OCF\n    OCF --\u003e PCF\n    PCF --\u003e GCF\n    GCF --\u003e GFC\n    GFC --\u003e ACF\n    ACF --\u003e TCF\n    TCF --\u003e OSCF\n    OSCF --\u003e BEST[\"Best\u003cbr\u003eTrajectory\"]\n```\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:170-177]()\n\n## Comparing TrajectoryPlannerROS and DWAPlannerROS\n\n| Feature | TrajectoryPlannerROS | DWAPlannerROS |\n|---------|----------------------|---------------|\n| Approach | Full Trajectory Rollout | Dynamic Window Approach |\n| Velocity sampling | Samples across full velocity space | Samples within dynamic window based on current velocity and acceleration limits |\n| Efficiency | Less efficient, more samples | More efficient, focused sampling |\n| Configuration | Integrated cost functions | Modular, pluggable cost functions |\n| Holonomic support | Yes, with y_vels parameter | Yes, with vy_samples parameter |\n| DWA mode | Optional (dwa parameter) | Always enabled |\n| Robot types | Works with most robots | Better for robots with significant dynamics constraints |\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner.h:105-123](), [dwa_local_planner/cfg/DWAPlanner.cfg:13-39]()\n\n## Key Configuration Parameters\n\nBoth planners share many common parameters, but with some differences in how they're applied:\n\n### Common Parameters\n\n* **sim_time**: How far to forward-simulate trajectories (seconds)\n* **sim_granularity**: Distance between simulation points along trajectory\n* **vx_samples**, **vtheta_samples**: Number of velocity samples to evaluate\n* **path_distance_bias**: Weight for path alignment costs\n* **goal_distance_bias**: Weight for goal approach costs\n* **occdist_scale**: Weight for obstacle avoidance costs\n* **max_vel_x**, **min_vel_x**: Maximum/minimum forward velocity\n* **max_vel_theta**, **min_vel_theta**: Maximum/minimum rotational velocity\n\n### DWA-Specific Parameters\n\n* **forward_point_distance**: Distance ahead of robot for scoring trajectories\n* **scaling_speed**: Speed at which to start scaling the robot's footprint\n* **max_scaling_factor**: Maximum factor to scale the robot's footprint\n* **vx_samples**, **vy_samples**, **vtheta_samples**: Number of velocity samples in each dimension\n\nSources: [dwa_local_planner/cfg/DWAPlanner.cfg:13-39](), [base_local_planner/src/trajectory_planner_ros.cpp:94-236]()\n\n## How Velocity Commands Are Generated\n\nThe local planners convert global plans into executable velocity commands through a multi-step process:\n\n```mermaid\nsequenceDiagram\n    participant MoveBase as move_base\n    participant LocalPlanner as Local Planner\n    participant Costmap as Costmap2D\n    \n    MoveBase-\u003e\u003eLocalPlanner: setPlan(global_plan)\n    \n    loop Until goal is reached\n        MoveBase-\u003e\u003eLocalPlanner: computeVelocityCommands()\n        LocalPlanner-\u003e\u003eLocalPlanner: Transform global plan to local frame\n        LocalPlanner-\u003e\u003eLocalPlanner: Check if goal reached\n        \n        alt Goal not reached\n            LocalPlanner-\u003e\u003eLocalPlanner: Generate trajectory candidates\n            LocalPlanner-\u003e\u003eCostmap: Check for collisions\n            LocalPlanner-\u003e\u003eLocalPlanner: Score trajectories\n            LocalPlanner-\u003e\u003eLocalPlanner: Select best trajectory\n            LocalPlanner-\u003e\u003eMoveBase: Return velocity command\n        else Goal reached\n            LocalPlanner-\u003e\u003eLocalPlanner: Slow down or stop\n            LocalPlanner-\u003e\u003eMoveBase: Return zero velocity\n        end\n    end\n```\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:399-553](), [dwa_local_planner/src/dwa_planner_ros.cpp:264-312]()\n\n## Odometry Handling\n\nBoth local planners use odometry information to:\n1. Track current robot velocity for trajectory generation\n2. Detect when the robot is stopped\n3. Track progress toward the goal\n\nThe `OdometryHelperRos` class is used by both planners to handle odometry data in a consistent way.\n\n```mermaid\nclassDiagram\n    class OdometryHelperRos {\n        -nav_msgs::Odometry base_odom_\n        -ros::Subscriber odom_sub_\n        -std::string odom_topic_\n        +getOdom(base_odom)\n        +getRobotVel(robot_vel)\n        +setOdomTopic(odom_topic)\n        -odomCallback(msg)\n    }\n    \n    class TrajectoryPlannerROS {\n        -OdometryHelperRos odom_helper_\n    }\n    \n    class DWAPlannerROS {\n        -OdometryHelperRos odom_helper_\n    }\n    \n    OdometryHelperRos \u003c-- TrajectoryPlannerROS : uses\n    OdometryHelperRos \u003c-- DWAPlannerROS : uses\n```\n\nSources: [base_local_planner/include/base_local_planner/odometry_helper_ros.h:48-88](), [base_local_planner/src/odometry_helper_ros.cpp:44-104]()\n\n## Implementing a Custom Local Planner\n\nTo implement a custom local planner, you must:\n\n1. Create a class that implements the `nav_core::BaseLocalPlanner` interface\n2. Register it as a plugin using the ROS plugin system (`pluginlib`)\n3. Configure it in the `move_base` parameters\n\nAll local planners must implement these four key methods:\n```cpp\n// Initialize the planner\nvoid initialize(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros);\n\n// Set the global plan to follow\nbool setPlan(const std::vector\u003cgeometry_msgs::PoseStamped\u003e\u0026 plan);\n\n// Compute velocity commands to execute\nbool computeVelocityCommands(geometry_msgs::Twist\u0026 cmd_vel);\n\n// Check if goal has been reached\nbool isGoalReached();\n```\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner_ros.h:78-162](), [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h:66-122]()\n\n## Selection Guide\n\n### When to Use TrajectoryPlannerROS\n- For simpler robot kinematics\n- When you need fine-grained control over trajectory generation\n- For robots where holonomic behavior needs to be precisely customized\n\n### When to Use DWAPlannerROS\n- For robots with significant dynamic constraints\n- For better computational efficiency\n- When you need more modular, pluggable cost functions\n- For cleaner integration with the rest of the navigation stack\n\nIn general, DWAPlannerROS is recommended for most modern applications as it provides better performance and a more modular design.\n\nSources: [dwa_local_planner/src/dwa_planner_ros.cpp:97-139](), [base_local_planner/src/trajectory_planner_ros.cpp:88-272]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"29:T3375,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Base Local Planner\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/include/base_local_planner/trajectory_planner.h](base_local_planner/include/base_local_planner/trajectory_planner.h)\n- [base_local_planner/include/base_local_planner/trajectory_planner_ros.h](base_local_planner/include/base_local_planner/trajectory_planner_ros.h)\n- [base_local_planner/src/trajectory_planner.cpp](base_local_planner/src/trajectory_planner.cpp)\n- [base_local_planner/src/trajectory_planner_ros.cpp](base_local_planner/src/trajectory_planner_ros.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Base Local Planner is a core component of the ROS Navigation Stack that generates local trajectories and velocity commands for mobile robots. It serves as the implementation of the `nav_core::BaseLocalPlanner` interface, taking a global plan from the global planner and producing velocity commands to safely navigate the robot toward its goal while avoiding obstacles. For information about the overall navigation architecture, see [Overview](#1) or for more details on other local planners like DWA, see [DWA Local Planner](#5.2).\n\n## 1. Architecture\n\nThe Base Local Planner consists of two main classes: `TrajectoryPlannerROS` and `TrajectoryPlanner`. The `TrajectoryPlannerROS` class serves as the ROS wrapper and implements the `nav_core::BaseLocalPlanner` interface, while the `TrajectoryPlanner` class handles the core trajectory generation and scoring logic.\n\n```mermaid\nclassDiagram\n    class nav_core[\"nav_core::BaseLocalPlanner\"] {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize()\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n    }\n    \n    class TrajectoryPlannerROS {\n        +initialize()\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +checkTrajectory()\n        +scoreTrajectory()\n        -rotateToGoal()\n        -stopWithAccLimits()\n    }\n    \n    class TrajectoryPlanner {\n        +findBestPath()\n        +updatePlan()\n        +checkTrajectory()\n        +scoreTrajectory()\n        -createTrajectories()\n        -generateTrajectory()\n        -footprintCost()\n    }\n    \n    class WorldModel {\n        \u003c\u003cinterface\u003e\u003e\n        +footprintCost()\n    }\n    \n    class CostmapModel {\n        +footprintCost()\n    }\n    \n    nav_core \u003c|-- TrajectoryPlannerROS\n    TrajectoryPlannerROS *-- TrajectoryPlanner\n    TrajectoryPlannerROS *-- WorldModel\n    WorldModel \u003c|-- CostmapModel\n    TrajectoryPlanner --\u003e MapGrid\n```\n\n**Diagram: Base Local Planner Class Structure**\n\nSources: [base_local_planner/include/base_local_planner/trajectory_planner_ros.h:78-229](). [base_local_planner/include/base_local_planner/trajectory_planner.h:66-382]().\n\nThe `TrajectoryPlannerROS` class serves as the ROS interface for the trajectory planner, handling parameter loading, ROS-specific functionality, and the plugin interface. The `TrajectoryPlanner` class contains the core trajectory generation and evaluation algorithms.\n\n### 1.1 Data Flow\n\n```mermaid\nflowchart TD\n    subgraph \"Inputs\"\n        GP[\"Global Plan\"]\n        RP[\"Robot Pose\"]\n        RV[\"Robot Velocity\"]\n        CM[\"Costmap\"]\n    end\n    \n    subgraph \"TrajectoryPlannerROS\"\n        TPROS[\"TrajectoryPlannerROS\"]\n        \n        TPROS --\u003e CVC[\"computeVelocityCommands()\"]\n        \n        CVC --\u003e UPlan[\"Update Plan\"]\n        UPlan --\u003e TPlan[\"Create Trajectories\"]\n        TPlan --\u003e Score[\"Score Trajectories\"]\n        Score --\u003e Select[\"Select Best Trajectory\"]\n        Select --\u003e Vel[\"Generate Velocity Command\"]\n    end\n    \n    subgraph \"Outputs\"\n        VC[\"Velocity Command\\n(geometry_msgs::Twist)\"]\n    end\n    \n    GP --\u003e UPlan\n    RP --\u003e TPlan\n    RV --\u003e TPlan\n    CM --\u003e Score\n    \n    Vel --\u003e VC\n```\n\n**Diagram: Base Local Planner Data Flow**\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:399-553](). [base_local_planner/src/trajectory_planner.cpp:906-985]().\n\n## 2. Trajectory Generation and Scoring\n\nThe core functionality of the Base Local Planner is generating and scoring trajectories to find the optimal velocity command. This process involves:\n\n1. Sampling velocities from the robot's velocity space\n2. Generating trajectories based on these velocity samples\n3. Scoring each trajectory based on multiple criteria\n4. Selecting the trajectory with the best score\n\n```mermaid\nsequenceDiagram\n    participant MoveBase\n    participant TrajectoryPlannerROS\n    participant TrajectoryPlanner\n    participant WorldModel\n    \n    MoveBase-\u003e\u003eTrajectoryPlannerROS: computeVelocityCommands()\n    TrajectoryPlannerROS-\u003e\u003eTrajectoryPlanner: updatePlan(global_plan)\n    TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: setTargetCells()\n    TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: setLocalGoal()\n    \n    TrajectoryPlannerROS-\u003e\u003eTrajectoryPlanner: findBestPath(pose, vel)\n    \n    TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: createTrajectories()\n    loop For each velocity sample\n        TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: generateTrajectory()\n        loop For each simulation step\n            TrajectoryPlanner-\u003e\u003eWorldModel: footprintCost()\n            TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: Calculate path/goal/obstacle costs\n        end\n        TrajectoryPlanner-\u003e\u003eTrajectoryPlanner: Score trajectory\n    end\n    \n    TrajectoryPlanner-\u003e\u003eTrajectoryPlannerROS: Return best trajectory\n    TrajectoryPlannerROS-\u003e\u003eMoveBase: Return velocity command\n```\n\n**Diagram: Trajectory Generation and Evaluation Process**\n\nSources: [base_local_planner/src/trajectory_planner.cpp:536-903](). [base_local_planner/src/trajectory_planner.cpp:214-370]().\n\n### 2.1 Velocity Sampling\n\nThe planner samples velocities from the robot's velocity space to generate trajectories. The sampling strategy depends on the robot's kinematics:\n\n**For holonomic robots (those that can move in any direction):**\n- X-velocity (forward/backward)\n- Y-velocity (lateral movement)\n- Theta-velocity (rotation)\n\n**For non-holonomic robots (like differential drive):**\n- X-velocity (forward/backward)\n- Theta-velocity (rotation)\n\nThe number of samples in each dimension is controlled by the `vx_samples` and `vtheta_samples` parameters.\n\nSources: [base_local_planner/src/trajectory_planner.cpp:538-697](). [base_local_planner/include/base_local_planner/trajectory_planner.h:286-287]().\n\n### 2.2 Trajectory Generation\n\nFor each velocity sample, the planner generates a trajectory by simulating the robot's motion over a short time horizon (`sim_time`). The trajectory is divided into small time steps (`sim_granularity`), and at each step:\n\n1. The robot's new position and orientation are calculated based on the current velocity\n2. The trajectory point is checked for collision with obstacles\n3. The cost of the point is calculated\n\nIf any point in the trajectory is in collision with an obstacle, the entire trajectory is marked as invalid.\n\nSources: [base_local_planner/src/trajectory_planner.cpp:214-370](). [base_local_planner/include/base_local_planner/trajectory_planner.h:243-246]().\n\n### 2.3 Trajectory Scoring\n\nValid trajectories are scored based on several factors:\n\n| Factor | Description | Parameter |\n|--------|-------------|-----------|\n| Path Distance | How well the trajectory follows the global path | `path_distance_bias` |\n| Goal Distance | How efficiently the trajectory approaches the goal | `goal_distance_bias` |\n| Obstacle Cost | How far the trajectory stays from obstacles | `occdist_scale` |\n| Heading | (Optional) How well the trajectory's heading aligns with the goal | `heading_scoring` |\n\nThe total score is a weighted sum of these factors, with the weights controlled by the bias parameters.\n\nSources: [base_local_planner/src/trajectory_planner.cpp:362-369](). [base_local_planner/include/base_local_planner/trajectory_planner.h:289]().\n\n## 3. Recovery Behaviors\n\nThe Base Local Planner includes several recovery strategies for when the robot gets stuck:\n\n1. **Rotation Recovery**: If the robot can't find a valid forward trajectory, it attempts to rotate in place to find a clear path.\n2. **Escape Mode**: If the robot is completely stuck, it will attempt to move backward to escape.\n3. **Oscillation Detection**: The planner detects and prevents oscillatory behavior, such as repeatedly switching between left and right rotations.\n\nSources: [base_local_planner/src/trajectory_planner.cpp:649-696](). [base_local_planner/src/trajectory_planner.cpp:849-901]().\n\n## 4. Configuration Parameters\n\nThe Base Local Planner is highly configurable through various parameters:\n\n### 4.1 Robot Limits\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `acc_lim_x` | X acceleration limit (m/s) | 2.5 |\n| `acc_lim_y` | Y acceleration limit (m/s) | 2.5 |\n| `acc_lim_theta` | Angular acceleration limit (rad/s) | 3.2 |\n| `max_vel_x` | Maximum forward velocity (m/s) | 0.5 |\n| `min_vel_x` | Minimum forward velocity (m/s) | 0.1 |\n| `max_vel_theta` | Maximum rotational velocity (rad/s) | 1.0 |\n| `min_vel_theta` | Minimum rotational velocity (rad/s) | -1.0 |\n| `min_in_place_vel_theta` | Minimum in-place rotational velocity (rad/s) | 0.4 |\n| `holonomic_robot` | Whether the robot is holonomic (can move sideways) | true |\n\n### 4.2 Goal Tolerance\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `yaw_goal_tolerance` | Goal yaw tolerance (rad) | 0.05 |\n| `xy_goal_tolerance` | Goal position tolerance (m) | 0.10 |\n| `latch_xy_goal_tolerance` | Whether to stop rotating to goal orientation once xy tolerance is met | false |\n\n### 4.3 Trajectory Scoring\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `path_distance_bias` | Weight for path distance cost | 0.6 |\n| `goal_distance_bias` | Weight for goal distance cost | 0.6 |\n| `occdist_scale` | Weight for obstacle cost | 0.01 |\n| `heading_scoring` | Whether to score based on robot heading | false |\n| `heading_scoring_timestep` | Time to look ahead for heading scoring | 0.8 |\n\n### 4.4 Trajectory Generation\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `sim_time` | Time to simulate trajectories (s) | 1.0 |\n| `sim_granularity` | Time step for trajectory simulation (s) | 0.025 |\n| `angular_sim_granularity` | Angular time step for trajectory simulation (rad) | 0.025 |\n| `vx_samples` | Number of velocity samples in x dimension | 3 |\n| `vtheta_samples` | Number of velocity samples in theta dimension | 20 |\n| `dwa` | Whether to use Dynamic Window Approach | true |\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:102-268](). [base_local_planner/src/trajectory_planner.cpp:61-139]().\n\n## 5. Implementation Details\n\n### 5.1 Dynamic Reconfiguration\n\nThe Base Local Planner supports dynamic reconfiguration, allowing parameters to be changed at runtime through the ROS dynamic_reconfigure framework.\n\n```mermaid\nflowchart LR\n    DSRV[\"Dynamic Reconfigure Server\"] --\u003e CB[\"reconfigureCB()\"]\n    CB --\u003e TC[\"TrajectoryPlanner::reconfigure()\"]\n    TC --\u003e Update[\"Update planner parameters\"]\n```\n\n**Diagram: Dynamic Reconfiguration Process**\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:64-76](). [base_local_planner/src/trajectory_planner.cpp:61-139]().\n\n### 5.2 Plugin Interface\n\nThe Base Local Planner is implemented as a plugin for the ROS Navigation Stack using the `nav_core::BaseLocalPlanner` interface:\n\n```\nPLUGINLIB_EXPORT_CLASS(base_local_planner::TrajectoryPlannerROS, nav_core::BaseLocalPlanner)\n```\n\nThis allows it to be loaded dynamically by the `move_base` node through the plugin loader mechanism.\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:60]().\n\n### 5.3 Footprint Handling\n\nThe planner uses the robot's footprint to check for collisions with obstacles. The footprint can be specified as a set of points representing the robot's shape projected onto the ground. \n\nThe collision checking is performed using the `WorldModel::footprintCost` method, which is typically implemented by the `CostmapModel` class to check the robot's footprint against the costmap.\n\nSources: [base_local_planner/src/trajectory_planner.cpp:988-991](). [base_local_planner/include/base_local_planner/trajectory_planner.h:254-255]().\n\n## 6. Usage\n\nThe Base Local Planner is typically used in conjunction with the `move_base` node as follows:\n\n1. Configure the `move_base` node to use the Base Local Planner by setting the `base_local_planner` parameter to `base_local_planner/TrajectoryPlannerROS`\n2. Configure the planner parameters in the `base_local_planner_params.yaml` file\n3. Launch the `move_base` node with your configuration\n\nWhen the `move_base` node receives a goal, it will:\n1. Request a global plan from the global planner\n2. Pass the global plan to the Base Local Planner via the `setPlan` method\n3. Repeatedly call `computeVelocityCommands` to get velocity commands until the goal is reached or aborted\n\nThe Base Local Planner will use the costmap, global plan, and robot state to generate velocity commands that safely navigate the robot towards its goal.\n\nSources: [base_local_planner/src/trajectory_planner_ros.cpp:382-396](). [base_local_planner/src/trajectory_planner_ros.cpp:399-553]()."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2a:T3b6f,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# DWA Local Planner\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/include/base_local_planner/odometry_helper_ros.h](base_local_planner/include/base_local_planner/odometry_helper_ros.h)\n- [base_local_planner/src/odometry_helper_ros.cpp](base_local_planner/src/odometry_helper_ros.cpp)\n- [dwa_local_planner/cfg/DWAPlanner.cfg](dwa_local_planner/cfg/DWAPlanner.cfg)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner.h](dwa_local_planner/include/dwa_local_planner/dwa_planner.h)\n- [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h](dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h)\n- [dwa_local_planner/src/dwa_planner.cpp](dwa_local_planner/src/dwa_planner.cpp)\n- [dwa_local_planner/src/dwa_planner_ros.cpp](dwa_local_planner/src/dwa_planner_ros.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Dynamic Window Approach (DWA) Local Planner is a trajectory-based local planner for mobile robots that implements the Dynamic Window Approach algorithm in ROS. This planner generates velocity commands that drive a robot toward its navigation goal while avoiding obstacles, respecting the robot's kinematic and dynamic constraints, and considering the global path.\n\nFor information about local planners in general and the abstract interface that DWA Local Planner implements, see [Local Planners](#5). For information about the other primary local planner implementation, see [Base Local Planner](#5.1).\n\n## Algorithm Overview\n\nThe Dynamic Window Approach, first introduced by Fox, Burgard, and Thrun, is a velocity space-based local planning method. Rather than planning in position space, DWA operates in the robot's velocity space (linear and angular velocities).\n\nThe core algorithm follows these steps:\n\n1. **Discretize the velocity space** - Sample from the robot's velocity space (vx, vy, v) within a \"dynamic window\" constrained by the robot's acceleration capabilities\n2. **Generate trajectories** - For each velocity sample, simulate the resulting trajectory over a short time horizon\n3. **Score trajectories** - Evaluate each trajectory using multiple cost functions\n4. **Select best trajectory** - Choose the trajectory with the highest score (lowest cost)\n5. **Execute** - Extract velocity commands from the selected trajectory\n\n```mermaid\nflowchart TD\n    subgraph \"DWA Algorithm Flow\"\n        A[\"Generate Velocity Samples\"]\n        B[\"Simulate Trajectories\"]\n        C[\"Score Trajectories\"]\n        D[\"Select Best Trajectory\"]\n        E[\"Extract Velocity Command\"]\n        \n        A --\u003e B --\u003e C --\u003e D --\u003e E\n    end\n    \n    subgraph \"Cost Functions\"\n        C1[\"Oscillation Costs\"]\n        C2[\"Obstacle Costs\"]\n        C3[\"Goal Front Costs\"]\n        C4[\"Alignment Costs\"]\n        C5[\"Path Costs\"]\n        C6[\"Goal Costs\"]\n        C7[\"Twirling Costs\"]\n        \n        C --\u003e C1 \u0026 C2 \u0026 C3 \u0026 C4 \u0026 C5 \u0026 C6 \u0026 C7\n    end\n```\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:170-177](), [dwa_local_planner/src/dwa_planner.cpp:297-393]()\n\n## Implementation Architecture\n\nThe DWA Local Planner is implemented with two main classes:\n\n1. `DWAPlannerROS` - The ROS wrapper that implements the `nav_core::BaseLocalPlanner` interface\n2. `DWAPlanner` - The core implementation that handles trajectory generation and evaluation\n\n```mermaid\nclassDiagram\n    class BaseLocalPlanner {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize()\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n    }\n    \n    class DWAPlannerROS {\n        -DWAPlanner* dp_\n        -LocalPlannerUtil planner_util_\n        -OdometryHelperRos odom_helper_\n        -LatchedStopRotateController latchedStopRotateController_\n        +initialize()\n        +computeVelocityCommands()\n        +setPlan()\n        +isGoalReached()\n        +dwaComputeVelocityCommands()\n    }\n    \n    class DWAPlanner {\n        -SimpleTrajectoryGenerator generator_\n        -OscillationCostFunction oscillation_costs_\n        -ObstacleCostFunction obstacle_costs_\n        -MapGridCostFunction path_costs_\n        -MapGridCostFunction goal_costs_\n        -MapGridCostFunction goal_front_costs_\n        -MapGridCostFunction alignment_costs_\n        -TwirlingCostFunction twirling_costs_\n        -SimpleScoredSamplingPlanner scored_sampling_planner_\n        +reconfigure()\n        +findBestPath()\n        +updatePlanAndLocalCosts()\n        +checkTrajectory()\n    }\n    \n    BaseLocalPlanner \u003c|-- DWAPlannerROS\n    DWAPlannerROS *-- DWAPlanner\n```\n\nSources: [dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h:66-157](), [dwa_local_planner/include/dwa_local_planner/dwa_planner.h:70-183]()\n\n### DWAPlannerROS\n\n`DWAPlannerROS` is the ROS wrapper class that:\n\n1. Implements the `nav_core::BaseLocalPlanner` interface, making it a plugin for `move_base`\n2. Handles ROS-specific functionality (parameters, subscribers, publishers)\n3. Delegates trajectory generation to the `DWAPlanner` class\n4. Provides visualization of the global and local plans\n\nThe class maintains the state of the robot and navigation task, and handles the transition between normal path following and the final approach to the goal.\n\nSources: [dwa_local_planner/src/dwa_planner_ros.cpp:57-312]()\n\n### DWAPlanner\n\n`DWAPlanner` implements the core Dynamic Window Approach algorithm:\n\n1. Uses `SimpleTrajectoryGenerator` to generate candidate trajectories\n2. Applies multiple cost functions to evaluate each trajectory\n3. Selects the best trajectory based on combined scores\n4. Provides debugging information and visualizations\n\nThe class is independent of ROS-specific constructs, focusing purely on the algorithm implementation.\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:52-393]()\n\n## Algorithm Flow\n\nThis sequence diagram illustrates how the DWA Local Planner operates within the ROS navigation stack:\n\n```mermaid\nsequenceDiagram\n    participant MoveBase\n    participant DWAPlannerROS\n    participant DWAPlanner\n    participant CostFunctions\n    participant TrajectoryGenerator\n    \n    MoveBase-\u003e\u003eDWAPlannerROS: setPlan(global_plan)\n    DWAPlannerROS-\u003e\u003eDWAPlanner: setPlan(global_plan)\n    \n    loop Navigation control cycle\n        MoveBase-\u003e\u003eDWAPlannerROS: computeVelocityCommands()\n        DWAPlannerROS-\u003e\u003eDWAPlannerROS: Get current pose and velocity\n        \n        alt Close to goal\n            DWAPlannerROS-\u003e\u003eDWAPlannerROS: latchedStopRotateController_.computeVelocityCommandsStopRotate()\n        else Regular path following\n            DWAPlannerROS-\u003e\u003eDWAPlannerROS: dwaComputeVelocityCommands()\n            DWAPlannerROS-\u003e\u003eDWAPlanner: updatePlanAndLocalCosts()\n            DWAPlannerROS-\u003e\u003eDWAPlanner: findBestPath()\n            DWAPlanner-\u003e\u003eTrajectoryGenerator: initialise()\n            TrajectoryGenerator-\u003e\u003eDWAPlanner: Return trajectory samples\n            \n            loop For each trajectory\n                DWAPlanner-\u003e\u003eCostFunctions: Score trajectory\n                CostFunctions-\u003e\u003eDWAPlanner: Return score\n            end\n            \n            DWAPlanner-\u003e\u003eDWAPlannerROS: Return best trajectory\n            DWAPlannerROS-\u003e\u003eDWAPlannerROS: Extract velocity commands\n        end\n        \n        DWAPlannerROS-\u003e\u003eMoveBase: Return velocity commands\n    end\n```\n\nSources: [dwa_local_planner/src/dwa_planner_ros.cpp:264-312](), [dwa_local_planner/src/dwa_planner.cpp:297-393]()\n\n## Trajectory Generation and Scoring\n\n### Trajectory Generation\n\nThe DWA Local Planner uses the `SimpleTrajectoryGenerator` class to generate trajectories. For each velocity sample (vx, vy, v), it simulates the robot's motion for a short time horizon.\n\nThe number of velocity samples is controlled by the `vx_samples`, `vy_samples`, and `vth_samples` parameters. The `use_dwa` parameter determines whether to use the full dynamic window approach (considering accelerations) or a simpler approach.\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:57-62](), [dwa_local_planner/cfg/DWAPlanner.cfg:31-35]()\n\n### Cost Functions\n\nThe DWA Local Planner uses multiple cost functions to evaluate trajectories, applied in the following order:\n\n| Cost Function | Purpose | Implementation |\n|---------------|---------|----------------|\n| `oscillation_costs_` | Prevents oscillatory behavior (back-and-forth motion) | Tracks forward/backward and rotation directions and penalizes reversals |\n| `obstacle_costs_` | Avoids collisions with obstacles | Checks if the footprint along the trajectory collides with obstacles |\n| `goal_front_costs_` | Drives the robot's nose toward the goal | Penalizes trajectories where the robot's front point doesn't move toward the goal |\n| `alignment_costs_` | Aligns the robot with the path | Penalizes trajectories where the robot isn't aligned with the path |\n| `path_costs_` | Keeps the robot close to the global path | Penalizes trajectories that move away from the global path |\n| `goal_costs_` | Drives the robot toward the goal | Penalizes trajectories that don't make progress toward the goal |\n| `twirling_costs_` | Discourages excessive rotation | Penalizes trajectories with high rotational velocity |\n\nEach cost function returns a score, and the combined score is used to select the best trajectory. Cost functions can abort scoring by returning a negative value, which helps efficiently eliminate invalid trajectories.\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:170-177](), [dwa_local_planner/include/dwa_local_planner/dwa_planner.h:174-180]()\n\n## Configuration Parameters\n\nThe DWA Local Planner has many configuration parameters that can be adjusted to optimize performance for a specific robot and environment. These can be set in the configuration file or adjusted dynamically at runtime.\n\n### Simulation Parameters\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `sim_time` | Time to simulate trajectories forward (seconds) | 1.7 |\n| `sim_granularity` | Step size for trajectory simulation (meters) | 0.025 |\n| `angular_sim_granularity` | Angular step size for trajectory simulation (radians) | 0.1 |\n\n### Cost Function Weights\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `path_distance_bias` | Weight for path distance cost | 0.6 |\n| `goal_distance_bias` | Weight for goal distance cost | 0.8 |\n| `occdist_scale` | Weight for obstacle distance cost | 0.01 |\n| `twirling_scale` | Weight for penalizing rotation | 0.0 |\n\n### Trajectory Sampling\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `vx_samples` | Number of samples in x velocity space | 3 |\n| `vy_samples` | Number of samples in y velocity space | 10 |\n| `vth_samples` | Number of samples in rotational velocity space | 20 |\n| `use_dwa` | Whether to use the dynamic window approach | True |\n\n### Velocity and Acceleration Limits\n\n| Parameter | Description |\n|-----------|-------------|\n| `max_vel_trans` | Maximum translational velocity |\n| `min_vel_trans` | Minimum translational velocity |\n| `max_vel_x` | Maximum velocity in x direction |\n| `min_vel_x` | Minimum velocity in x direction |\n| `max_vel_y` | Maximum velocity in y direction |\n| `min_vel_y` | Minimum velocity in y direction |\n| `max_vel_theta` | Maximum rotational velocity |\n| `min_vel_theta` | Minimum rotational velocity |\n| `acc_lim_x` | Maximum acceleration in x direction |\n| `acc_lim_y` | Maximum acceleration in y direction |\n| `acc_lim_theta` | Maximum rotational acceleration |\n\n### Other Parameters\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| `stop_time_buffer` | Time the robot must be able to stop before collision (seconds) | 0.2 |\n| `oscillation_reset_dist` | Distance to travel before resetting oscillation flags (meters) | 0.05 |\n| `oscillation_reset_angle` | Angle to rotate before resetting oscillation flags (radians) | 0.2 |\n| `forward_point_distance` | Distance ahead of robot to place additional scoring point (meters) | 0.325 |\n\nSources: [dwa_local_planner/cfg/DWAPlanner.cfg:13-36]()\n\n## Integration with move_base\n\nThe DWA Local Planner is designed to be used as a plugin for the `move_base` node. To use it, you need to specify it in your move_base configuration:\n\n```yaml\nbase_local_planner: \"dwa_local_planner/DWAPlannerROS\"\n```\n\nYou also need to provide configuration parameters either in a separate configuration file or in the move_base namespace:\n\n```yaml\nDWAPlannerROS:\n  # Trajectory generation\n  sim_time: 1.7\n  sim_granularity: 0.025\n  \n  # Cost function weights\n  path_distance_bias: 0.6\n  goal_distance_bias: 0.8\n  occdist_scale: 0.01\n  \n  # Velocity sampling\n  vx_samples: 3\n  vy_samples: 10\n  vth_samples: 20\n  \n  # Robot-specific limits\n  max_vel_x: 0.5\n  min_vel_x: 0.0\n  max_vel_y: 0.0  # 0.0 for non-holonomic robots\n  min_vel_y: 0.0\n  max_vel_trans: 0.5\n  min_vel_trans: 0.1\n  max_vel_theta: 1.0\n  min_vel_theta: 0.2\n  acc_lim_x: 2.5\n  acc_lim_y: 0.0  # 0.0 for non-holonomic robots\n  acc_lim_theta: 3.2\n  \n  # Other parameters\n  forward_point_distance: 0.325\n```\n\nThe DWA Local Planner supports dynamic reconfiguration, allowing you to tune parameters at runtime without restarting the navigation stack.\n\nSources: [dwa_local_planner/src/dwa_planner_ros.cpp:57-90](), [dwa_local_planner/src/dwa_planner_ros.cpp:133-135]()\n\n## Algorithm Details: Velocity Command Generation\n\nThe core of the DWA algorithm is implemented in `DWAPlanner::findBestPath()`, which follows these steps:\n\n1. Get the current robot pose and velocity\n2. Initialize the trajectory generator with robot constraints\n3. Generate and score multiple trajectories\n4. Select the highest-scoring valid trajectory\n5. Extract velocity commands from the selected trajectory\n\nIf no valid trajectory is found (all trajectories have negative scores), the planner returns zero velocity, causing the robot to stop.\n\n```mermaid\nflowchart TD\n    A[\"findBestPath()\"] --\u003e B[\"Get current pose and velocity\"]\n    B --\u003e C[\"Initialize trajectory generator\"]\n    C --\u003e D[\"Generate trajectories\"]\n    D --\u003e E[\"Score trajectories\"]\n    E --\u003e F[\"Select best trajectory\"]\n    \n    F --\u003e G{Valid trajectory?}\n    G --\u003e|Yes| H[\"Extract velocity commands\"]\n    G --\u003e|No| I[\"Return zero velocity\"]\n    \n    H --\u003e J[\"Return trajectory\"]\n    I --\u003e J\n```\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:297-393]()\n\n## Trajectory Visualization\n\nThe DWA Local Planner can visualize its internal state to aid in debugging and tuning:\n\n1. `publish_traj_pc_`: When enabled, publishes all explored trajectories as a point cloud\n2. `publish_cost_grid_pc_`: When enabled, publishes the cost grid visualization\n\nThese visualizations can be viewed in RViz to understand why the planner is making certain decisions.\n\nSources: [dwa_local_planner/src/dwa_planner.cpp:323-369]()\n\n## Summary\n\nThe DWA Local Planner provides a velocity-space approach to local navigation that:\n\n1. Efficiently samples the robot's velocity space\n2. Considers kinodynamic constraints\n3. Evaluates trajectories using multiple criteria\n4. Balances progress toward the goal with obstacle avoidance\n\nThis approach is particularly effective for differential-drive and omnidirectional robots. The planner's performance can be tuned by adjusting the weights of different cost functions and the density of velocity sampling."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2b:T4cdb,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Localization\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/CMakeLists.txt](amcl/CMakeLists.txt)\n- [amcl/cfg/AMCL.cfg](amcl/cfg/AMCL.cfg)\n- [amcl/package.xml](amcl/package.xml)\n- [amcl/src/amcl/pf/eig3.c](amcl/src/amcl/pf/eig3.c)\n- [amcl/src/amcl/pf/pf.c](amcl/src/amcl/pf/pf.c)\n- [amcl/src/amcl/pf/pf_vector.c](amcl/src/amcl/pf/pf_vector.c)\n- [amcl/src/amcl/sensors/amcl_laser.cpp](amcl/src/amcl/sensors/amcl_laser.cpp)\n- [amcl/src/amcl_node.cpp](amcl/src/amcl_node.cpp)\n- [amcl/src/include/portable_utils.hpp](amcl/src/include/portable_utils.hpp)\n- [amcl/test/basic_localization.py](amcl/test/basic_localization.py)\n- [amcl/test/basic_localization_stage.xml](amcl/test/basic_localization_stage.xml)\n- [amcl/test/global_localization_stage.xml](amcl/test/global_localization_stage.xml)\n- [amcl/test/rosie_multilaser.xml](amcl/test/rosie_multilaser.xml)\n- [amcl/test/set_initial_pose.xml](amcl/test/set_initial_pose.xml)\n- [amcl/test/set_initial_pose_delayed.xml](amcl/test/set_initial_pose_delayed.xml)\n- [amcl/test/set_pose.py](amcl/test/set_pose.py)\n- [amcl/test/small_loop_crazy_driving_prg.xml](amcl/test/small_loop_crazy_driving_prg.xml)\n- [amcl/test/small_loop_crazy_driving_prg_corrected.xml](amcl/test/small_loop_crazy_driving_prg_corrected.xml)\n- [amcl/test/small_loop_prf.xml](amcl/test/small_loop_prf.xml)\n- [amcl/test/texas_greenroom_loop.xml](amcl/test/texas_greenroom_loop.xml)\n- [amcl/test/texas_willow_hallway_loop.xml](amcl/test/texas_willow_hallway_loop.xml)\n- [fake_localization/package.xml](fake_localization/package.xml)\n- [map_server/package.xml](map_server/package.xml)\n- [navigation/package.xml](navigation/package.xml)\n\n\u003c/details\u003e\n\n\n\nThe Localization system in the ROS Navigation Stack is responsible for determining the robot's pose (position and orientation) within a known map. It provides the critical transformation between the global map frame and the robot's local odometry frame, which enables global path planning and autonomous navigation. This document explains the available localization methods, their implementations, and how to configure them for optimal performance.\n\nFor costmap-related information, see [Costmap2D](#2). For path planning details, see [Global Planners](#4) and [Local Planners](#5).\n\n## 1. Overview\n\nThe ROS Navigation Stack includes two main localization implementations:\n\n1. **AMCL (Adaptive Monte Carlo Localization)**: A probabilistic localization algorithm that uses a particle filter to track the robot's pose.\n2. **fake_localization**: A simplified alternative that directly publishes transforms based on odometry, useful for testing or simulation environments.\n\nBoth implementations provide the necessary transform from the map frame to the odometry frame, which is essential for the navigation stack to function properly.\n\n```mermaid\ngraph TD\n    subgraph \"Localization System\"\n        AMCL[\"AMCL\"]\n        Fake[\"fake_localization\"]\n    end\n    \n    subgraph \"Inputs\"\n        Map[\"Map Data\"]\n        Laser[\"Laser Scans\"]\n        Odom[\"Odometry\"]\n        InitialPose[\"Initial Pose\"]\n    end\n    \n    subgraph \"Outputs\"\n        Transform[\"TF: mapodom\"]\n        PoseEstimate[\"Pose Estimate\"]\n    end\n    \n    Map --\u003e AMCL\n    Laser --\u003e AMCL\n    Odom --\u003e AMCL\n    InitialPose --\u003e AMCL\n    \n    Odom --\u003e Fake\n    \n    AMCL --\u003e Transform\n    AMCL --\u003e PoseEstimate\n    \n    Fake --\u003e Transform\n    Fake --\u003e PoseEstimate\n```\n\nSources: [amcl/package.xml](5-17), [fake_localization/package.xml](1-13), [navigation/package.xml](21-27)\n\n## 2. AMCL (Adaptive Monte Carlo Localization)\n\nAMCL is a probabilistic localization system that implements the adaptive Monte Carlo localization approach using a particle filter. It tracks the pose of a robot against a known map by maintaining a set of particles, each representing a possible robot pose.\n\n### 2.1 Algorithm Overview\n\nThe AMCL algorithm represents the robot's belief about its pose as a collection of weighted particles. Each particle corresponds to a potential pose, and the weight indicates the probability of that pose being correct.\n\nThe \"adaptive\" aspect refers to the algorithm's ability to dynamically adjust the number of particles based on the localization uncertainty, using KLD-sampling (Kullback-Leibler Divergence).\n\n```mermaid\nflowchart TD\n    subgraph \"AMCL Algorithm\"\n        Init[\"Initialize Particle Filter\"] --\u003e Predict\n        Predict[\"Motion Update (Prediction)\"] --\u003e Correct\n        Correct[\"Sensor Update (Correction)\"] --\u003e Resample\n        Resample[\"Resample Particles\"] --\u003e PoseEst\n        PoseEst[\"Estimate Pose\"] --\u003e TF\n        TF[\"Publish Transform\"] --\u003e Predict\n    end\n    \n    Odom[\"Odometry Data\"] --\u003e Predict\n    Laser[\"Laser Scan\"] --\u003e Correct\n    Map[\"Map\"] --\u003e Correct\n    Initial[\"Initial Pose\"] --\u003e Init\n```\n\nSources: [amcl/src/amcl_node.cpp](348-618), [amcl/src/amcl/pf/pf.c](46-115)\n\n### 2.2 Implementation Architecture\n\nThe AMCL node in ROS is implemented as a class-based structure that coordinates several components:\n\n```mermaid\nclassDiagram\n    class AmclNode {\n        +pf_t* pf_\n        +map_t* map_\n        +AMCLLaser* laser_\n        +AMCLOdom* odom_\n        +tf2_ros::Buffer* tf_\n        +initialize()\n        +laserReceived()\n        +initialPoseReceived()\n        +globalLocalizationCallback()\n        +updatePoseFromServer()\n    }\n    \n    class pf_t {\n        +pf_sample_set_t sets[2]\n        +pf_init()\n        +pf_update_action()\n        +pf_update_sensor()\n        +pf_update_resample()\n    }\n    \n    class AMCLLaser {\n        +SetModelBeam()\n        +SetModelLikelihoodField()\n        +SetModelLikelihoodFieldProb()\n        +UpdateSensor()\n    }\n    \n    class AMCLOdom {\n        +SetModel()\n        +UpdateAction()\n    }\n    \n    AmclNode --\u003e pf_t : uses\n    AmclNode --\u003e AMCLLaser : uses\n    AmclNode --\u003e AMCLOdom : uses\n```\n\nSources: [amcl/src/amcl_node.cpp](132-296), [amcl/src/amcl/pf/pf.c](46-115), [amcl/src/amcl/sensors/amcl_laser.cpp](43-64)\n\n### 2.3 Particle Filter\n\nThe particle filter is the core algorithm of AMCL, implemented in `pf_t` structure and related functions:\n\n1. **Initialization**: Particles are initialized either with a Gaussian distribution around an initial pose or uniformly across free space for global localization.\n\n2. **Motion Update**: When the robot moves, particles are updated according to the odometry model:\n   ```\n   pf_update_action(pf_, (pf_action_model_fn_t)AMCLOdom::UpdateAction, odom_);\n   ```\n\n3. **Sensor Update**: Laser scan measurements update the particle weights:\n   ```\n   pf_update_sensor(pf_, (pf_sensor_model_fn_t)AMCLLaser::BeamModel, data);\n   ```\n\n4. **Resampling**: Periodically, particles are resampled to focus computational resources on the most likely poses:\n   ```\n   pf_update_resample(pf_);\n   ```\n\n5. **Adaptive Sampling**: The KLD-sampling algorithm adjusts the number of particles based on the distribution complexity:\n   ```\n   pf_resample_limit(pf, set_b-\u003ekdtree-\u003eleaf_count)\n   ```\n\n6. **Pose Estimation**: The final pose is estimated by clustering the particles and computing statistics:\n   ```\n   pf_cluster_stats(pf, set);\n   ```\n\nSources: [amcl/src/amcl/pf/pf.c](135-211), [amcl/src/amcl/pf/pf.c](253-262), [amcl/src/amcl/pf/pf.c](267-318), [amcl/src/amcl/pf/pf.c](362-510), [amcl/src/amcl/pf/pf.c](513-555), [amcl/src/amcl/pf/pf.c](558-693)\n\n### 2.4 Sensor Models\n\nAMCL supports three different laser sensor models to compute particle weights:\n\n1. **Beam Model**: Models individual laser beams and compares expected and actual range readings\n   - Parameters: z_hit, z_short, z_max, z_rand, sigma_hit, lambda_short\n   - Implementation: [amcl/src/amcl/sensors/amcl_laser.cpp](144-213)\n\n2. **Likelihood Field Model**: Uses a precomputed distance field for faster computation\n   - Parameters: z_hit, z_rand, sigma_hit, laser_likelihood_max_dist\n   - Implementation: [amcl/src/amcl/sensors/amcl_laser.cpp](215-304)\n\n3. **Likelihood Field Model with Probabilities**: Enhanced version that handles dynamic environments better\n   - Additional parameters: do_beamskip, beam_skip_distance, beam_skip_threshold\n   - Implementation: [amcl/src/amcl/sensors/amcl_laser.cpp](305-494)\n\n```mermaid\nflowchart TD\n    subgraph \"Sensor Models\"\n        BeamModel[\"Beam Model\u003cbr\u003ez_hit, z_short, z_max, z_rand\"]\n        LikelihoodField[\"Likelihood Field Model\u003cbr\u003ez_hit, z_rand, sigma_hit\"]\n        LikelihoodFieldProb[\"Likelihood Field with Probabilities\u003cbr\u003e+ beam skipping\"]\n    end\n    \n    LaserScan[\"Laser Scan\"] --\u003e BeamModel \u0026 LikelihoodField \u0026 LikelihoodFieldProb\n    Map[\"Map\"] --\u003e BeamModel \u0026 LikelihoodField \u0026 LikelihoodFieldProb\n    BeamModel \u0026 LikelihoodField \u0026 LikelihoodFieldProb --\u003e ParticleWeights[\"Particle Weights\"]\n```\n\nSources: [amcl/src/amcl/sensors/amcl_laser.cpp](66-118), [amcl/cfg/AMCL.cfg](40-55)\n\n### 2.5 Odometry Models\n\nAMCL provides different odometry models for the motion update:\n\n1. **Differential Drive Model (`diff`)**: For robots with differential drive kinematics\n   - Parameters: alpha1 (rotation noise from rotation), alpha2 (rotation noise from translation), alpha3 (translation noise from translation), alpha4 (translation noise from rotation)\n\n2. **Omnidirectional Model (`omni`)**: For robots that can move in any direction\n   - Additional parameter: alpha5 (translational noise)\n\n3. **Corrected Models (`diff-corrected`, `omni-corrected`)**: More sophisticated versions that account for systematic errors\n\nSources: [amcl/cfg/AMCL.cfg](58-69), [amcl/src/amcl_node.cpp](422-436)\n\n### 2.6 ROS Interface\n\nThe AMCL node interacts with the ROS ecosystem through the following interfaces:\n\n#### Subscribed Topics\n\n| Topic | Message Type | Description |\n|-------|-------------|-------------|\n| `scan` | sensor_msgs/LaserScan | Laser scan data for pose correction |\n| `initialpose` | geometry_msgs/PoseWithCovarianceStamped | Initial pose estimate |\n| `map` (optional) | nav_msgs/OccupancyGrid | Map data if `use_map_topic` is true |\n\n#### Published Topics\n\n| Topic | Message Type | Description |\n|-------|-------------|-------------|\n| `amcl_pose` | geometry_msgs/PoseWithCovarianceStamped | Estimated pose with uncertainty |\n| `particlecloud` | geometry_msgs/PoseArray | Visualization of particle distribution |\n| `/tf` | tf2_msgs/TFMessage | Transform from map to odom frames |\n\n#### Services\n\n| Service | Type | Description |\n|---------|------|-------------|\n| `global_localization` | std_srvs/Empty | Triggers global localization (uniform distribution) |\n| `request_nomotion_update` | std_srvs/Empty | Forces filter update without robot motion |\n| `set_map` | nav_msgs/SetMap | Sets a new map and initial pose |\n\nSources: [amcl/src/amcl_node.cpp](477-483), [amcl/src/amcl_node.cpp](485-498)\n\n### 2.7 Configuration\n\nAMCL has numerous parameters that can be adjusted for optimal performance. Key parameter categories include:\n\n#### Particle Filter Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `min_particles` | 100 | Minimum allowed number of particles |\n| `max_particles` | 5000 | Maximum allowed number of particles |\n| `kld_err` | 0.01 | Error bound for KLD sampling |\n| `kld_z` | 0.99 | Upper standard normal quantile for KLD sampling |\n\n#### Update Thresholds\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `update_min_d` | 0.2 | Minimum translation (meters) before updating |\n| `update_min_a` | /6 | Minimum rotation (radians) before updating |\n| `resample_interval` | 2 | Number of updates between resampling |\n\n#### Laser Model Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `laser_model_type` | \"likelihood_field\" | Type of laser model (\"beam\", \"likelihood_field\", \"likelihood_field_prob\") |\n| `laser_z_hit` | 0.95 | Weight for hits in the model |\n| `laser_z_rand` | 0.05 | Weight for random measurements |\n| `laser_sigma_hit` | 0.2 | Standard deviation for Gaussian model |\n| `laser_likelihood_max_dist` | 2.0 | Maximum distance for likelihood field |\n\n#### Odometry Model Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `odom_model_type` | \"diff\" | Type of odometry model (\"diff\", \"omni\", \"diff-corrected\", \"omni-corrected\") |\n| `odom_alpha1` | 0.2 | Rotation noise from rotation |\n| `odom_alpha2` | 0.2 | Rotation noise from translation |\n| `odom_alpha3` | 0.2 | Translation noise from translation |\n| `odom_alpha4` | 0.2 | Translation noise from rotation |\n| `odom_alpha5` | 0.2 | Translation noise parameter (omni only) |\n\n#### Frame IDs\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `global_frame_id` | \"map\" | Frame for the map |\n| `odom_frame_id` | \"odom\" | Frame for odometry |\n| `base_frame_id` | \"base_link\" | Frame for the robot base |\n\nSources: [amcl/cfg/AMCL.cfg](10-73), [amcl/src/amcl_node.cpp](364-469)\n\n### 2.8 Example Configuration\n\nHere's an example configuration from the test files:\n\n```xml\n\u003cnode pkg=\"amcl\" type=\"amcl\" name=\"amcl\"\u003e\n  \u003cparam name=\"min_particles\" value=\"500\"/\u003e\n  \u003cparam name=\"max_particles\" value=\"5000\"/\u003e\n  \u003cparam name=\"kld_err\" value=\"0.05\"/\u003e\n  \u003cparam name=\"kld_z\" value=\"0.99\"/\u003e\n  \n  \u003cparam name=\"odom_model_type\" value=\"diff\"/\u003e\n  \u003cparam name=\"odom_alpha1\" value=\"0.1\"/\u003e\n  \u003cparam name=\"odom_alpha2\" value=\"0.3\"/\u003e\n  \u003cparam name=\"odom_alpha3\" value=\"0.8\"/\u003e\n  \u003cparam name=\"odom_alpha4\" value=\"0.1\"/\u003e\n  \n  \u003cparam name=\"laser_z_hit\" value=\"0.5\"/\u003e\n  \u003cparam name=\"laser_z_rand\" value=\"0.5\"/\u003e\n  \u003cparam name=\"laser_sigma_hit\" value=\"0.25\"/\u003e\n  \u003cparam name=\"laser_max_range\" value=\"5.0\"/\u003e\n  \u003cparam name=\"laser_model_type\" value=\"likelihood_field\"/\u003e\n  \u003cparam name=\"laser_likelihood_max_dist\" value=\"2.0\"/\u003e\n  \n  \u003cparam name=\"update_min_d\" value=\"0.2\"/\u003e\n  \u003cparam name=\"update_min_a\" value=\"0.5\"/\u003e\n  \u003cparam name=\"resample_interval\" value=\"1\"/\u003e\n  \n  \u003cparam name=\"initial_pose_x\" value=\"14.049\"/\u003e\n  \u003cparam name=\"initial_pose_y\" value=\"24.234\"/\u003e\n  \u003cparam name=\"initial_pose_a\" value=\"-1.517\"/\u003e\n\u003c/node\u003e\n```\n\nSources: [amcl/test/texas_greenroom_loop.xml](7-38)\n\n## 3. fake_localization\n\nfake_localization is a simpler alternative to AMCL that directly converts odometry data to pose estimates in the map frame. This is useful for:\n\n1. **Testing navigation algorithms** without the complexity of real localization\n2. **Simulation environments** where perfect localization is desired\n3. **Debugging** to isolate problems from localization issues\n\nUnlike AMCL, fake_localization does not perform any probabilistic estimation. It simply takes the odometry data and publishes it as the robot's pose in the map frame, applying an optional static transform between the map and odometry frames.\n\n```mermaid\nflowchart LR\n    subgraph \"fake_localization\"\n        OdomSub[\"Odometry Subscriber\"]\n        TFPublish[\"TF Publisher\"]\n        PosePublish[\"Pose Publisher\"]\n    end\n    \n    OdomInput[\"Odometry Input\"] --\u003e OdomSub\n    InitialPose[\"Initial Pose\"] --\u003e TFPublish\n    \n    OdomSub --\u003e TFPublish\n    OdomSub --\u003e PosePublish\n    \n    TFPublish --\u003e TF[\"mapodom Transform\"]\n    PosePublish --\u003e Pose[\"amcl_pose\"]\n```\n\nSources: [fake_localization/package.xml](6)\n\n## 4. Integration with Navigation Stack\n\nLocalization is a critical component of the ROS Navigation Stack. It fits into the overall architecture as follows:\n\n```mermaid\nflowchart TD\n    subgraph \"Navigation System\"\n        MoveBase[\"move_base\"]\n        GlobalPlanner[\"Global Planners (navfn, etc.)\"]\n        LocalPlanner[\"Local Planners (DWA, etc.)\"]\n        Costmap[\"costmap_2d\"]\n        Recovery[\"Recovery Behaviors\"]\n    end\n    \n    subgraph \"Localization\"\n        AMCL[\"AMCL / fake_localization\"]\n    end\n    \n    subgraph \"Perception\"\n        LaserScan[\"Laser Scanner\"]\n        Odometry[\"Odometry Source\"]\n    end\n    \n    subgraph \"Map\"\n        MapServer[\"map_server\"]\n    end\n    \n    MapServer --\"Map Data\"--\u003e AMCL\n    MapServer --\"Map Data\"--\u003e Costmap\n    \n    LaserScan --\u003e AMCL\n    LaserScan --\u003e Costmap\n    \n    Odometry --\u003e AMCL\n    \n    AMCL --\"mapodom Transform\"--\u003e MoveBase\n    \n    MoveBase --\u003e GlobalPlanner\n    MoveBase --\u003e LocalPlanner\n    MoveBase --\u003e Recovery\n    \n    GlobalPlanner --\u003e Costmap\n    LocalPlanner --\u003e Costmap\n```\n\nSources: [navigation/package.xml](21-36)\n\nThe localization system:\n1. Consumes map data, sensor data, and odometry\n2. Produces the transform between the map and odometry frames\n3. Enables the robot to plan paths in the map frame and execute them in the local frame\n\nThe transform published by the localization system allows move_base to:\n- Receive goals in the map frame\n- Plan global paths in the map frame\n- Transform these paths to the robot's local frame for execution\n- Track the robot's progress through the map\n\n## 5. Common Usage Patterns\n\n### 5.1 Global Localization\n\nWhen the robot's initial pose is unknown, global localization can be performed:\n\n```bash\n# Using the service\nrosservice call /global_localization \"{}\"\n```\n\nThis initializes the particle filter with a uniform distribution across the map's free space. As the robot moves and senses the environment, the particles converge to the correct pose.\n\nSources: [amcl/src/amcl_node.cpp](1088-1102)\n\n### 5.2 Setting an Initial Pose\n\nWhen the robot's approximate initial pose is known, it can be set via the initialpose topic:\n\n```bash\n# Using rostopic\nrostopic pub /initialpose geometry_msgs/PoseWithCovarianceStamped \"header:\n  seq: 0\n  stamp:\n    secs: 0\n    nsecs: 0\n  frame_id: 'map'\npose:\n  pose:\n    position: {x: 1.0, y: 1.0, z: 0.0}\n    orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\n  covariance: [0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06853891945200942]\"\n```\n\nSources: [amcl/test/set_pose.py](10-32)\n\n### 5.3 Handling Dynamic Environments\n\nFor robots operating in environments with moving obstacles:\n\n1. Use the **Likelihood Field Model with Probabilities**:\n   ```\n   \u003cparam name=\"laser_model_type\" value=\"likelihood_field_prob\"/\u003e\n   ```\n\n2. Enable beam skipping:\n   ```\n   \u003cparam name=\"do_beamskip\" value=\"true\"/\u003e\n   \u003cparam name=\"beam_skip_distance\" value=\"0.5\"/\u003e\n   \u003cparam name=\"beam_skip_threshold\" value=\"0.3\"/\u003e\n   ```\n\nThis helps AMCL ignore laser readings that are likely caused by dynamic obstacles.\n\nSources: [amcl/src/amcl/sensors/amcl_laser.cpp](305-494), [amcl/cfg/AMCL.cfg](26-28)\n\n### 5.4 Debugging and Visualization\n\n1. **Particle cloud visualization**:\n   - Use RViz to view the `/particlecloud` topic\n   - A widely dispersed cloud indicates uncertainty\n   - A concentrated cloud indicates confidence in the pose\n\n2. **TF tree inspection**:\n   - Use `rosrun tf2_tools view_frames.py` to verify the transform tree\n   - Check that the transform from map to odom is being published correctly\n\n3. **Parameter tuning**:\n   - Use dynamic reconfiguration: `rosrun rqt_reconfigure rqt_reconfigure`\n   - Adjust parameters and observe the effect on localization performance\n\n4. **Diagnostics**:\n   - AMCL publishes diagnostic information about the standard deviation of the pose estimate\n   - High standard deviation values indicate uncertainty in the localization\n\nSources: [amcl/src/amcl_node.cpp](256-264), [amcl/src/amcl_node.cpp](513-514)\n\n## 6. Conclusion\n\nThe ROS Navigation Stack provides two localization options: AMCL for probabilistic localization in real environments, and fake_localization for testing and simulation. AMCL is highly configurable and can be tuned for different robots and environments. Proper localization is essential for successful navigation, providing the critical link between the global map and the robot's local reference frame."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2c:T4886,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# AMCL\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/CMakeLists.txt](amcl/CMakeLists.txt)\n- [amcl/cfg/AMCL.cfg](amcl/cfg/AMCL.cfg)\n- [amcl/src/amcl/pf/eig3.c](amcl/src/amcl/pf/eig3.c)\n- [amcl/src/amcl/pf/pf.c](amcl/src/amcl/pf/pf.c)\n- [amcl/src/amcl/pf/pf_vector.c](amcl/src/amcl/pf/pf_vector.c)\n- [amcl/src/amcl/sensors/amcl_laser.cpp](amcl/src/amcl/sensors/amcl_laser.cpp)\n- [amcl/src/amcl_node.cpp](amcl/src/amcl_node.cpp)\n- [amcl/src/include/portable_utils.hpp](amcl/src/include/portable_utils.hpp)\n- [amcl/test/basic_localization.py](amcl/test/basic_localization.py)\n- [amcl/test/basic_localization_stage.xml](amcl/test/basic_localization_stage.xml)\n- [amcl/test/global_localization_stage.xml](amcl/test/global_localization_stage.xml)\n- [amcl/test/rosie_multilaser.xml](amcl/test/rosie_multilaser.xml)\n- [amcl/test/set_initial_pose.xml](amcl/test/set_initial_pose.xml)\n- [amcl/test/set_initial_pose_delayed.xml](amcl/test/set_initial_pose_delayed.xml)\n- [amcl/test/set_pose.py](amcl/test/set_pose.py)\n- [amcl/test/small_loop_crazy_driving_prg.xml](amcl/test/small_loop_crazy_driving_prg.xml)\n- [amcl/test/small_loop_crazy_driving_prg_corrected.xml](amcl/test/small_loop_crazy_driving_prg_corrected.xml)\n- [amcl/test/small_loop_prf.xml](amcl/test/small_loop_prf.xml)\n- [amcl/test/texas_greenroom_loop.xml](amcl/test/texas_greenroom_loop.xml)\n- [amcl/test/texas_willow_hallway_loop.xml](amcl/test/texas_willow_hallway_loop.xml)\n\n\u003c/details\u003e\n\n\n\nAMCL (Adaptive Monte Carlo Localization) is a probabilistic localization system for a robot moving in 2D. It implements an adaptive particle filter that uses a map, laser scans, and odometry to estimate the robot's pose. This page documents the AMCL implementation in the ROS navigation stack, focusing on its architecture, operation, and configuration.\n\n## Overview\n\nAMCL tracks the pose of a robot against a known map by maintaining a probability distribution over all possible poses. This distribution is represented using particles, each representing a potential pose of the robot. The key features of AMCL include:\n\n- Adaptation of particle count based on localization uncertainty\n- Support for multiple sensor models (beam, likelihood field)  \n- Multiple odometry models (differential, omnidirectional)\n- Dynamic reconfigurability\n- Ability to globally localize from an unknown initial pose\n\n```mermaid\nflowchart TD\n    subgraph \"AMCL System\"\n        AC[\"AmclNode\"]\n        PF[\"Particle Filter\"]\n        OM[\"Odometry Model\"]\n        LM[\"Laser Model\"]\n        \n        AC --\u003e PF\n        AC --\u003e OM\n        AC --\u003e LM\n    end\n    \n    subgraph \"Inputs\"\n        MAP[\"Map Data\"]\n        SN[\"Laser Scans\"]\n        OD[\"Odometry\"]\n        IP[\"Initial Pose\"]\n    end\n    \n    subgraph \"Outputs\"\n        EP[\"Estimated Pose\"]\n        PC[\"Particle Cloud\"]\n        TF[\"TF Transform\"]\n    end\n    \n    MAP --\u003e AC\n    SN --\u003e AC\n    OD --\u003e AC\n    IP --\u003e AC\n    \n    AC --\u003e EP\n    AC --\u003e PC\n    AC --\u003e TF\n```\n\nSources: [amcl/src/amcl_node.cpp:20-347]()\n\n## Architecture\n\nAMCL is implemented as a ROS node centered around the `AmclNode` class. This class manages the overall operation of the localization system, integrating the particle filter and sensor models.\n\n```mermaid\nclassDiagram\n    class AmclNode {\n        -pf_t* pf_\n        -map_t* map_\n        -AMCLOdom* odom_\n        -AMCLLaser* laser_\n        +AmclNode()\n        +~AmclNode()\n        +process()\n        +runFromBag()\n        -laserReceived()\n        -initialPoseReceived()\n        -mapReceived()\n    }\n    \n    class pf_t {\n        +int min_samples\n        +int max_samples\n        +pf_sample_set_t* sets\n        +pf_init()\n        +pf_update_sensor()\n        +pf_update_action()\n        +pf_update_resample()\n    }\n    \n    class AMCLLaser {\n        +laser_model_t model_type\n        +SetModelBeam()\n        +SetModelLikelihoodField()\n        +SetModelLikelihoodFieldProb()\n        +UpdateSensor()\n    }\n    \n    class AMCLOdom {\n        +odom_model_t model_type\n        +SetModel()\n        +UpdateAction()\n    }\n    \n    AmclNode --\u003e pf_t : uses\n    AmclNode --\u003e AMCLLaser : uses\n    AmclNode --\u003e AMCLOdom : uses\n    AmclNode --\u003e \"1\" map_t : uses\n```\n\nSources: [amcl/src/amcl_node.cpp:132-296](), [amcl/src/amcl/pf/pf.c:45-115](), [amcl/src/amcl/sensors/amcl_laser.cpp:44-54]()\n\n### Key Components\n\n1. **AmclNode**: Core class that manages the particle filter, processes sensor data, and interfaces with ROS.\n2. **Particle Filter (pf_t)**: Maintains and updates the set of pose hypotheses.\n3. **Sensor Models**:\n   - **AMCLLaser**: Processes laser scan data and updates particle weights\n   - **AMCLOdom**: Uses odometry to predict particle movement\n4. **Map**: 2D occupancy grid representation of the environment\n\n## Particle Filter Operation\n\nThe core of AMCL is its particle filter implementation. The particle filter tracks multiple hypotheses about the robot's pose and updates them based on sensor measurements.\n\n```mermaid\nflowchart TB\n    subgraph \"Particle Filter Operation\"\n        direction TB\n        INIT[\"Initialize Particles\"]\n        PRED[\"Predict with Odometry\"]\n        UPD[\"Update with Sensor Data\"]\n        RESAMP[\"Resample Particles\"]\n        \n        INIT --\u003e PRED\n        PRED --\u003e UPD\n        UPD --\u003e RESAMP\n        RESAMP --\u003e|Next cycle| PRED\n    end\n    \n    subgraph \"Particle Adaptation\"\n        KLD[\"KLD Sampling\"]\n        CONV[\"Convergence Detection\"]\n        \n        KLD --\u003e RESAMP\n        CONV --\u003e RESAMP\n    end\n    \n    subgraph \"Recovery\"\n        RAW[\"Random Weight Average\"]\n        RAND[\"Add Random Samples\"]\n        \n        RAW --\u003e RAND\n        RAND --\u003e RESAMP\n    end\n```\n\nSources: [amcl/src/amcl/pf/pf.c:253-263](), [amcl/src/amcl/pf/pf.c:362-510]()\n\n### Initialization\n\nThe particle filter can be initialized either with:\n- A Gaussian distribution around a specific pose (e.g., from a saved position)\n- A uniform distribution across the map (for global localization)\n\n```cpp\n// Initialize with a Gaussian distribution\nvoid pf_init(pf_t *pf, pf_vector_t mean, pf_matrix_t cov)\n\n// Initialize with a uniform distribution \nvoid pf_init_model(pf_t *pf, pf_init_model_fn_t init_fn, void *init_data)\n```\n\nSources: [amcl/src/amcl/pf/pf.c:136-211]()\n\n### Prediction and Update\n\nThe particle filter follows a standard prediction-update cycle:\n1. **Prediction**: Use odometry to predict how particles move\n2. **Update**: Use sensor data to weigh particles based on how well they match observations\n3. **Resampling**: Periodically sample a new set of particles based on current weights\n\nThe key to adaptivity is that AMCL adjusts the number of particles based on localization certainty, using Kullback-Leibler Divergence (KLD) sampling.\n\n## Sensor Models\n\nAMCL supports multiple sensor models for laser scanners:\n\n```mermaid\nflowchart TD\n    subgraph \"Laser Models\"\n        BM[\"Beam Model\"]\n        LF[\"Likelihood Field\"]\n        LFP[\"Likelihood Field Prob\"]\n    end\n    \n    subgraph \"Odometry Models\"\n        DIFF[\"Differential Drive\"]\n        OMNI[\"Omnidirectional\"]\n        DIFFC[\"Differential Corrected\"]\n        OMNIC[\"Omnidirectional Corrected\"]\n    end\n    \n    BM --\u003e WEIGHT[\"Particle Weighting\"]\n    LF --\u003e WEIGHT\n    LFP --\u003e WEIGHT\n    \n    DIFF --\u003e MOTION[\"Particle Motion\"]\n    OMNI --\u003e MOTION\n    DIFFC --\u003e MOTION\n    OMNIC --\u003e MOTION\n    \n    WEIGHT --\u003e PF[\"Particle Filter\"]\n    MOTION --\u003e PF\n```\n\nSources: [amcl/src/amcl/sensors/amcl_laser.cpp:120-139](), [amcl/cfg/AMCL.cfg:54-63]()\n\n### Laser Models\n\n1. **Beam Model**: Models laser beams by comparing measured ranges to expected ranges\n   - Parameters: z_hit, z_short, z_max, z_rand, sigma_hit, lambda_short\n   - Implementation in `BeamModel()` function\n\n2. **Likelihood Field**: Pre-computes a distance field from the map and uses it to evaluate scans\n   - Parameters: z_hit, z_rand, sigma_hit, laser_likelihood_max_dist\n   - More efficient than beam model\n   - Implementation in `LikelihoodFieldModel()` function\n\n3. **Likelihood Field Prob**: Extended likelihood field model with beam skipping capabilities\n   - Adds ability to ignore beams that don't match the map (for dynamic obstacles)\n   - Parameters: beam_skip_distance, beam_skip_threshold, beam_skip_error_threshold\n   - Implementation in `LikelihoodFieldModelProb()` function\n\nSources: [amcl/src/amcl/sensors/amcl_laser.cpp:144-494]()\n\n### Odometry Models\n\n1. **Differential Drive**: Standard model for robots with differential drive\n2. **Omnidirectional**: For robots that can move in any direction\n3. **Corrected Models**: Variants that account for additional noise sources\n\nEach model has noise parameters (alpha1-alpha5) that can be tuned for the specific robot.\n\n## Configuration\n\nAMCL offers extensive configuration through ROS parameters. Key parameters include:\n\n### Particle Filter Parameters\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| min_particles | Minimum allowed number of particles | 100 |\n| max_particles | Maximum allowed number of particles | 5000 |\n| kld_err | KLD sampling error | 0.01 |\n| kld_z | KLD sampling z-value | 0.99 |\n| update_min_d | Minimum translation before filter update | 0.2 meters |\n| update_min_a | Minimum rotation before filter update | 0.5 radians |\n| resample_interval | Number of updates between resampling | 2 |\n| recovery_alpha_slow | Slow filter decay rate for recovery | 0.001 |\n| recovery_alpha_fast | Fast filter decay rate for recovery | 0.1 |\n\nSources: [amcl/cfg/AMCL.cfg:10-24]()\n\n### Sensor Model Parameters\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| laser_model_type | Type of laser model: beam, likelihood_field, likelihood_field_prob | likelihood_field |\n| laser_z_hit | Mixture weight for z_hit part of model | 0.95 |\n| laser_z_short | Mixture weight for z_short part of model | 0.1 |\n| laser_z_max | Mixture weight for z_max part of model | 0.05 |\n| laser_z_rand | Mixture weight for z_rand part of model | 0.05 |\n| laser_sigma_hit | Standard deviation for Gaussian model in z_hit | 0.2 |\n| laser_max_beams | How many beams to use per scan | 30 |\n| do_beamskip | Whether to skip beams for dynamic obstacle handling | false |\n\nSources: [amcl/cfg/AMCL.cfg:39-55]()\n\n### Frame and Integration Parameters\n\n| Parameter | Description | Default |\n|-----------|-------------|---------|\n| odom_frame_id | Frame ID for odometry | \"odom\" |\n| base_frame_id | Frame ID for robot base | \"base_link\" |\n| global_frame_id | Frame ID for map | \"map\" |\n| transform_tolerance | How long TF transforms remain valid | 0.1 seconds |\n| gui_publish_rate | Rate for visualization publishing | -1 (disabled) |\n| use_map_topic | Whether to get map from topic instead of service | false |\n| first_map_only | Whether to use only first received map | false |\n\nSources: [amcl/cfg/AMCL.cfg:29-37](), [amcl/cfg/AMCL.cfg:71-73]()\n\n## Operation Flow\n\nThe following sequence diagram shows how AMCL processes data during operation:\n\n```mermaid\nsequenceDiagram\n    participant Map as map_server\n    participant Laser as laser_scan\n    participant Odom as odometry\n    participant AMCL\n    participant TF as tf\n    participant Client as navigation_clients\n    \n    Note over AMCL: Initialization\n    Map-\u003e\u003eAMCL: Occupancy Grid\n    Note over AMCL: Initialize particle filter\n    \n    loop Main operation\n        Laser-\u003e\u003eAMCL: LaserScan message\n        AMCL-\u003e\u003eTF: Look up transform\n        TF-\u003e\u003eAMCL: Odometry pose\n        \n        Note over AMCL: Calculate robot motion\n        alt Motion threshold met\n            Note over AMCL: Apply odometry model\n            Note over AMCL: Apply laser model\n            Note over AMCL: Resample if needed\n            AMCL-\u003e\u003eClient: PoseWithCovarianceStamped\n            AMCL-\u003e\u003eTF: Publish map-\u003eodom transform\n        end\n    end\n    \n    alt Global localization requested\n        Client-\u003e\u003eAMCL: global_localization service\n        Note over AMCL: Reinitialize with uniform distribution\n    end\n    \n    alt New initial pose provided\n        Client-\u003e\u003eAMCL: initialpose message\n        Note over AMCL: Reinitialize around specified pose\n    end\n```\n\nSources: [amcl/src/amcl_node.cpp:173-176](), [amcl/src/amcl_node.cpp:1023-1047]()\n\n## Key Methods\n\n### AmclNode Initialization\n\nThe `AmclNode` constructor initializes the node, sets up parameters, and creates publishers, subscribers, and services:\n\n```cpp\nAmclNode::AmclNode()\n```\n\nKey initialization steps:\n1. Load parameters from parameter server\n2. Initialize ROS publishers and subscribers\n3. Set up services (global_localization, etc.)\n4. Create TF listener and broadcaster\n5. Set up dynamic reconfiguration\n\nSources: [amcl/src/amcl_node.cpp:349-515]()\n\n### Laser Processing\n\n```cpp\nvoid AmclNode::laserReceived(const sensor_msgs::LaserScanConstPtr\u0026 laser_scan)\n```\n\nThis method is called when a new laser scan is received. It:\n1. Gets the odometry pose\n2. Updates the filter with the new odometry and laser data\n3. Publishes the updated pose and particle cloud\n\nSources: [amcl/src/amcl_node.cpp:1023-1047]()\n\n### Particle Filter Update\n\nThe core update functions in the particle filter:\n\n```cpp\n// Update with motion\nvoid pf_update_action(pf_t *pf, pf_action_model_fn_t action_fn, void *action_data)\n\n// Update with sensor measurements\nvoid pf_update_sensor(pf_t *pf, pf_sensor_model_fn_t sensor_fn, void *sensor_data)\n\n// Resample particles\nvoid pf_update_resample(pf_t *pf)\n```\n\nSources: [amcl/src/amcl/pf/pf.c:253-263](), [amcl/src/amcl/pf/pf.c:267-318](), [amcl/src/amcl/pf/pf.c:362-510]()\n\n## Advanced Features\n\n### Beam Skipping\n\nAMCL includes a beam skipping feature in the likelihood field model that helps handle dynamic obstacles:\n\n```cpp\nvoid AMCLLaser::SetModelLikelihoodFieldProb(double z_hit,\n                                           double z_rand,\n                                           double sigma_hit,\n                                           double max_occ_dist,\n                                           bool do_beamskip,\n                                           double beam_skip_distance,\n                                           double beam_skip_threshold,\n                                           double beam_skip_error_threshold)\n```\n\nThis feature:\n- Identifies beams that don't match the map for a majority of particles\n- Skips these beams when calculating particle weights\n- Helps prevent the filter from being affected by dynamic obstacles not in the map\n\nSources: [amcl/src/amcl/sensors/amcl_laser.cpp:100-118](), [amcl/src/amcl/sensors/amcl_laser.cpp:333-492]()\n\n### Adaptive Sampling\n\nAMCL adapts the number of particles based on localization uncertainty:\n\n```cpp\nint pf_resample_limit(pf_t *pf, int k)\n```\n\nThis function implements Kullback-Leibler Divergence (KLD) sampling to determine the number of particles needed to adequately represent the current distribution.\n\nSources: [amcl/src/amcl/pf/pf.c:515-555]()\n\n## Usage with Navigation Stack\n\nAMCL integrates with the broader navigation stack through:\n\n```mermaid\nflowchart TD\n    subgraph \"Navigation Stack\"\n        MAPSERVER[\"map_server\"]\n        MOVEBASE[\"move_base\"]\n        LOCALPLANNER[\"Local Planner\"]\n        GLOBALPLANNER[\"Global Planner\"]\n    end\n    \n    subgraph \"AMCL\"\n        PF[\"Particle Filter\"]\n        LASER[\"Laser Processor\"]\n        ODOM[\"Odometry Processor\"]\n    end\n    \n    subgraph \"Robot Hardware\"\n        LASERSCAN[\"Laser Scanner\"]\n        ODOMETRY[\"Odometry Source\"]\n    end\n    \n    MAPSERVER --\u003e|\"/map\"| AMCL\n    MAPSERVER --\u003e|\"/map\"| MOVEBASE\n    \n    LASERSCAN --\u003e|\"/scan\"| AMCL\n    ODOMETRY --\u003e|\"/odom\" TF| AMCL\n    \n    AMCL --\u003e|\"/amcl_pose\"| MOVEBASE\n    AMCL --\u003e|\"/particlecloud\"| VISUALIZATION[\"Visualization\"]\n    AMCL --\u003e|\"mapodom\" TF| MOVEBASE\n    \n    MOVEBASE --\u003e LOCALPLANNER\n    MOVEBASE --\u003e GLOBALPLANNER\n```\n\nSources: [amcl/src/amcl_node.cpp:477-478](), [amcl/src/amcl_node.cpp:479-483]()\n\n### Key Topics and Services\n\n- **Subscriptions**:\n  - `/scan` - Laser scan data\n  - `/map` (if use_map_topic=true) - Map data\n  - `/initialpose` - Initial pose estimates\n\n- **Publications**:\n  - `/amcl_pose` - Current pose estimate\n  - `/particlecloud` - Current set of pose hypotheses\n  - `/tf` - Transform between map and odometry frames\n\n- **Services**:\n  - `/global_localization` - Reinitialize the filter with a uniform pose distribution\n  - `/request_nomotion_update` - Force an update without motion\n  - `/set_map` - Set a new map and initial pose\n\nSources: [amcl/src/amcl_node.cpp:477-483](), [amcl/src/amcl_node.cpp:485-501]()\n\n## Common Configuration Scenarios\n\n### Global Localization vs. Position Tracking\n\n1. **Position Tracking** (when initial pose is known):\n   - Set initial_pose_x, initial_pose_y, initial_pose_a to known position\n   - Use lower number of particles (min_particles parameter)\n\n2. **Global Localization** (when initial pose is unknown):\n   - Call global_localization service after startup\n   - Use higher number of particles (max_particles parameter)\n   - May need to adjust recovery_alpha_fast to recover from incorrect convergence\n\nSources: [amcl/test/global_localization_stage.xml:46-47](), [amcl/test/basic_localization_stage.xml:44-48]()\n\n### Tuning for Different Environments\n\n1. **Large, open environments**:\n   - Increase max_particles for better coverage\n   - Increase update_min_d and update_min_a to reduce computation\n\n2. **Complex, cluttered environments**:\n   - Use likelihood_field_prob model with beam skipping\n   - Adjust laser_max_beams based on computational constraints\n   - May need higher min_particles for robustness\n\n3. **Dynamic environments**:\n   - Enable do_beamskip (set to true)\n   - Tune beam_skip_threshold and beam_skip_distance\n\nSources: [amcl/test/small_loop_crazy_driving_prg.xml:12-33](), [amcl/test/texas_willow_hallway_loop.xml:12-29]()\n\n## Troubleshooting\n\nCommon issues with AMCL include:\n\n1. **Poor localization accuracy**:\n   - Check odometry model parameters (alpha1-alpha5)\n   - Ensure correct laser model for your environment\n   - Verify map accuracy and resolution\n\n2. **Filter divergence**:\n   - Increase recovery_alpha_fast to recover from incorrect convergence\n   - Ensure update_min_d and update_min_a are appropriate for your robot's motion\n\n3. **High CPU usage**:\n   - Reduce max_particles\n   - Increase update_min_d and update_min_a\n   - Reduce laser_max_beams\n\n4. **TF-related errors**:\n   - Verify correct frame IDs (odom_frame_id, base_frame_id, global_frame_id)\n   - Increase transform_tolerance if system has timing issues\n\nSources: [amcl/src/amcl_node.cpp:836-844](), [amcl/src/amcl_node.cpp:436-469]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2d:T20c9,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Fake Localization\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/package.xml](amcl/package.xml)\n- [fake_localization/CMakeLists.txt](fake_localization/CMakeLists.txt)\n- [fake_localization/package.xml](fake_localization/package.xml)\n- [map_server/package.xml](map_server/package.xml)\n- [nav_core/CMakeLists.txt](nav_core/CMakeLists.txt)\n- [navigation/package.xml](navigation/package.xml)\n\n\u003c/details\u003e\n\n\n\n## Purpose and Scope\n\nFake Localization is a lightweight ROS node that provides a simplified alternative to actual localization algorithms like [AMCL](#6.1). Instead of performing complex probabilistic pose estimation, it simply forwards odometry information, optionally applying a specified global offset. It is primarily designed for testing and simulation purposes when perfect localization is desired.\n\nSources: [fake_localization/package.xml:6]()\n\n## Overview\n\nFake Localization provides a way to simulate perfect localization while maintaining the same ROS interfaces as \"real\" localization systems like AMCL. This makes it useful for isolating navigation stack issues from localization issues during development and testing. It transforms odometry information into the map coordinate frame, providing a \"ground truth\" pose that perfectly reflects the robot's actual position.\n\n```mermaid\ngraph TD\n    subgraph \"Localization Methods\"\n        direction LR\n        FL[\"fake_localization\"]\n        AMCL[\"amcl\"]\n    end\n    \n    OD[\"Odometry\\n/odom\"]\n    TF[\"TF\\n/tf\"]\n    MI[\"Map Info\\n/map\"]\n    \n    INIT[\"Initial Pose\\n/initialpose\"]\n    \n    PO[\"Pose\\n/amcl_pose\"]\n    PCL[\"Particle Cloud\\n/particlecloud\"]\n    \n    OD --\u003e FL\n    INIT --\u003e FL\n    TF --\u003e FL\n    MI -.-\u003e FL\n    \n    FL --\u003e PO\n    FL --\u003e PCL\n    FL --\u003e TF\n    \n    style FL fill:white,stroke:black\n    style AMCL fill:white,stroke:black,stroke-dasharray: 5 5\n```\n\n**Diagram 1: Fake Localization in the Navigation Stack**\n\nSources: [fake_localization/package.xml:6](), [fake_localization/CMakeLists.txt:30-35]()\n\n## Components\n\nFake Localization consists of two main components:\n\n1. **fake_localization node** - The C++ implementation that transforms odometry into map-frame pose estimates\n2. **static_odom_broadcaster.py** - A Python utility script for broadcasting static odometry transforms for testing\n\n```mermaid\nclassDiagram\n    class FakeLocalization {\n        -tf2_ros::Buffer* tf_\n        -tf2_ros::TransformListener* tfl_\n        -ros::NodeHandle nh_\n        -ros::Publisher pose_pub_\n        -ros::Publisher particlecloud_pub_\n        -ros::Subscriber odom_sub_\n        -ros::Subscriber initialpose_sub_\n        +handleOdomMessage()\n        +handleInitialPoseMessage()\n        +publishTransform()\n    }\n    \n    class StaticOdomBroadcaster {\n        -TransformBroadcaster br\n        -publishTransform()\n        -main()\n    }\n```\n\n**Diagram 2: Fake Localization Components**\n\nSources: [fake_localization/CMakeLists.txt:30-35](), [fake_localization/CMakeLists.txt:38-41]()\n\n## Functionality and Data Flow\n\nFake Localization functions by:\n\n1. Subscribing to odometry messages (typically `/odom`)\n2. Optionally receiving an initial pose (via `/initialpose`)\n3. Transforming odometry data to the map frame using a fixed transform \n4. Publishing the transformed pose as localization output (via `/amcl_pose`)\n5. Publishing an artificial particle cloud (via `/particlecloud`)\n6. Broadcasting the map-\u003eodom transform via TF\n\nThis process maintains the same interface as AMCL but without the computational overhead or uncertainty of particle filter-based localization.\n\n```mermaid\nsequenceDiagram\n    participant OD as Odometry Source\n    participant FL as fake_localization\n    participant MB as move_base\n    participant TF as TF System\n    \n    OD-\u003e\u003eFL: /odom message\n    FL-\u003e\u003eFL: Apply offset transform\n    FL-\u003e\u003eMB: /amcl_pose\n    FL-\u003e\u003eFL: Generate artificial particles\n    FL-\u003e\u003eMB: /particlecloud\n    FL-\u003e\u003eTF: Broadcast mapodom transform\n    \n    Note over MB: Uses pose for navigation\n```\n\n**Diagram 3: Data Flow in Fake Localization**\n\nSources: [fake_localization/package.xml:20-26]()\n\n## Configuration Parameters\n\nFake Localization can be configured with several parameters:\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `~odom_frame_id` | string | The frame ID of the odometry source (default: \"odom\") |\n| `~base_frame_id` | string | The robot's base frame ID (default: \"base_link\") |\n| `~global_frame_id` | string | The global frame ID (default: \"map\") |\n| `~delta_x` | double | X offset to apply to odometry (default: 0.0) |\n| `~delta_y` | double | Y offset to apply to odometry (default: 0.0) |\n| `~delta_yaw` | double | Yaw offset to apply to odometry (default: 0.0) |\n| `~tf_broadcast` | bool | Whether to broadcast the map-\u003eodom transform (default: true) |\n\nSources: [fake_localization/package.xml:17-18]()\n\n## Comparison with AMCL\n\nThe following table highlights the key differences between Fake Localization and AMCL:\n\n| Feature | Fake Localization | AMCL |\n|---------|------------------|------|\n| Algorithm | Simple odometry forwarding | Adaptive Monte Carlo Localization |\n| Particle Filter | No (artificial particles only) | Yes (adaptive sampling) |\n| Sensor Input | Odometry only | Laser scans, odometry |\n| Computational Load | Very low | Moderate to high |\n| Uncertainty Handling | None (perfect localization) | Probabilistic |\n| Use Case | Testing, simulation | Real-world operation |\n| Accuracy | Perfect in simulation, poor in real-world | Varies based on environment |\n\nSources: [fake_localization/package.xml:6]()\n\n## Usage Examples\n\n### Basic Launch Configuration\n\n```xml\n\u003cnode pkg=\"fake_localization\" type=\"fake_localization\" name=\"fake_localization\"\u003e\n  \u003cparam name=\"odom_frame_id\" value=\"odom\"/\u003e\n  \u003cparam name=\"base_frame_id\" value=\"base_link\"/\u003e\n  \u003cparam name=\"global_frame_id\" value=\"map\"/\u003e\n  \n  \u003c!-- Optional offset --\u003e\n  \u003cparam name=\"delta_x\" value=\"0.0\"/\u003e\n  \u003cparam name=\"delta_y\" value=\"0.0\"/\u003e\n  \u003cparam name=\"delta_yaw\" value=\"0.0\"/\u003e\n\u003c/node\u003e\n```\n\n### Using with Static Odometry (for fully simulated testing)\n\n```xml\n\u003cnode pkg=\"fake_localization\" type=\"static_odom_broadcaster.py\" name=\"fake_odom\"\u003e\n  \u003cparam name=\"odom_frame_id\" value=\"odom\"/\u003e\n  \u003cparam name=\"base_frame_id\" value=\"base_link\"/\u003e\n\u003c/node\u003e\n\n\u003cnode pkg=\"fake_localization\" type=\"fake_localization\" name=\"fake_localization\"\u003e\n  \u003cparam name=\"odom_frame_id\" value=\"odom\"/\u003e\n  \u003cparam name=\"base_frame_id\" value=\"base_link\"/\u003e\n\u003c/node\u003e\n```\n\n## Limitations\n\n1. Does not perform actual localization - simply forwards and transforms odometry\n2. Assumes that odometry is perfect (or has a fixed error that can be corrected with a static offset)\n3. Cannot handle dynamic environments or changing conditions\n4. Not suitable for real-world deployment where localization uncertainty exists\n5. Does not make use of sensor data (e.g., laser scans) for position correction\n\nSources: [fake_localization/package.xml:6](), [fake_localization/package.xml:20-26]()\n\n## Integration with Navigation Stack\n\nFake Localization integrates with the Navigation Stack in the same way as AMCL, making it a drop-in replacement for testing purposes. It provides the pose information required by move_base and other navigation components.\n\n```mermaid\ngraph TD\n    subgraph \"Navigation Stack\"\n        MB[\"move_base\"]\n        GP[\"Global Planner\"]\n        LP[\"Local Planner\"]\n        CM[\"costmap_2d\"]\n    end\n    \n    subgraph \"Localization\"\n        FL[\"fake_localization\"]\n        FL_O[\"/odom\"]\n        FL_P[\"/amcl_pose\"]\n        FL_T[\"/tf (mapodom)\"]\n    end\n    \n    FL_O --\u003e FL\n    FL --\u003e FL_P\n    FL --\u003e FL_T\n    \n    FL_P --\u003e MB\n    FL_T --\u003e MB\n    FL_T --\u003e CM\n    \n    MB --\u003e GP\n    MB --\u003e LP\n    GP --\u003e CM\n    LP --\u003e CM\n```\n\n**Diagram 4: Fake Localization Integration with Navigation Stack**\n\nSources: [navigation/package.xml:27]()\n\n## Summary\n\nFake Localization provides a simplified localization solution that is primarily useful for:\n\n1. Testing other components of the navigation stack in isolation\n2. Simulation environments where perfect localization is desired\n3. Development of navigation algorithms without the complexity of real localization\n4. Benchmarking performance against ideal localization\n\nFor actual robot deployments in real environments, more robust localization approaches like [AMCL](#6.1) should be used instead."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2e:T28bc,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Recovery Behaviors\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h](clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h)\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp](clear_costmap_recovery/src/clear_costmap_recovery.cpp)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/include/costmap_2d/costmap_layer.h](costmap_2d/include/costmap_2d/costmap_layer.h)\n- [costmap_2d/src/costmap_layer.cpp](costmap_2d/src/costmap_layer.cpp)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h](rotate_recovery/include/rotate_recovery/rotate_recovery.h)\n- [rotate_recovery/src/rotate_recovery.cpp](rotate_recovery/src/rotate_recovery.cpp)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n\n\u003c/details\u003e\n\n\n\nRecovery behaviors in the ROS Navigation Stack provide mechanisms for robots to recover from navigation failures. When a robot gets stuck, can't find a valid path, or encounters other navigation difficulties, these behaviors are executed to attempt to resolve the situation and continue navigation.\n\nFor information about the overall Navigation Stack architecture, see [Overview](#1) and [Architecture](#1.1).\n\n## Interface and Integration\n\nRecovery behaviors implement the `nav_core::RecoveryBehavior` interface, providing a plugin architecture that allows for easy customization and extension.\n\n```mermaid\nclassDiagram\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class ClearCostmapRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class RotateRecovery {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class MoveSlowAndClear {\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    RecoveryBehavior \u003c|-- ClearCostmapRecovery\n    RecoveryBehavior \u003c|-- RotateRecovery\n    RecoveryBehavior \u003c|-- MoveSlowAndClear\n```\n\nSources: \n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h:37-87]()\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h:37-86]()\n\n### Integration with move_base\n\nRecovery behaviors are loaded as plugins by the `move_base` node and executed in sequence when the robot encounters difficulties in navigation. The `move_base` node manages a state machine that determines when to trigger recovery actions.\n\n```mermaid\nsequenceDiagram\n    participant MoveBase as \"move_base\"\n    participant GlobalPlanner as \"Global Planner\"\n    participant LocalPlanner as \"Local Planner\"\n    participant RecoveryManager as \"Recovery Manager\"\n    participant Recovery1 as \"Recovery Behavior 1\"\n    participant Recovery2 as \"Recovery Behavior 2\"\n    \n    MoveBase-\u003e\u003eGlobalPlanner: Request plan\n    alt Plan failed\n        GlobalPlanner-\u003e\u003eMoveBase: Failure\n        MoveBase-\u003e\u003eRecoveryManager: Execute recovery\n        RecoveryManager-\u003e\u003eRecovery1: runBehavior()\n        opt If first recovery fails\n            RecoveryManager-\u003e\u003eRecovery2: runBehavior()\n        end\n        MoveBase-\u003e\u003eGlobalPlanner: Try planning again\n    else Plan succeeded\n        GlobalPlanner-\u003e\u003eMoveBase: Return plan\n        MoveBase-\u003e\u003eLocalPlanner: Execute plan\n        alt Execution stuck\n            LocalPlanner-\u003e\u003eMoveBase: Failure\n            MoveBase-\u003e\u003eRecoveryManager: Execute recovery\n            RecoveryManager-\u003e\u003eRecovery1: runBehavior()\n            opt If first recovery fails\n                RecoveryManager-\u003e\u003eRecovery2: runBehavior()\n            end\n            MoveBase-\u003e\u003eLocalPlanner: Try execution again\n        end\n    end\n```\n\nSources:\n- [move_base/CMakeLists.txt:1-87]()\n\n## Standard Recovery Behaviors\n\nThe Navigation Stack provides three standard recovery behaviors:\n\n### Clear Costmap Recovery\n\nThis behavior clears obstacles from the costmap within a specified area around the robot. It's useful when the costmap has accumulated obstacles that are no longer present in the environment or when sensor errors have introduced phantom obstacles.\n\n```mermaid\nflowchart TD\n    subgraph \"ClearCostmapRecovery\"\n        A[\"initialize()\"] --\u003e B[\"runBehavior()\"]\n        B --\u003e C[\"clear(costmap)\"]\n        C --\u003e D[\"clearMap(layer, pose_x, pose_y)\"]\n        D --\u003e E[\"worldToMapNoBounds()\"]\n        E --\u003e F[\"clearArea()\"]\n    end\n```\n\nKey features:\n- Can be configured to clear local costmap, global costmap, or both\n- Can clear inside or outside a specified square around the robot\n- Configurable reset distance parameter\n- Can be configured to clear specific costmap layers only\n\nSources:\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:1-189]()\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h:1-88]()\n- [costmap_2d/src/costmap_layer.cpp:21-36]()\n\n### Rotate Recovery\n\nThis behavior rotates the robot in place to search for free space. When a robot becomes stuck, performing a full rotation can help find an escape route.\n\n```mermaid\nflowchart TD\n    subgraph \"RotateRecovery\"\n        A[\"initialize()\"] --\u003e B[\"runBehavior()\"]\n        B --\u003e C[\"Get current robot pose\"]\n        C --\u003e D[\"Start rotation loop\"]\n        D --\u003e E[\"Check footprint for collision\"]\n        E --\u003e F[\"Compute velocity command\"]\n        F --\u003e G[\"Publish cmd_vel\"]\n        G --\u003e H{\"Completed\\nfull rotation?\"}\n        H --\u003e|\"No\"| D\n        H --\u003e|\"Yes\"| I[\"Exit\"]\n    end\n```\n\nKey features:\n- Rotates the robot 360 in place\n- Uses acceleration and velocity limits from the local planner\n- Checks for potential collisions before rotating\n- Stops if it detects a potential collision during rotation\n\nSources:\n- [rotate_recovery/src/rotate_recovery.cpp:1-184]()\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h:1-87]()\n\n### Move Slow and Clear\n\nThis behavior reduces the robot's speed and clears the costmap around it. It's useful when the robot needs to navigate through tight spaces or areas with uncertain obstacles.\n\nKey features:\n- Temporarily limits the robot's velocity\n- Clears obstacles from the costmap\n- Gradually returns to normal velocity after a set time or distance\n\n## Configuration\n\nRecovery behaviors are configured through the `move_base` parameters. A typical configuration in a launch file looks like:\n\n```xml\n\u003cnode pkg=\"move_base\" type=\"move_base\" name=\"move_base\" output=\"screen\"\u003e\n  \u003c!-- Recovery Parameters --\u003e\n  \u003cparam name=\"recovery_behavior_enabled\" value=\"true\"/\u003e\n  \u003cparam name=\"clearing_rotation_allowed\" value=\"true\"/\u003e\n  \n  \u003crosparam file=\"$(find my_robot_navigation)/params/recovery_behaviors.yaml\" command=\"load\"/\u003e\n\u003c/node\u003e\n```\n\n### Sample Configuration (YAML)\n\n```yaml\nrecovery_behaviors:\n  - name: conservative_reset\n    type: clear_costmap_recovery/ClearCostmapRecovery\n  - name: rotate_recovery\n    type: rotate_recovery/RotateRecovery\n  - name: aggressive_reset\n    type: clear_costmap_recovery/ClearCostmapRecovery\n\nconservative_reset:\n  reset_distance: 3.0\n  affected_maps: both\n  layer_names: [\"obstacles\"]\n\naggressive_reset:\n  reset_distance: 5.0\n  affected_maps: both\n  layer_names: [\"obstacles\"]\n\nrotate_recovery:\n  frequency: 20.0\n  sim_granularity: 0.017\n```\n\n## Clear Costmap Recovery Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `reset_distance` | double | 3.0 | Size (in meters) of the square area to clear |\n| `affected_maps` | string | \"both\" | Maps to clear: \"local\", \"global\", or \"both\" |\n| `layer_names` | string[] | [\"obstacles\"] | Names of layers to clear |\n| `invert_area_to_clear` | boolean | false | If true, clears inside the square instead of outside |\n| `force_updating` | boolean | false | If true, forces costmap update after clearing |\n\nSources:\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:52-81]()\n\n## Rotate Recovery Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `sim_granularity` | double | 0.017 | Angular granularity (radians) for collision checking |\n| `frequency` | double | 20.0 | Control loop frequency in Hz |\n| `acc_lim_th` | double | 3.2 | Rotational acceleration limit |\n| `max_rotational_vel` | double | 1.0 | Maximum rotational velocity |\n| `min_rotational_vel` | double | 0.4 | Minimum rotational velocity |\n| `yaw_goal_tolerance` | double | 0.10 | Tolerance (radians) for considering rotation complete |\n\nSources:\n- [rotate_recovery/src/rotate_recovery.cpp:58-86]()\n\n## State Machine Integration\n\n```mermaid\nstateDiagram-v2\n    [*] --\u003e Planning\n    Planning --\u003e Controlling: Plan Found\n    Planning --\u003e RecoveryTrigger: Planning Failed\n    Controlling --\u003e RecoveryTrigger: Controlling Failed\n    Controlling --\u003e [*]: Goal Reached\n    \n    state RecoveryTrigger {\n        [*] --\u003e ClearCostmapRecovery\n        ClearCostmapRecovery --\u003e RotateRecovery: If Failed\n        RotateRecovery --\u003e MoveSlowAndClear: If Failed\n        MoveSlowAndClear --\u003e [*]: If Failed\n    }\n    \n    RecoveryTrigger --\u003e Planning: Try Again\n```\n\n## Custom Recovery Behaviors\n\nTo implement a custom recovery behavior:\n\n1. Create a class that inherits from `nav_core::RecoveryBehavior`\n2. Implement the required interface methods:\n   - `initialize(name, tf, global_costmap, local_costmap)`\n   - `runBehavior()`\n3. Export the class as a plugin using the `pluginlib` macros\n4. Add the behavior to your recovery behaviors configuration\n\nExample plugin export:\n\n```cpp\n#include \u003cpluginlib/class_list_macros.hpp\u003e\nPLUGINLIB_EXPORT_CLASS(my_namespace::MyRecoveryBehavior, nav_core::RecoveryBehavior)\n```\n\nSources:\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:42-43]()\n- [rotate_recovery/src/rotate_recovery.cpp:49-50]()"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"2f:T3039,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Clear Costmap Recovery\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h](clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h)\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp](clear_costmap_recovery/src/clear_costmap_recovery.cpp)\n- [costmap_2d/include/costmap_2d/costmap_layer.h](costmap_2d/include/costmap_2d/costmap_layer.h)\n- [costmap_2d/src/costmap_layer.cpp](costmap_2d/src/costmap_layer.cpp)\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h](rotate_recovery/include/rotate_recovery/rotate_recovery.h)\n- [rotate_recovery/src/rotate_recovery.cpp](rotate_recovery/src/rotate_recovery.cpp)\n\n\u003c/details\u003e\n\n\n\n## Introduction\n\nThe Clear Costmap Recovery behavior is a recovery mechanism within the ROS Navigation Stack that enables a robot to recover from navigation failures caused by obstacles in the costmap that may no longer exist in the real world. When a robot gets stuck during navigation, this behavior can clear out potentially stale obstacle data from the costmap, allowing the robot to attempt navigation again with a \"fresh\" view of its environment.\n\nThis page details the implementation, configuration, and usage of the Clear Costmap Recovery module. For information about other recovery behaviors, see [Recovery Behaviors](#7).\n\nSources: [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h:45-49]()\n\n## How It Works\n\nThe Clear Costmap Recovery behavior operates by selectively clearing portions of the costmap. When activated, it identifies a square region around the robot's current position (based on the configured reset distance) and removes obstacle information within that area, resetting those cells to the `NO_INFORMATION` state.\n\n```mermaid\nflowchart TD\n    subgraph \"Clear Costmap Recovery Process\"\n        A[\"Initialize\"] --\u003e B[\"Get Robot Position\"]\n        B --\u003e C[\"Calculate Clear Area\"]\n        C --\u003e D[\"Clear Local and/or Global Costmaps\"]\n        D --\u003e E[\"Force Update Costmaps (if configured)\"]\n    end\n```\n\nSources: [clear_costmap_recovery/src/clear_costmap_recovery.cpp:89-129]()\n\n### Clearing Process\n\nWhen the `runBehavior()` method is called by the navigation stack:\n\n1. The robot's current position is obtained from the costmap\n2. A square area is calculated around this position based on the `reset_distance` parameter\n3. For each specified costmap (local, global, or both):\n   - The system identifies all costmap layers that match the specified `layer_names`\n   - Each matching layer is cleared within the calculated area\n   - If `force_updating` is enabled, the costmap is immediately updated\n\nThe clearing can be performed in two modes:\n- Clear outside the specified square (default)\n- Clear inside the specified square (when `invert_area_to_clear` is true)\n\n```mermaid\ngraph TD\n    subgraph \"ClearCostmapRecovery::runBehavior\"\n        start[\"Start Recovery\"]\n        check_init[\"Check Initialization\"]\n        check_costmaps[\"Check Costmaps\"]\n        log_action[\"Log Clearing Action\"]\n        decide_maps[\"Which Maps to Clear?\"]\n        \n        start --\u003e check_init\n        check_init --\u003e check_costmaps\n        check_costmaps --\u003e log_action\n        log_action --\u003e decide_maps\n        \n        decide_maps --\u003e|\"affected_maps_=global or both\"| clear_global[\"Clear Global Costmap\"]\n        decide_maps --\u003e|\"affected_maps_=local or both\"| clear_local[\"Clear Local Costmap\"]\n        \n        clear_global --\u003e|\"if force_updating_=true\"| update_global[\"Update Global Map\"]\n        clear_local --\u003e|\"if force_updating_=true\"| update_local[\"Update Local Map\"]\n    end\n    \n    subgraph \"ClearCostmapRecovery::clear\"\n        get_plugins[\"Get Costmap Plugins\"]\n        get_pose[\"Get Robot Pose\"]\n        iterate_plugins[\"Iterate Through Plugins\"]\n        check_layer[\"Is Layer in clearable_layers_?\"]\n        cast_layer[\"Cast to CostmapLayer\"]\n        \n        get_plugins --\u003e get_pose\n        get_pose --\u003e iterate_plugins\n        iterate_plugins --\u003e check_layer\n        check_layer --\u003e|\"Yes\"| cast_layer\n        cast_layer --\u003e clear_map[\"Clear Map Area\"]\n    end\n\n    clear_global --\u003e get_plugins\n    clear_local --\u003e get_plugins\n```\n\nSources: \n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:89-129]()\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:131-165]()\n\n### Clearing Algorithm\n\nThe actual clearing operation is performed by the `clearArea` method in the `CostmapLayer` class. This method iterates through all cells in the costmap and sets cells that satisfy the clearing condition to `NO_INFORMATION`.\n\nThe clearing condition depends on the `invert_area_to_clear` parameter:\n- When `false`: Cells outside the specified rectangle are cleared\n- When `true`: Cells inside the specified rectangle are cleared\n\n```mermaid\nflowchart TD\n    subgraph \"clearMap Function\"\n        F[\"Calculate Square Boundaries\"] --\u003e G[\"Call clearArea on CostmapLayer\"]\n    end\n    \n    subgraph \"clearArea Implementation\"\n        H[\"Loop through all costmap cells\"] --\u003e I[\"Check if cell is in target area\"]\n        I --\u003e|\"Clear condition satisfied\"| J[\"Set cell to NO_INFORMATION\"]\n        I --\u003e|\"Clear condition not satisfied\"| K[\"Leave cell unchanged\"]\n    end\n```\n\nSources: \n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:167-187]()\n- [costmap_2d/src/costmap_layer.cpp:21-36]()\n\n## Configuration Parameters\n\nThe Clear Costmap Recovery behavior can be configured through the following ROS parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `reset_distance` | double | 3.0 | Size of the square (in meters) to use for costmap clearing |\n| `invert_area_to_clear` | bool | false | When true, clears inside the square; when false, clears outside |\n| `force_updating` | bool | false | When true, forces an immediate update of the costmap after clearing |\n| `affected_maps` | string | \"both\" | Which costmaps to clear: \"local\", \"global\", or \"both\" |\n| `layer_names` | string[] | [\"obstacles\"] | Names of the costmap layers to clear |\n\nExample configuration in a launch file:\n\n```xml\n\u003cnode pkg=\"move_base\" type=\"move_base\" name=\"move_base\" output=\"screen\"\u003e\n  \u003c!-- Other configuration --\u003e\n  \n  \u003cparam name=\"recovery_behavior_enabled\" value=\"true\"/\u003e\n  \n  \u003crosparam param=\"recovery_behaviors\"\u003e\n    [{name: conservative_reset, type: clear_costmap_recovery/ClearCostmapRecovery},\n     {name: rotate_recovery, type: rotate_recovery/RotateRecovery},\n     {name: aggressive_reset, type: clear_costmap_recovery/ClearCostmapRecovery}]\n  \u003c/rosparam\u003e\n  \n  \u003cparam name=\"conservative_reset/reset_distance\" value=\"3.0\"/\u003e\n  \u003cparam name=\"conservative_reset/invert_area_to_clear\" value=\"false\"/\u003e\n  \u003cparam name=\"conservative_reset/affected_maps\" value=\"local\"/\u003e\n  \n  \u003cparam name=\"aggressive_reset/reset_distance\" value=\"4.0\"/\u003e\n  \u003cparam name=\"aggressive_reset/affected_maps\" value=\"both\"/\u003e\n\u003c/node\u003e\n```\n\nSources: [clear_costmap_recovery/src/clear_costmap_recovery.cpp:51-86]()\n\n## Implementation Details\n\n### Class Structure\n\nThe Clear Costmap Recovery behavior is implemented as a plugin to the ROS Navigation Stack's recovery behavior system. It inherits from the `nav_core::RecoveryBehavior` interface, which requires implementing the `initialize` and `runBehavior` methods.\n\n```mermaid\nclassDiagram\n    class \"nav_core::RecoveryBehavior\" {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class \"clear_costmap_recovery::ClearCostmapRecovery\" {\n        -global_costmap_: Costmap2DROS*\n        -local_costmap_: Costmap2DROS*\n        -tf_: tf2_ros::Buffer*\n        -initialized_: bool\n        -reset_distance_: double\n        -invert_area_to_clear_: bool\n        -force_updating_: bool\n        -affected_maps_: string\n        -clearable_layers_: set~string~\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n        -clear(costmap)\n        -clearMap(costmap, pose_x, pose_y)\n    }\n    \n    class \"costmap_2d::CostmapLayer\" {\n        +clearArea(start_x, start_y, end_x, end_y, invert_area)\n        +addExtraBounds(mx0, my0, mx1, my1)\n    }\n    \n    \"nav_core::RecoveryBehavior\" \u003c|-- \"clear_costmap_recovery::ClearCostmapRecovery\"\n    \"clear_costmap_recovery::ClearCostmapRecovery\" --\u003e \"costmap_2d::CostmapLayer\" : uses\n```\n\nSources:\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h:49-86]()\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:42-43]()\n\n### Plugin Registration\n\nThe Clear Costmap Recovery behavior is registered as a plugin using the `pluginlib` library. This allows it to be dynamically loaded by the move_base node based on the configuration.\n\n```cpp\nPLUGINLIB_EXPORT_CLASS(clear_costmap_recovery::ClearCostmapRecovery, nav_core::RecoveryBehavior)\n```\n\nSources: [clear_costmap_recovery/src/clear_costmap_recovery.cpp:43]()\n\n## Integration with Move Base\n\nThe Clear Costmap Recovery behavior is typically used as part of a sequence of recovery behaviors configured in the move_base node. When navigation fails, move_base will attempt each recovery behavior in sequence until navigation succeeds or all recovery behaviors have been tried.\n\n```mermaid\ngraph TD\n    subgraph \"move_base Node\"\n        MB[\"MoveBase\"]\n        SM[\"State Machine\"]\n        \n        MB --\u003e SM\n        SM --\u003e|\"Navigation Failure\"| RB[\"Recovery Behaviors\"]\n    end\n    \n    subgraph \"Recovery Behaviors\"\n        RB1[\"ClearCostmapRecovery (conservative)\"]\n        RB2[\"RotateRecovery\"]\n        RB3[\"ClearCostmapRecovery (aggressive)\"]\n        RB4[\"MoveSlowAndClear\"]\n        \n        RB --\u003e RB1\n        RB1 --\u003e|\"If still stuck\"| RB2\n        RB2 --\u003e|\"If still stuck\"| RB3\n        RB3 --\u003e|\"If still stuck\"| RB4\n    end\n    \n    RB1 --\u003e|\"Clears specified layers\"| CM[\"Costmap Layers\"]\n    RB3 --\u003e|\"Clears specified layers\"| CM\n    \n    subgraph \"Costmap Layers\"\n        OL[\"ObstacleLayer\"]\n        VL[\"VoxelLayer\"]\n        IL[\"InflationLayer\"]\n        SL[\"StaticLayer\"]\n    end\n```\n\nSources: \n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:89-129]()\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:131-165]()\n\n## Common Usage Patterns\n\nThe Clear Costmap Recovery behavior is typically used in two different configurations within the same recovery sequence:\n\n1. **Conservative Reset**: Applied early in the recovery sequence, this configuration typically clears only the local costmap or a small area, allowing the robot to attempt navigation with minimal disruption to its understanding of the environment.\n\n2. **Aggressive Reset**: Applied later in the recovery sequence, this configuration clears larger areas and/or both costmaps, providing a more \"fresh start\" when less aggressive recovery behaviors have failed.\n\nThis staged approach helps balance the need to recover from navigation failures with the desire to maintain as much valid environmental information as possible.\n\nSources: [clear_costmap_recovery/src/clear_costmap_recovery.cpp:100-106]()\n\n## Considerations and Limitations\n\n- Clearing the costmap is useful for handling false positives (obstacles that appear in the costmap but don't exist in reality), but won't help if the robot is actually stuck due to real obstacles.\n\n- The `force_updating` parameter can be important in time-critical situations, as it ensures the costmap is updated immediately after clearing rather than waiting for the next update cycle.\n\n- The behavior only clears specified layers; by default, it only clears the \"obstacles\" layer. This preserves information like static maps and inflation areas.\n\n- When using the inverted clearing mode (`invert_area_to_clear` set to true), only obstacles inside the specified square are cleared, which can be useful for targeted clearing of areas the robot is about to move through.\n\nSources:\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:100-106]()\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp:152-162]()\n\n## See Also\n\n- [Recovery Behaviors](#7) - Overview of all recovery behaviors\n- [Rotate Recovery](#7.2) - The rotation recovery behavior\n- [Move Slow and Clear](#7.3) - The move slow and clear recovery behavior\n- [Costmap2D](#2) - Information about the costmap system being cleared"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"30:T2375,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Rotate Recovery\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h](clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h)\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp](clear_costmap_recovery/src/clear_costmap_recovery.cpp)\n- [costmap_2d/include/costmap_2d/costmap_layer.h](costmap_2d/include/costmap_2d/costmap_layer.h)\n- [costmap_2d/src/costmap_layer.cpp](costmap_2d/src/costmap_layer.cpp)\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h](rotate_recovery/include/rotate_recovery/rotate_recovery.h)\n- [rotate_recovery/src/rotate_recovery.cpp](rotate_recovery/src/rotate_recovery.cpp)\n\n\u003c/details\u003e\n\n\n\nThe Rotate Recovery module is a recovery behavior in the ROS Navigation Stack that attempts to clear a path for the robot by performing an in-place rotation. When a robot gets stuck during navigation, this behavior can help find an escape route by rotating a full 360 degrees to scan for open paths.\n\nFor information about other recovery behaviors, see [Recovery Behaviors](#7) and [Clear Costmap Recovery](#7.1).\n\n## Overview\n\nThe Rotate Recovery behavior is implemented as a plugin to the recovery behavior framework. When activated, it instructs the robot to perform a full rotation in place, turning 180 degrees in one direction, then returning to its original orientation. During this rotation, it continuously checks for potential collisions to ensure the rotation can be performed safely.\n\nThis behavior is particularly useful in cluttered environments or when dynamic obstacles have blocked the robot's path but might leave temporary openings that can be discovered through rotation.\n\n```mermaid\nflowchart TD\n    subgraph \"RecoveryBehavior Plugin\"\n        RR[\"RotateRecovery\"]\n    end\n\n    subgraph \"Behavior Execution\"\n        RB[\"runBehavior()\"]\n        CP[\"Collision Checking\"]\n        VC[\"Velocity Control\"]\n        RB --\u003e CP\n        CP --\u003e VC\n    end\n\n    subgraph \"Components Used\"\n        LC[\"Local Costmap\"]\n        FCM[\"Footprint Cost Model\"]\n        CM[\"cmd_vel Publisher\"]\n    end\n\n    RR --\u003e RB\n    CP --\u003e LC\n    CP --\u003e FCM\n    VC --\u003e CM\n```\n\nSources: [rotate_recovery/include/rotate_recovery/rotate_recovery.h:47-84](), [rotate_recovery/src/rotate_recovery.cpp:52-86]()\n\n## Implementation\n\nThe Rotate Recovery behavior is implemented in the `rotate_recovery` package as the `RotateRecovery` class, which inherits from `nav_core::RecoveryBehavior`. It uses the local costmap to detect obstacles and check for potential collisions during rotation.\n\n```mermaid\nclassDiagram\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class RotateRecovery {\n        -costmap_2d::Costmap2DROS* local_costmap_\n        -bool initialized_\n        -double sim_granularity_\n        -double min_rotational_vel_\n        -double max_rotational_vel_\n        -double acc_lim_th_\n        -double tolerance_\n        -double frequency_\n        -CostmapModel* world_model_\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    RecoveryBehavior \u003c|-- RotateRecovery\n```\n\nSources: [rotate_recovery/include/rotate_recovery/rotate_recovery.h:47-84]()\n\n### Key Components\n\n1. **Plugin Registration**: The RotateRecovery class is registered as a plugin to the RecoveryBehavior interface using the `pluginlib` framework.\n\n2. **Local Costmap**: The behavior uses the local costmap to check for potential collisions during rotation.\n\n3. **Costmap Model**: A `base_local_planner::CostmapModel` is used to perform collision checking by evaluating the footprint cost at different angles.\n\n4. **Velocity Control**: The behavior calculates appropriate rotational velocities to execute the rotation smoothly.\n\nSources: [rotate_recovery/src/rotate_recovery.cpp:49-57](), [rotate_recovery/src/rotate_recovery.cpp:78-86]()\n\n## Behavior Execution\n\nWhen the `runBehavior()` method is called, the Rotate Recovery behavior performs the following steps:\n\n1. Retrieves the robot's current pose from the local costmap\n2. Records the starting orientation angle\n3. Begins a rotation toward a 180 turn (opposite direction)\n4. Checks if the rotation would cause a collision at each step\n5. Aborts if a collision is detected\n6. Once 180 is reached, continues to rotate back to the original orientation\n7. Publishes velocity commands to execute the rotation\n\n```mermaid\nsequenceDiagram\n    participant MoveBase as \"move_base\"\n    participant RotateRecovery as \"RotateRecovery\"\n    participant Costmap as \"Local Costmap\"\n    participant WorldModel as \"Costmap Model\"\n    participant CmdVel as \"cmd_vel Publisher\"\n    \n    MoveBase-\u003e\u003eRotateRecovery: runBehavior()\n    RotateRecovery-\u003e\u003eCostmap: getRobotPose()\n    Costmap--\u003e\u003eRotateRecovery: return current pose\n    \n    Note over RotateRecovery: Record starting orientation\n    \n    loop Until 180 reached and back to start\n        RotateRecovery-\u003e\u003eWorldModel: Check footprint collision\n        WorldModel-\u003e\u003eCostmap: Query for obstacle data\n        Costmap--\u003e\u003eWorldModel: Return costmap data\n        WorldModel--\u003e\u003eRotateRecovery: Return footprint cost\n        \n        alt If collision detected\n            RotateRecovery-\u003e\u003eMoveBase: Return (abort rotation)\n        else No collision\n            RotateRecovery-\u003e\u003eRotateRecovery: Calculate rotation velocity\n            RotateRecovery-\u003e\u003eCmdVel: Publish rotation command\n        end\n        \n        RotateRecovery-\u003e\u003eCostmap: getRobotPose()\n        Costmap--\u003e\u003eRotateRecovery: return updated pose\n    end\n    \n    RotateRecovery-\u003e\u003eMoveBase: Return (successful completion)\n```\n\nSources: [rotate_recovery/src/rotate_recovery.cpp:93-182]()\n\n### Collision Checking\n\nBefore executing rotation, the behavior checks if the intended rotation will cause a collision. This is done by simulating the rotation in small increments (defined by `sim_granularity_`) and checking if any position would result in a collision using the robot's footprint.\n\nIf a potential collision is detected at any point in the rotation, the behavior aborts and returns control to the move_base node, which may try a different recovery behavior.\n\nSources: [rotate_recovery/src/rotate_recovery.cpp:149-165]()\n\n### Velocity Control\n\nThe behavior calculates the rotational velocity using the formula:\n\n```\nvel = sqrt(2 * acc_lim_th_ * dist_left)\n```\n\nThis ensures smooth acceleration and deceleration during the rotation. The calculated velocity is constrained between `min_rotational_vel_` and `max_rotational_vel_` to maintain safe operation.\n\nSources: [rotate_recovery/src/rotate_recovery.cpp:168-171]()\n\n## Configuration Parameters\n\nThe Rotate Recovery behavior can be configured with the following parameters:\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `sim_granularity` | double | 0.017 | The granularity (in radians) with which to check for collisions during rotation (default: ~1 degree) |\n| `frequency` | double | 20.0 | The frequency at which velocity commands are published |\n| `acc_lim_th` | double | 3.2 | The rotational acceleration limit |\n| `max_rotational_vel` | double | 1.0 | Maximum rotational velocity |\n| `min_rotational_vel` | double | 0.4 | Minimum rotational velocity |\n| `yaw_goal_tolerance` | double | 0.10 | The tolerance (in radians) for reaching the goal orientation |\n\nThese parameters can be set in the navigation configuration file under the `~/\u003cname\u003e` namespace for RotateRecovery and under `~/TrajectoryPlannerROS` for the planner-related parameters.\n\nSources: [rotate_recovery/src/rotate_recovery.cpp:58-76]()\n\n## Usage in the Navigation Stack\n\nThe Rotate Recovery behavior is typically used by the `move_base` node as part of a sequence of recovery behaviors. When the robot gets stuck and cannot find a valid path, `move_base` will systematically try various recovery behaviors, including Rotate Recovery.\n\nThe order and parameters for recovery behaviors are configured in the `move_base` parameters, usually in a recovery_behaviors.yaml file or within the robot's navigation configuration.\n\nExample configuration for recovery behaviors:\n\n```yaml\nrecovery_behaviors:\n  - name: conservative_reset\n    type: clear_costmap_recovery/ClearCostmapRecovery\n  - name: rotate_recovery\n    type: rotate_recovery/RotateRecovery\n  - name: aggressive_reset\n    type: clear_costmap_recovery/ClearCostmapRecovery\n```\n\n## Limitations\n\n1. The Rotate Recovery behavior will fail if there are obstacles too close to the robot that would prevent a full rotation.\n2. The behavior assumes that by rotating, the robot may find a new path that wasn't visible before.\n3. It does not actively clear obstacles from the costmap, unlike the Clear Costmap Recovery behavior.\n\nFor more complex recovery scenarios, it might be used in combination with other recovery behaviors like [Clear Costmap Recovery](#7.1) or [Move Slow and Clear](#7.3)."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"31:T2664,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Move Slow and Clear\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [base_local_planner/CMakeLists.txt](base_local_planner/CMakeLists.txt)\n- [carrot_planner/CMakeLists.txt](carrot_planner/CMakeLists.txt)\n- [clear_costmap_recovery/CMakeLists.txt](clear_costmap_recovery/CMakeLists.txt)\n- [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h](clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h)\n- [clear_costmap_recovery/src/clear_costmap_recovery.cpp](clear_costmap_recovery/src/clear_costmap_recovery.cpp)\n- [costmap_2d/CMakeLists.txt](costmap_2d/CMakeLists.txt)\n- [costmap_2d/include/costmap_2d/costmap_layer.h](costmap_2d/include/costmap_2d/costmap_layer.h)\n- [costmap_2d/src/costmap_layer.cpp](costmap_2d/src/costmap_layer.cpp)\n- [dwa_local_planner/CMakeLists.txt](dwa_local_planner/CMakeLists.txt)\n- [global_planner/CMakeLists.txt](global_planner/CMakeLists.txt)\n- [move_base/CMakeLists.txt](move_base/CMakeLists.txt)\n- [move_slow_and_clear/CMakeLists.txt](move_slow_and_clear/CMakeLists.txt)\n- [navfn/CMakeLists.txt](navfn/CMakeLists.txt)\n- [rotate_recovery/CMakeLists.txt](rotate_recovery/CMakeLists.txt)\n- [rotate_recovery/include/rotate_recovery/rotate_recovery.h](rotate_recovery/include/rotate_recovery/rotate_recovery.h)\n- [rotate_recovery/src/rotate_recovery.cpp](rotate_recovery/src/rotate_recovery.cpp)\n- [voxel_grid/CMakeLists.txt](voxel_grid/CMakeLists.txt)\n\n\u003c/details\u003e\n\n\n\n## Introduction\n\nMove Slow and Clear is a recovery behavior in the ROS Navigation Stack designed to help robots navigate through challenging environments by temporarily reducing velocity limits and clearing obstacle information from the costmap. This behavior is particularly useful when a robot is stuck in a tight space or when the perceived environment contains potential false obstacles.\n\nFor information about the general recovery behavior framework, see [Recovery Behaviors](#7). For details on other specific recovery behaviors, see [Clear Costmap Recovery](#7.1) and [Rotate Recovery](#7.2).\n\nSources: [move_slow_and_clear/CMakeLists.txt:1-58]()\n\n## How It Works\n\nMove Slow and Clear combines two recovery techniques:\n\n1. **Speed Reduction**: Temporarily lowers the maximum velocity parameters of the local planner\n2. **Costmap Clearing**: Removes obstacle information from a region around the robot\n\nWhen triggered, this behavior first clears the costmap in a specified area around the robot's current position (similar to Clear Costmap Recovery). It then reduces the robot's maximum allowed velocities for a period of time, allowing more cautious navigation through the previously problematic area. After this period expires, the original velocity parameters are restored.\n\n```mermaid\nflowchart TD\n    subgraph \"Move Slow and Clear Behavior\"\n        A[\"runBehavior()\"] --\u003e B[\"Clear Local Costmap Area\"]\n        B --\u003e C[\"Reduce Speed Parameters\"]\n        C --\u003e D[\"Start Timer\"]\n        D --\u003e E[\"Wait for Timer or Distance Moved\"]\n        E --\u003e F[\"Restore Original Speed Parameters\"]\n    end\n```\n\nSources: [move_slow_and_clear/CMakeLists.txt:35-40](), [clear_costmap_recovery/src/clear_costmap_recovery.cpp:89-129]()\n\n## Integration with Navigation Stack\n\nMove Slow and Clear is one of the standard recovery behaviors used by the `move_base` node. Like other recovery behaviors, it implements the `RecoveryBehavior` interface from the `nav_core` package, which allows it to be loaded as a plugin.\n\n```mermaid\nclassDiagram\n    class RecoveryBehavior {\n        \u003c\u003cinterface\u003e\u003e\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n    }\n    \n    class MoveSlowAndClear {\n        -double clearing_distance_\n        -std::map~std::string, double~ original_params_\n        -ros::Duration duration_\n        -bool recovery_triggered_\n        +initialize(name, tf, global_costmap, local_costmap)\n        +runBehavior()\n        -reconfigurePlanner()\n        -restoreOriginalParams()\n        -clearCostmap()\n    }\n    \n    RecoveryBehavior \u003c|-- MoveSlowAndClear\n```\n\nThe `move_base` node calls different recovery behaviors in sequence when it gets stuck. Move Slow and Clear is typically called after simpler recovery behaviors like Clear Costmap Recovery and Rotate Recovery have failed to resolve the navigation issue.\n\nSources: [move_slow_and_clear/CMakeLists.txt:25-33](), [clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h:43-87](), [rotate_recovery/include/rotate_recovery/rotate_recovery.h:37-86]()\n\n## Workflow in Navigation System\n\nWhen a robot gets stuck or is unable to find a valid path, the recovery behaviors are triggered in sequence by the `move_base` node. Move Slow and Clear is typically one of the later recovery behaviors to be attempted.\n\n```mermaid\nsequenceDiagram\n    participant MB as \"move_base\"\n    participant CCR as \"Clear Costmap Recovery\"\n    participant RR as \"Rotate Recovery\"\n    participant MSC as \"Move Slow and Clear\"\n    participant LP as \"Local Planner\"\n    participant CM as \"Costmap\"\n    \n    MB-\u003e\u003eMB: Navigation fails\n    MB-\u003e\u003eCCR: Execute recovery\n    CCR-\u003e\u003eCM: Clear costmap area\n    CCR-\u003e\u003eMB: Recovery complete\n    \n    MB-\u003e\u003eMB: Navigation still failing\n    MB-\u003e\u003eRR: Execute recovery\n    RR-\u003e\u003eMB: Rotate robot\n    RR-\u003e\u003eMB: Recovery complete\n    \n    MB-\u003e\u003eMB: Navigation still failing\n    MB-\u003e\u003eMSC: Execute recovery\n    MSC-\u003e\u003eCM: Clear costmap area\n    MSC-\u003e\u003eLP: Reduce velocity limits\n    MSC-\u003e\u003eMB: Continue navigation at reduced speed\n    \n    Note over MSC: After time/distance threshold\n    \n    MSC-\u003e\u003eLP: Restore original velocity limits\n    MSC-\u003e\u003eMB: Recovery complete\n```\n\nSources: [move_slow_and_clear/CMakeLists.txt:35-40](), [clear_costmap_recovery/src/clear_costmap_recovery.cpp:89-129](), [rotate_recovery/src/rotate_recovery.cpp:93-182]()\n\n## Configuration Parameters\n\nMove Slow and Clear can be configured through the following ROS parameters:\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| clearing_distance | double | Radius around the robot to clear obstacles from the costmap (meters) |\n| limited_trans_speed | double | Reduced translational speed during recovery (m/s) |\n| limited_rot_speed | double | Reduced rotational speed during recovery (rad/s) |\n| limited_distance | double | Distance the robot must travel before restoring normal speeds (meters) |\n| duration | double | Time to maintain reduced speed before restoring normal speeds (seconds) |\n\nThese parameters are set in the recovery behavior section of your navigation configuration:\n\n```\nrecovery_behaviors: [\n  {name: conservative_reset, type: clear_costmap_recovery/ClearCostmapRecovery},\n  {name: rotate_recovery, type: rotate_recovery/RotateRecovery},\n  {name: move_slow_and_clear, type: move_slow_and_clear/MoveSlowAndClear}\n]\n\nmove_slow_and_clear:\n  clearing_distance: 0.5\n  limited_trans_speed: 0.1\n  limited_rot_speed: 0.2\n  limited_distance: 0.3\n  duration: 10.0\n```\n\nSources: [move_slow_and_clear/CMakeLists.txt:25-33](), [clear_costmap_recovery/src/clear_costmap_recovery.cpp:52-87](), [rotate_recovery/src/rotate_recovery.cpp:58-86]()\n\n## Implementation Details\n\n### Costmap Clearing\n\nMove Slow and Clear clears a portion of the costmap around the robot's current position, similar to how Clear Costmap Recovery works. This is done by setting grid cells in the specified area to `NO_INFORMATION`, allowing the robot to rediscover obstacles through sensors.\n\nThe clearing process:\n1. Gets the robot's current position\n2. Calculates the area to clear based on the `clearing_distance` parameter\n3. Uses the `clearArea` method from the `CostmapLayer` class to reset cells to `NO_INFORMATION`\n\n```mermaid\nflowchart LR\n    subgraph \"Costmap Clearing Process\"\n        A[\"Get Robot Position\"] --\u003e B[\"Calculate Area Bounds\"]\n        B --\u003e C[\"For Each Clearable Layer\"]\n        C --\u003e D[\"Call clearArea() Method\"]\n        D --\u003e E[\"Update Costmap\"]\n    end\n```\n\nSources: [clear_costmap_recovery/src/clear_costmap_recovery.cpp:131-187](), [costmap_2d/src/costmap_layer.cpp:21-36]()\n\n### Speed Limiting\n\nThe speed limiting aspect:\n1. Stores the original velocity parameters from the local planner\n2. Sets reduced velocity parameters using dynamic reconfiguration\n3. Starts a timer for the specified duration\n4. After the duration expires or distance threshold is reached, restores the original parameters\n\nThis approach is unique to Move Slow and Clear and distinguishes it from other recovery behaviors.\n\nSources: [move_slow_and_clear/CMakeLists.txt:35-40]()\n\n## Example Use Cases\n\nMove Slow and Clear is particularly effective in the following scenarios:\n\n1. **Narrow Passages**: When a robot needs to navigate through a tight space where normal speeds might cause collision\n2. **Uncertain Environments**: Areas with potential false obstacles or dynamic elements that might be incorrectly mapped\n3. **Fine Positioning**: When precise positioning is needed, such as docking or approaching a target\n4. **Recovery Cascade**: As part of a sequence of recovery behaviors when simpler recovery methods have failed\n\nBy combining obstacle clearing with reduced speeds, this recovery behavior offers a more comprehensive recovery strategy than the other recovery behaviors alone.\n\nSources: [move_slow_and_clear/CMakeLists.txt:1-58]()\n\n## Conclusion\n\nMove Slow and Clear provides a sophisticated recovery behavior that combines costmap clearing with temporary speed reduction. This dual approach helps robots navigate through challenging environments by both removing potentially false obstacles and increasing navigation caution. As part of the ROS Navigation Stack's recovery behavior system, it offers an important tool for improving navigation robustness, especially in complex or dynamic environments."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"32:T2d11,"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"# Map Server\n\n\u003cdetails\u003e\n\u003csummary\u003eRelevant source files\u003c/summary\u003e\n\nThe following files were used as context for generating this wiki page:\n\n- [amcl/CHANGELOG.rst](amcl/CHANGELOG.rst)\n- [amcl/package.xml](amcl/package.xml)\n- [base_local_planner/CHANGELOG.rst](base_local_planner/CHANGELOG.rst)\n- [carrot_planner/CHANGELOG.rst](carrot_planner/CHANGELOG.rst)\n- [clear_costmap_recovery/CHANGELOG.rst](clear_costmap_recovery/CHANGELOG.rst)\n- [costmap_2d/CHANGELOG.rst](costmap_2d/CHANGELOG.rst)\n- [dwa_local_planner/CHANGELOG.rst](dwa_local_planner/CHANGELOG.rst)\n- [fake_localization/CHANGELOG.rst](fake_localization/CHANGELOG.rst)\n- [fake_localization/package.xml](fake_localization/package.xml)\n- [global_planner/CHANGELOG.rst](global_planner/CHANGELOG.rst)\n- [map_server/CHANGELOG.rst](map_server/CHANGELOG.rst)\n- [map_server/CMakeLists.txt](map_server/CMakeLists.txt)\n- [map_server/include/map_server/image_loader.h](map_server/include/map_server/image_loader.h)\n- [map_server/package.xml](map_server/package.xml)\n- [map_server/src/image_loader.cpp](map_server/src/image_loader.cpp)\n- [map_server/src/main.cpp](map_server/src/main.cpp)\n- [map_server/src/map_saver.cpp](map_server/src/map_saver.cpp)\n- [map_server/src/map_server.dox](map_server/src/map_server.dox)\n- [map_server/test/rtest.cpp](map_server/test/rtest.cpp)\n- [map_server/test/rtest.xml](map_server/test/rtest.xml)\n- [map_server/test/spectrum.png](map_server/test/spectrum.png)\n- [map_server/test/test_constants.cpp](map_server/test/test_constants.cpp)\n- [map_server/test/test_constants.h](map_server/test/test_constants.h)\n- [map_server/test/testmap.yaml](map_server/test/testmap.yaml)\n- [map_server/test/testmap2.png](map_server/test/testmap2.png)\n- [map_server/test/testmap2.yaml](map_server/test/testmap2.yaml)\n- [map_server/test/utest.cpp](map_server/test/utest.cpp)\n- [move_base/CHANGELOG.rst](move_base/CHANGELOG.rst)\n- [move_slow_and_clear/CHANGELOG.rst](move_slow_and_clear/CHANGELOG.rst)\n- [navfn/CHANGELOG.rst](navfn/CHANGELOG.rst)\n- [navigation/package.xml](navigation/package.xml)\n- [voxel_grid/CHANGELOG.rst](voxel_grid/CHANGELOG.rst)\n\n\u003c/details\u003e\n\n\n\nThe Map Server is a core component of the ROS navigation stack that provides occupancy grid maps to other navigation components. It loads maps from image files, publishes them as ROS messages, and provides services for accessing map data. The package also includes a utility for saving maps generated by SLAM algorithms.\n\n## Architecture and Integration\n\nThe Map Server plays a central role in the navigation system by loading map data and making it available to other components.\n\n### Map Server in the Navigation Stack\n\n```mermaid\ngraph TD\n    subgraph \"Map Server Package\"\n        MS[\"map_server node\"]\n        MSV[\"map_saver utility\"]\n    end\n    \n    subgraph \"Map Data Sources\"\n        IMG[\"Image Files\\n(PNG/BMP)\"]\n        YAML[\"YAML Configuration\"]\n        SLAM[\"SLAM Generated Maps\"]\n    end\n    \n    subgraph \"Navigation Components\"\n        AMCL[\"amcl\\n(Localization)\"]\n        CM[\"costmap_2d\\n(Environment Representation)\"]\n        GP[\"Global Planners\\n(navfn, global_planner)\"]\n        LP[\"Local Planners\"]\n    end\n    \n    IMG --\u003e MS\n    YAML --\u003e MS\n    MS --\u003e |\"map topic\"| AMCL\n    MS --\u003e |\"map topic\"| CM\n    MS --\u003e |\"static_map service\"| GP\n    SLAM --\u003e |\"map topic\"| MSV\n    MSV --\u003e IMG\n    MSV --\u003e YAML\n```\n\nSources: [map_server/src/main.cpp](). [map_server/src/map_saver.cpp]().\n\n### Internal Structure\n\n```mermaid\nclassDiagram\n    class MapServer {\n        -ros::NodeHandle nh_\n        -ros::Publisher map_pub_\n        -ros::Publisher metadata_pub_\n        -ros::ServiceServer get_map_service_\n        -ros::ServiceServer change_map_srv_\n        -bool deprecated_\n        -std::string frame_id_\n        +MapServer(string fname, double res)\n        -bool mapCallback(request, response)\n        -bool changeMapCallback(request, response)\n        -bool loadMapFromValues(...)\n        -bool loadMapFromParams(...)\n        -bool loadMapFromYaml(...)\n    }\n    \n    class ImageLoader {\n        +loadMapFromFile(response, fname, res, negate, occ_th, free_th, origin, mode)\n    }\n    \n    class MapGenerator {\n        -std::string mapname_\n        -ros::Subscriber map_sub_\n        -bool saved_map_\n        -int threshold_occupied_\n        -int threshold_free_\n        +MapGenerator(mapname, threshold_occupied, threshold_free)\n        -void mapCallback(map)\n    }\n    \n    MapServer --\u003e ImageLoader : uses\n```\n\nSources: [map_server/src/main.cpp:60-297](). [map_server/src/image_loader.cpp:56-163](). [map_server/src/map_saver.cpp:43-129]().\n\n## Map Server Node\n\nThe `map_server` node loads map data from image files and makes it available to the navigation stack.\n\n### Map Loading Process\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MapServer\n    participant ImageLoader\n    participant NavigationComponent\n    \n    User-\u003e\u003eMapServer: \"rosrun map_server map_server map.yaml\"\n    MapServer-\u003e\u003eImageLoader: \"loadMapFromFile()\"\n    ImageLoader--\u003e\u003eMapServer: \"Return occupancy grid\"\n    MapServer-\u003e\u003eMapServer: \"Publish map to 'map' topic\"\n    MapServer-\u003e\u003eMapServer: \"Publish metadata to 'map_metadata' topic\"\n    \n    NavigationComponent-\u003e\u003eMapServer: \"Call 'static_map' service\"\n    MapServer--\u003e\u003eNavigationComponent: \"Return occupancy grid\"\n    \n    Note over User,MapServer: \"Map can be changed at runtime\"\n    User-\u003e\u003eMapServer: \"Call 'change_map' service\"\n    MapServer-\u003e\u003eImageLoader: \"loadMapFromFile() with new map\"\n    ImageLoader--\u003e\u003eMapServer: \"Return new occupancy grid\"\n    MapServer-\u003e\u003eMapServer: \"Publish updated map\"\n```\n\nSources: [map_server/src/main.cpp:63-168](). [map_server/test/rtest.cpp:82-188]().\n\n### Map Representation\n\nThe map_server converts image files into occupancy grids using the following process:\n\n1. Loads an image file (PNG, BMP) using SDL_image\n2. Processes each pixel according to the configured map mode\n3. Converts pixel values to occupancy values:\n   - 0: Free space\n   - 100: Occupied space\n   - -1: Unknown space (or values between 1-99 in SCALE mode)\n4. Publishes the resulting grid with appropriate metadata\n\nSources: [map_server/src/image_loader.cpp:56-163]().\n\n### YAML Configuration Parameters\n\n| Parameter | Description | Example Value |\n|-----------|-------------|---------------|\n| image | Path to the image file | map.png |\n| resolution | Map resolution in meters/pixel | 0.05 |\n| origin | Position and orientation [x, y, ] of the lower-left pixel | [0.0, 0.0, 0.0] |\n| negate | Whether to invert black/white free/occupied semantics | 0 |\n| occupied_thresh | Pixels with values greater than this are considered occupied | 0.65 |\n| free_thresh | Pixels with values less than this are considered free | 0.196 |\n| mode | Interpretation mode: trinary, scale, or raw | trinary |\n\nSources: [map_server/test/testmap.yaml:1-6](). [map_server/src/main.cpp:187-283]().\n\n### Map Modes\n\nThe map_server supports three different modes for interpreting pixel values:\n\n1. **TRINARY**: The default mode where cells are either:\n   - Free (0) if pixel value is below free_thresh\n   - Occupied (100) if pixel value is above occupied_thresh\n   - Unknown (-1) if pixel value is between thresholds\n\n2. **SCALE**: Similar to TRINARY but scales values between thresholds to range 1-99\n   - Free (0) if pixel value is below free_thresh\n   - Occupied (100) if pixel value is above occupied_thresh\n   - Scaled (1-99) based on a linear mapping between the thresholds\n\n3. **RAW**: Uses the raw pixel values directly without thresholding\n\nSources: [map_server/include/map_server/image_loader.h:38-52](). [map_server/src/image_loader.cpp:133-156]().\n\n### Services and Topics\n\n| Name | Type | Description |\n|------|------|-------------|\n| map | nav_msgs/OccupancyGrid | Published occupancy grid map |\n| map_metadata | nav_msgs/MapMetaData | Published metadata about the map |\n| static_map | nav_msgs/GetMap | Service to request the current map |\n| change_map | nav_msgs/LoadMap | Service to load a different map at runtime |\n\nSources: [map_server/src/main.cpp:74-84](). [map_server/src/main.cpp:109-135]().\n\n## Map Saver Utility\n\nThe `map_saver` utility allows saving maps published by SLAM algorithms as image files.\n\n### Map Saving Process\n\nWhen you run `map_saver`, it:\n1. Subscribes to the `map` topic waiting for an OccupancyGrid message\n2. When a map is received, converts the occupancy grid to a PGM image\n3. Creates a YAML file with the map metadata\n4. Saves both files using the specified name prefix\n\n```mermaid\ngraph TD\n    MSV[\"map_saver\"] --\u003e SUB[\"Subscribe to 'map' topic\"]\n    SUB --\u003e RECV[\"Receive OccupancyGrid message\"]\n    RECV --\u003e CONVPGM[\"Convert to PGM image\"]\n    RECV --\u003e META[\"Extract metadata\"]\n    CONVPGM --\u003e SAVEPGM[\"Save .pgm file\"]\n    META --\u003e SAVEYAML[\"Save .yaml file\"]\n```\n\nSources: [map_server/src/map_saver.cpp:43-129](). [map_server/src/map_saver.cpp:136-214]().\n\n### Command-line Options\n\n| Option | Description | Default |\n|--------|-------------|---------|\n| -h | Show usage information | |\n| -f \\\u003cmapname\\\u003e | Specify the name for the map files | map |\n| --occ \\\u003cthreshold\\\u003e | Set the threshold for considering a cell occupied | 65 |\n| --free \\\u003cthreshold\\\u003e | Set the threshold for considering a cell free | 25 |\n\nSources: [map_server/src/map_saver.cpp:132-201]().\n\n## Usage Examples\n\n### Starting the Map Server\n\nTo start the map_server with a map:\n\n```\nrosrun map_server map_server map.yaml\n```\n\nThe YAML file format example:\n\n```yaml\nimage: map.png\nresolution: 0.05\norigin: [0.0, 0.0, 0.0]\nnegate: 0\noccupied_thresh: 0.65\nfree_thresh: 0.196\nmode: trinary\n```\n\nSources: [map_server/src/main.cpp:299-326](). [map_server/test/testmap.yaml:1-6]().\n\n### Changing Maps at Runtime\n\nYou can change the map using the `change_map` service:\n\n```\nrosservice call /change_map \"map_url: '/path/to/new_map.yaml'\"\n```\n\nSources: [map_server/src/main.cpp:122-136](). [map_server/test/rtest.cpp:141-181]().\n\n### Saving a Map\n\nTo save a map published on the `map` topic:\n\n```\nrosrun map_server map_saver -f my_map\n```\n\nThis will create `my_map.pgm` and `my_map.yaml` files.\n\nSources: [map_server/src/map_saver.cpp:136-214]().\n\n## Integration with Navigation Stack Components\n\n### Map Data Flow in Navigation\n\n```mermaid\nflowchart TD\n    subgraph \"Map Server\"\n        MS[\"map_server\"]\n    end\n    \n    subgraph \"Localization\"\n        AMCL[\"amcl\"]\n        FL[\"fake_localization\"]\n    end\n    \n    subgraph \"Planning\"\n        subgraph \"Global Planning\"\n            NAVFN[\"navfn\"]\n            GP[\"global_planner\"]\n        end\n        \n        subgraph \"Local Planning\"\n            BLP[\"base_local_planner\"]\n            DWA[\"dwa_local_planner\"]\n        end\n    end\n    \n    subgraph \"Environment Representation\"\n        CM[\"costmap_2d\"]\n        SL[\"Static Layer\"]\n    end\n    \n    MS --\u003e |\"map topic\"| AMCL\n    MS --\u003e |\"map topic\"| FL\n    MS --\u003e |\"static_map service\"| CM\n    CM --\u003e SL\n    CM --\u003e NAVFN\n    CM --\u003e GP\n    CM --\u003e BLP\n    CM --\u003e DWA\n```\n\nSources: [map_server/package.xml:9-10](). [amcl/package.xml:43]().\n\n### Key Integration Points\n\n1. **AMCL and Localization**: The map provides the reference for AMCL to perform Monte Carlo localization\n\n2. **Costmap_2D**: The static map is used as a base layer in the layered costmap system, which is then used by both global and local planners\n\n3. **Global Planners**: Use the map information to plan paths through free space\n\n4. **move_base**: Coordinates the overall navigation process using map data as a foundation\n\nSources: [map_server/package.xml:9-10](). [navigation/package.xml:19-36]()."])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"5:[\"$\",\"$L12\",null,{\"repoName\":\"ros-planning/navigation\",\"hasConfig\":false,\"canSteer\":true,\"children\":[\"$\",\"$L13\",null,{\"wiki\":{\"metadata\":{\"repo_name\":\"ros-planning/navigation\",\"commit_hash\":\"9ad64419\",\"generated_at\":\"2025-04-27T02:23:59.707829\",\"config\":null,\"config_source\":null},\"pages\":[{\"page_plan\":{\"id\":\"1\",\"title\":\"Overview\"},\"content\":\"$14\"},{\"page_plan\":{\"id\":\"1.1\",\"title\":\"Architecture\"},\"content\":\"$15\"},{\"page_plan\":{\"id\":\"1.2\",\"title\":\"Packages\"},\"content\":\"$16\"},{\"page_plan\":{\"id\":\"1.3\",\"title\":\"Plugin System\"},\"content\":\"$17\"},{\"page_plan\":{\"id\":\"2\",\"title\":\"Costmap2D\"},\"content\":\"$18\"},{\"page_plan\":{\"id\":\"2.1\",\"title\":\"Costmap2DROS\"},\"content\":\"$19\"},{\"page_plan\":{\"id\":\"2.2\",\"title\":\"LayeredCostmap\"},\"content\":\"$1a\"},{\"page_plan\":{\"id\":\"2.3\",\"title\":\"Costmap Layers\"},\"content\":\"$1b\"},{\"page_plan\":{\"id\":\"2.3.1\",\"title\":\"Static Layer\"},\"content\":\"$1c\"},{\"page_plan\":{\"id\":\"2.3.2\",\"title\":\"Obstacle Layer\"},\"content\":\"$1d\"},{\"page_plan\":{\"id\":\"2.3.3\",\"title\":\"Inflation Layer\"},\"content\":\"$1e\"},{\"page_plan\":{\"id\":\"2.3.4\",\"title\":\"Voxel Layer\"},\"content\":\"$1f\"},{\"page_plan\":{\"id\":\"3\",\"title\":\"Move Base\"},\"content\":\"$20\"},{\"page_plan\":{\"id\":\"3.1\",\"title\":\"State Machine\"},\"content\":\"$21\"},{\"page_plan\":{\"id\":\"3.2\",\"title\":\"Action Interface\"},\"content\":\"$22\"},{\"page_plan\":{\"id\":\"3.3\",\"title\":\"Configuration\"},\"content\":\"$23\"},{\"page_plan\":{\"id\":\"4\",\"title\":\"Global Planners\"},\"content\":\"$24\"},{\"page_plan\":{\"id\":\"4.1\",\"title\":\"Navfn\"},\"content\":\"$25\"},{\"page_plan\":{\"id\":\"4.2\",\"title\":\"Global Planner\"},\"content\":\"$26\"},{\"page_plan\":{\"id\":\"4.3\",\"title\":\"Carrot Planner\"},\"content\":\"$27\"},{\"page_plan\":{\"id\":\"5\",\"title\":\"Local Planners\"},\"content\":\"$28\"},{\"page_plan\":{\"id\":\"5.1\",\"title\":\"Base Local Planner\"},\"content\":\"$29\"},{\"page_plan\":{\"id\":\"5.2\",\"title\":\"DWA Local Planner\"},\"content\":\"$2a\"},{\"page_plan\":{\"id\":\"6\",\"title\":\"Localization\"},\"content\":\"$2b\"},{\"page_plan\":{\"id\":\"6.1\",\"title\":\"AMCL\"},\"content\":\"$2c\"},{\"page_plan\":{\"id\":\"6.2\",\"title\":\"Fake Localization\"},\"content\":\"$2d\"},{\"page_plan\":{\"id\":\"7\",\"title\":\"Recovery Behaviors\"},\"content\":\"$2e\"},{\"page_plan\":{\"id\":\"7.1\",\"title\":\"Clear Costmap Recovery\"},\"content\":\"$2f\"},{\"page_plan\":{\"id\":\"7.2\",\"title\":\"Rotate Recovery\"},\"content\":\"$30\"},{\"page_plan\":{\"id\":\"7.3\",\"title\":\"Move Slow and Clear\"},\"content\":\"$31\"},{\"page_plan\":{\"id\":\"8\",\"title\":\"Map Server\"},\"content\":\"$32\"}]},\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]\n"])</script><script data-aria-hidden="true" aria-hidden="true">self.__next_f.push([1,"c:null\n10:[[\"$\",\"title\",\"0\",{\"children\":\"Inflation Layer | ros-planning/navigation | DeepWiki\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"The Inflation Layer is a critical component of the ROS Navigation Stack's costmap system that expands obstacles to account for the robot's physical dimensions and create a safety buffer for navigation\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Inflation Layer | ros-planning/navigation | DeepWiki\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"The Inflation Layer is a critical component of the ROS Navigation Stack's costmap system that expands obstacles to account for the robot's physical dimensions and create a safety buffer for navigation\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:url\",\"content\":\"https://deepwiki.com/ros-planning/navigation/2.3.3-inflation-layer\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:site_name\",\"content\":\"DeepWiki\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Inflation Layer | ros-planning/navigation | DeepWiki\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"The Inflation Layer is a critical component of the ROS Navigation Stack's costmap system that expands obstacles to account for the robot's physical dimensions and create a safety buffer for navigation\"}],[\"$\",\"link\",\"10\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/icon.png?66aaf51e0e68c818\",\"type\":\"image/png\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?a4f658907db0ab87\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]]\n"])</script><deepl-input-controller translate="no" data-aria-hidden="true" aria-hidden="true"><template shadowrootmode="open"><link rel="stylesheet" href="chrome-extension://cofdbpoegempjloogbagkncekinflcnj/build/content.css"><div dir="ltr" style="visibility: initial !important;"><div class="dl-input-translation-container svelte-95aucy"><div></div></div></div></template></deepl-input-controller><next-route-announcer style="position: absolute;" data-aria-hidden="true" aria-hidden="true"><template shadowrootmode="open"><div aria-live="assertive" id="__next-route-announcer__" role="alert" style="position: absolute; border: 0px; height: 1px; margin: -1px; padding: 0px; width: 1px; clip: rect(0px, 0px, 0px, 0px); overflow: hidden; white-space: nowrap; overflow-wrap: normal;"></div></template></next-route-announcer><iframe id="_hjSafeContext_27428220" title="_hjSafeContext" tabindex="-1" aria-hidden="true" src="./Inflation Layer _ ros-planning_navigation _ DeepWiki_files/saved_resource.html" data-aria-hidden="true" style="display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;"></iframe><div id="hl-aria-live-message-container" aria-live="polite" class="visually-hidden"></div><div id="hl-aria-live-alert-container" role="alert" aria-live="assertive" class="visually-hidden"></div><div data-state="open" data-slot="dialog-overlay" class="data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50 backdrop-blur-xs" data-aria-hidden="true" aria-hidden="true" style="pointer-events: auto;"></div><div role="dialog" id="radix-r3" aria-describedby="radix-r5" aria-labelledby="radix-r4" data-state="open" data-slot="dialog-content" class="data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed left-[50%] top-[50%] z-50 grid w-full translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border shadow-lg duration-200 bg-surface max-w-[90vw] p-0 sm:max-w-[90vw]" tabindex="-1" style="pointer-events: auto;"><button type="button" data-slot="dialog-close" class="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground rounded-xs focus:outline-hidden absolute right-2 top-2 opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 256 256" class="size-5"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"></path></svg><span class="sr-only">Close</span></button><div class="p-4"><div class="flex max-h-full max-w-full justify-center"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="2.869778633117676 -6.618520736694336 1265.203125 781" style="max-width: 100%; touch-action: none; user-select: none; cursor: grab; min-height: fit-content; max-height: 100%;" class="flowchart" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" id="mermaid-yi0e9ihi7p" preserveAspectRatio="xMidYMid meet"><style>#mermaid-yi0e9ihi7p{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-yi0e9ihi7p .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-yi0e9ihi7p .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-yi0e9ihi7p .error-icon{fill:#dddddd;}#mermaid-yi0e9ihi7p .error-text{fill:#222222;stroke:#222222;}#mermaid-yi0e9ihi7p .edge-thickness-normal{stroke-width:1px;}#mermaid-yi0e9ihi7p .edge-thickness-thick{stroke-width:3.5px;}#mermaid-yi0e9ihi7p .edge-pattern-solid{stroke-dasharray:0;}#mermaid-yi0e9ihi7p .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-yi0e9ihi7p .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-yi0e9ihi7p .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-yi0e9ihi7p .marker{fill:#999;stroke:#999;}#mermaid-yi0e9ihi7p .marker.cross{stroke:#999;}#mermaid-yi0e9ihi7p svg{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:16px;}#mermaid-yi0e9ihi7p p{margin:0;}#mermaid-yi0e9ihi7p .label{font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;color:#333;}#mermaid-yi0e9ihi7p .cluster-label text{fill:#444;}#mermaid-yi0e9ihi7p .cluster-label span{color:#444;}#mermaid-yi0e9ihi7p .cluster-label span p{background-color:transparent;}#mermaid-yi0e9ihi7p .label text,#mermaid-yi0e9ihi7p span{fill:#333;color:#333;}#mermaid-yi0e9ihi7p .node rect,#mermaid-yi0e9ihi7p .node circle,#mermaid-yi0e9ihi7p .node ellipse,#mermaid-yi0e9ihi7p .node polygon,#mermaid-yi0e9ihi7p .node path{fill:#ffffff;stroke:#dddddd;stroke-width:1px;}#mermaid-yi0e9ihi7p .rough-node .label text,#mermaid-yi0e9ihi7p .node .label text,#mermaid-yi0e9ihi7p .image-shape .label,#mermaid-yi0e9ihi7p .icon-shape .label{text-anchor:middle;}#mermaid-yi0e9ihi7p .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-yi0e9ihi7p .rough-node .label,#mermaid-yi0e9ihi7p .node .label,#mermaid-yi0e9ihi7p .image-shape .label,#mermaid-yi0e9ihi7p .icon-shape .label{text-align:center;}#mermaid-yi0e9ihi7p .node.clickable{cursor:pointer;}#mermaid-yi0e9ihi7p .root .anchor path{fill:#999!important;stroke-width:0;stroke:#999;}#mermaid-yi0e9ihi7p .arrowheadPath{fill:#0b0b0b;}#mermaid-yi0e9ihi7p .edgePath .path{stroke:#999;stroke-width:2.0px;}#mermaid-yi0e9ihi7p .flowchart-link{stroke:#999;fill:none;}#mermaid-yi0e9ihi7p .edgeLabel{background-color:#ffffff;text-align:center;}#mermaid-yi0e9ihi7p .edgeLabel p{background-color:#ffffff;}#mermaid-yi0e9ihi7p .edgeLabel rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-yi0e9ihi7p .labelBkg{background-color:rgba(255, 255, 255, 0.5);}#mermaid-yi0e9ihi7p .cluster rect{fill:#f8f8f8;stroke:#dddddd;stroke-width:1px;}#mermaid-yi0e9ihi7p .cluster text{fill:#444;}#mermaid-yi0e9ihi7p .cluster span{color:#444;}#mermaid-yi0e9ihi7p div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:ui-sans-serif,-apple-system,system-ui,Segoe UI,Helvetica;font-size:12px;background:#dddddd;border:1px solid hsl(0, 0%, 76.6666666667%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-yi0e9ihi7p .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-yi0e9ihi7p rect.text{fill:none;stroke-width:0;}#mermaid-yi0e9ihi7p .icon-shape,#mermaid-yi0e9ihi7p .image-shape{background-color:#ffffff;text-align:center;}#mermaid-yi0e9ihi7p .icon-shape p,#mermaid-yi0e9ihi7p .image-shape p{background-color:#ffffff;padding:2px;}#mermaid-yi0e9ihi7p .icon-shape rect,#mermaid-yi0e9ihi7p .image-shape rect{opacity:0.5;background-color:#ffffff;fill:#ffffff;}#mermaid-yi0e9ihi7p :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid-yi0e9ihi7p_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(0, 88.5)" class="root"><g class="clusters"><g data-look="classic" id="subGraph1" class="cluster"><rect height="588" width="753.79296875" y="8" x="8" style=""></rect><g transform="translate(323.748046875, 8)" class="cluster-label"><foreignobject height="24" width="122.296875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost Assignment</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X_Y_0" d="M257.036,99.5L242.245,105.75C227.454,112,197.871,124.5,183.08,138.333C168.289,152.167,168.289,167.333,168.289,174.917L168.289,182.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X_Z_0" d="M384.831,99.5L399.622,105.75C414.414,112,443.996,124.5,458.787,136.333C473.578,148.167,473.578,159.333,473.578,164.917L473.578,170.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Z_W_0" d="M402.66,252.5L391.294,258.75C379.929,265,357.199,277.5,345.834,289.333C334.469,301.167,334.469,312.333,334.469,317.917L334.469,323.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_Z_V_0" d="M536.579,252.5L546.675,258.75C556.771,265,576.964,277.5,587.06,291.333C597.156,305.167,597.156,320.333,597.156,327.917L597.156,335.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_V_U_0" d="M597.156,393.5L597.156,401.75C597.156,410,597.156,426.5,597.156,440.333C597.156,454.167,597.156,465.333,597.156,470.917L597.156,476.5"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(320.93359375, 72.5)" id="flowchart-X-10" class="node default"><rect height="54" width="160.578125" y="-27" x="-80.2890625" style="" class="basic label-container"></rect><g transform="translate(-50.2890625, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="100.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>If distance = 0</p></span></div></foreignobject></g></g><g transform="translate(168.2890625, 213.5)" id="flowchart-Y-11" class="node default"><rect height="54" width="250.578125" y="-27" x="-125.2890625" style="" class="basic label-container"></rect><g transform="translate(-95.2890625, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="190.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = LETHAL_OBSTACLE</p></span></div></foreignobject></g></g><g transform="translate(473.578125, 213.5)" id="flowchart-Z-13" class="node default"><rect height="78" width="260" y="-39" x="-130" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>If distance &lt;= inscribed_radius</p></span></div></foreignobject></g></g><g transform="translate(334.46875, 366.5)" id="flowchart-W-15" class="node default"><rect height="78" width="304.71875" y="-39" x="-152.359375" style="" class="basic label-container"></rect><g transform="translate(-122.359375, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="244.71875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = INSCRIBED_INFLATED_OBSTACLE</p></span></div></foreignobject></g></g><g transform="translate(597.15625, 366.5)" id="flowchart-V-17" class="node default"><rect height="54" width="89.59375" y="-27" x="-44.796875" style="" class="basic label-container"></rect><g transform="translate(-14.796875, -12)" style="" class="label"><rect></rect><foreignobject height="24" width="29.59375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Else</p></span></div></foreignobject></g></g><g transform="translate(597.15625, 519.5)" id="flowchart-U-19" class="node default"><rect height="78" width="258.546875" y="-39" x="-129.2734375" style="" class="basic label-container"></rect><g transform="translate(-99.2734375, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="198.546875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Cost = exponential decay<br>based on distance &amp; weight</p></span></div></foreignobject></g></g></g></g><g transform="translate(803.79296875, 0)" class="root"><g class="clusters"><g data-look="classic" id="subGraph0" class="cluster"><rect height="765" width="445.41015625" y="8" x="8" style=""></rect><g transform="translate(170.080078125, 8)" class="cluster-label"><foreignobject height="24" width="121.25"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Inflation Process</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M248.715,123.5L248.715,129.75C248.715,136,248.715,148.5,248.715,160.333C248.715,172.167,248.715,183.333,248.715,188.917L248.715,194.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_C_0" d="M248.715,276.5L248.715,282.75C248.715,289,248.715,301.5,248.715,313.333C248.715,325.167,248.715,336.333,248.715,341.917L248.715,347.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_0" d="M202.217,429.5L194.766,435.75C187.314,442,172.411,454.5,164.959,466.333C157.508,478.167,157.508,489.333,157.508,494.917L157.508,500.5"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_0" d="M157.508,582.5L157.508,588.75C157.508,595,157.508,607.5,164.449,619.572C171.389,631.643,185.271,643.286,192.212,649.108L199.152,654.929"></path><path marker-end="url(#mermaid-yi0e9ihi7p_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_C_0" d="M295.213,657.5L302.664,651.25C310.116,645,325.019,632.5,332.47,613.5C339.922,594.5,339.922,569,339.922,543.5C339.922,518,339.922,492.5,332.981,473.928C326.04,455.357,312.159,443.714,305.218,437.892L298.277,432.071"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignobject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignobject></g></g><g transform="translate(339.921875, 543.5)" class="edgeLabel"><g transform="translate(-45.1875, -12)" class="label"><foreignobject height="24" width="90.375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>For each cell</p></span></div></foreignobject></g></g></g><g class="nodes"><g transform="translate(248.71484375, 84.5)" id="flowchart-A-0" class="node default"><rect height="78" width="237.4375" y="-39" x="-118.71875" style="" class="basic label-container"></rect><g transform="translate(-88.71875, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="177.4375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Initialize with<br>LETHAL_OBSTACLE cells</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 237.5)" id="flowchart-B-1" class="node default"><rect height="78" width="222.515625" y="-39" x="-111.2578125" style="" class="basic label-container"></rect><g transform="translate(-81.2578125, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="162.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Place cells in<br>distance-sorted queue</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 390.5)" id="flowchart-C-3" class="node default"><rect height="78" width="242.28125" y="-39" x="-121.140625" style="" class="basic label-container"></rect><g transform="translate(-91.140625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="182.28125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Process cells in<br>increasing distance order</p></span></div></foreignobject></g></g><g transform="translate(157.5078125, 543.5)" id="flowchart-D-5" class="node default"><rect height="78" width="204.453125" y="-39" x="-102.2265625" style="" class="basic label-container"></rect><g transform="translate(-72.2265625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="144.453125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Assign cost based<br>on distance formula</p></span></div></foreignobject></g></g><g transform="translate(248.71484375, 696.5)" id="flowchart-E-7" class="node default"><rect height="78" width="253.578125" y="-39" x="-126.7890625" style="" class="basic label-container"></rect><g transform="translate(-96.7890625, -24)" style="" class="label"><rect></rect><foreignobject height="48" width="193.578125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Add neighbors to queue<br>with appropriate distances</p></span></div></foreignobject></g></g></g></g></g></g></g></svg></div></div></div><span data-radix-focus-guard="" tabindex="0" data-aria-hidden="true" aria-hidden="true" style="outline: none; opacity: 0; position: fixed; pointer-events: none;"></span></body></html>